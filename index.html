<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Zpl,Golang,TCP/IP,ElasticSearch,Redis,Mysql,OS,Life">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="随便记一下，顺便骚一下">
<meta name="keywords" content="技术、生活、健身">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员Zpl">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="程序员Zpl">
<meta property="og:description" content="随便记一下，顺便骚一下">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员Zpl">
<meta name="twitter:description" content="随便记一下，顺便骚一下">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>程序员Zpl</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Zpl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code and gym<br>做最强壮的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/algorithm-structure-learning/" itemprop="url">算法与数据结构基础学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:33:38+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。</p>
<h2 id="重要的问题类型"><a href="#重要的问题类型" class="headerlink" title="重要的问题类型"></a>重要的问题类型</h2><p>计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。<br>最重要的问题类型如下：</p>
<ul>
<li>排序</li>
<li>查找</li>
<li>字符串处理</li>
<li>图问题</li>
<li>组合问题</li>
<li>几何问题</li>
<li>数值问题</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序问题要求我们按照升序重新排列给定列表中的数据项。</p>
<p>我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人的平均成绩来对学生记录进行排序，这段特别选定的信息成为键（key）</p>
<p>计算机科学家通常只关心如何对键进行排序，哪怕表中的元素不是记录，也许仅仅是整数。</p>
<p>到目前为止科学家已经开发出了几十种不同的排序算法。但没有一种算法再任何情况下都是最优的。<br>有些算法比较适合随机排列的输入，而另一些则更适合基本有序的列表。有些算法仅适合排列驻留再快速存储器中的列表。而另一些可以用来对存储再磁盘上的大型文件排序，如此等等。</p>
<p>排序算法有两个特性值得一提：</p>
<ul>
<li>如果一个排序算法保留了等值元素的输入中的相对位置，就可以说它是稳定的。</li>
<li>如果一个算法不需要额外的存储空间（除了个别存储单元以外），我们就说它是在位（in-place）</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找问题就是在给定的集合（或者是多重集，它允许多个元素具有相同的值）中找一个给定的值（我们称之为查找键）。</p>
<p>对于查找来说，也没有一种算法在任何情况下都是最优的。有些算法比其他算法速度快，但需要更多的存储空间。有些算法速度非常快，但仅使用于有序的数组。</p>
<p>和排序算法不同，查找算法没有稳定性问题。但会发生其他问题。查找问题就必须结合另外两种操作一起考虑，在数据集合中添加和删除元素的操作。</p>
<p>在这种情况下必须仔细选择数据结构和算法。以便在各种操作的需求之间达到一个平衡。而且对于高效查找（以及添加和删除）的特大型数据集合来说，如何组织其结构是一个不同寻常的挑战，而这对实际应用具有非常重要的意义。</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串是字符表中的符号所构成序列。我们尤其关心文本串，它是由字母、数字以及特殊符号构成的；位串是由“0”和“1”构成的；</p>
<p>如何在文本查找一个给定的词，这一特殊问题引起了研究人员的特别关注，它们成为字符串匹配问题。类似这种查找的特性，人们发明了好几种算法。</p>
<h2 id="图问题"><a href="#图问题" class="headerlink" title="图问题"></a>图问题</h2><p>TODO</p>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>TODO</p>
<h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p>TODO</p>
<h2 id="数值问题"><a href="#数值问题" class="headerlink" title="数值问题"></a>数值问题</h2><p>TODO</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>数据结构定义：对相关的数据项进行组织的特殊架构。</p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一维数组是n个相同数据类型的元素构成的序列，他们连续存储在计算机的存储器种，我们只要指定数组的下标就能够访问这些元素</p>
<p>无论位于数组的什么为止，都能用相等的常量时间访问数组中的任何元素。这种特性不是链表所具有的。</p>
<p>数组可以实现多种其他的数据结构，比较出名是<strong>字符串</strong>。字符串是来自于字母表的字符序列，并以一个特殊字符来标志字符串的结束。<br>字符串的常见操作不同于其他数组的典型操作。字符串的典型操作包括计算字符串的长度，按照字典序（即字母顺序）确定两个字符串在排序时的顺序。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是0个或多个成为节点的元素构成的序列，每个节点包含两类信息：一类是数据；另一类是一个或者多个成为指针的链接，指向链表中其他元素。</p>
<p>如果指向链表其他元素位null的时候表明节点没有后继元素。</p>
<p>单链表中，除了尾节点，每个节点都包含一个指向下一个元素的指针。</p>
<p>为了访问链表中的某个特定元素，我们从链表的首节点开始，沿指针链向前遍历，直到访问到该特定元素为止。因此和数组不同，访问单链表元素所需要的时间依赖于该元素在的链表中的位置。</p>
<p>优点：</p>
<ul>
<li>链表不需要实现分配任何存储空间</li>
<li>插入和删除的效率也非常高，只要相关的节点重新连接就可以了。</li>
</ul>
<p>为了增加链表灵活性，链表通常从一个称为表头的特殊节点开始，这个节点包含链表的长度，包含一个指向头元素的指针，还有可以包含指向尾元素的指针。</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>这是单向链表的扩展结构，其中除了首尾两个节点，每个节点都同时包含指向前趋的指针和指向后继的指针。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列也是一种列表，只是删除元素在列表的一头进行，这一头成为队头（出队），查入元素在表的另一头进行，这一头成为队尾（入队），因此，队列是按照“先进先出”(First-In-First-Out FIFO)的方式运转。</p>
<p>队列也有许多重要的而英勇，其中包括一些图问题的算法。</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>从一个动态改变的候选集合中选择一个优先级最高的元素。有一种数据结构可以满足，称为优先队列。</p>
<p>优先队列是数据项中的一个集合，这些数据项都来自于一些全序域。对优先队列的主要操作包括查找最大元素、删除最大元素和查入新的元素。</p>
<p>我们可以基于数组或者有序数组来实现优先队列，但这两种都不是最高效率的方案，优先队列有更好的实现方法，我们称之为堆(heap)</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种插入和删除操作都只能在端部进行的列表，这一端称为栈顶。</p>
<p>当我们在栈中添加一个元素或者删除一个元素时，该结构都按照一种“后进先出”（Last-In-First-Out LIFO)的方式运转。</p>
<p>栈的应用很广，对于实现递归算法来说时不可缺少的。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树，更精确地说，自由树就是连通无回路图。无回路但不一定连通的图成为森林。</p>
<p>树的边数总是比它的顶点数少1</p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>树的另外一个非常重要的特性就是：树的任意两个顶点之间总是恰好存在一条从一个顶点到另一个顶点的简单路径。这个性质使得以下做法成为可能：</p>
<p>任选自由树种的一个顶点，将它作为所谓的有根树的根。对有根树的描述中，根通常放在最顶上（树的第0层），邻接根的顶点放在根的下面，再下面是跟根距离两条边的顶点，然后以此类推。</p>
<p>有根树扮演很重要的角色，远比自由树重要，它们常常被简称为“树”。也就是说“树”通常是指有根树。</p>
<h4 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h4><p>有序树是一颗有根树，树中每个顶点的所有子女都是有序的。</p>
<h2 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h2><p>分析算法效率一般框架一般有两种：时间效率和空间效率</p>
<ul>
<li>时间雄安率指出算法的运行速度，空间效率涉及算法需要的额外空间。</li>
<li>算法的时间效率主要用它输入规模的函数来度量。该函数计算算法基本操作的执行次数。基本操作是总云心赶时间中工先最大的操作。通常它是算法的最内层循环中最费时的操作。</li>
<li>大多算法的效率可以分为以下几类：常数、对数、线性、线性对数、平方、立方和指数</li>
</ul>
<p>o(1)常数, o(n)线性, o(logn)对数, o(nlogn)线性对数</p>
<ul>
<li>比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。</li>
<li>再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。</li>
<li>再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</li>
<li>O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。</li>
<li>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961615&amp;idx=1&amp;sn=8711d52aa7bbd77db02eded67f6cc299&amp;chksm=bd2d0cd38a5a85c5e767e3be02fe885d0bcc95a9755d1e9b52971aac31b4fbca24227102a578&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我时间复杂度了 -  58沈剑  架构师之路</a></p>
<h1 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h1><p><img src="/uploads/algorithm-structure-learning/sort-table.jpg" alt></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序开始的时候，我们扫描整个列表，找到它最小元素，然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素中的最小元素，再和第二个元素交换位置，把第二小元素放在它的最终位置上。</p>
<p>一般来说，在对该列表进行第i遍扫描的时候，该算法在最后n-i个元素中寻找最小元素，然后拿它和Ai交换。</p>
<p>优点：</p>
<ul>
<li>不需要额外的存储空间</li>
<li>键的交换次数仅为O(n)，或者更精确点时n-1次。这个特性使得选择排序优于许多其他排序</li>
</ul>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 不稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/xuanze.gif" alt></p>
<h3 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(in); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[min] &gt; in[j] &#123;</span><br><span class="line">				min = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		in[i], in[min] = in[min], in[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它比较表中的相邻元素，如果它们是逆序的话，就交换它们的位置。重复多次以后，最终，最大的元素就“沉到”列表最后一个位置。第二遍操作将第二大的元素沉下去。这样一直做，直到n-1遍以后，该列表就排好序了。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/bubbleSort.gif" alt></p>
<h3 id="Golang实现-1"><a href="#Golang实现-1" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[j] &gt; in[j+<span class="number">1</span>] &#123;</span><br><span class="line">				in[j], in[j+<span class="number">1</span>] = in[j+<span class="number">1</span>], in[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>另外有一种扩展算法，是以发明者希尔命名-SHELL排序。此排序提供了一种更好的算法来对较大的文件进行排序。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-2"><a href="#Golang实现-2" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">		cur := in[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; in[j]; j-- &#123;</span><br><span class="line">			in[j+<span class="number">1</span>] = in[j]</span><br><span class="line">		&#125;</span><br><span class="line">		in[j+<span class="number">1</span>] = cur</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。</p>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/shellSort.webp" alt></p>
<h3 id="Golang实现-3"><a href="#Golang实现-3" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">	gap := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> gap &lt; length/<span class="number">3</span> &#123;  <span class="comment">// &lt;O(n^(3/2))</span></span><br><span class="line">		gap = gap*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; length; i++ &#123;</span><br><span class="line">			temp := arr[i]</span><br><span class="line">			j := i - gap</span><br><span class="line">			<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap &#123;</span><br><span class="line">				arr[j+gap] = arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+gap] = temp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并排序（归并排序）"><a href="#合并排序（归并排序）" class="headerlink" title="合并排序（归并排序）"></a>合并排序（归并排序）</h2><p>合并排序是成功应用分治技术的一个完美例子。对于一个需要排序的数组A[0..n-1]，合并排序把它一分为二：A[0..n/2-1]和A[n/2..n-1]，并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 稳定 |</p>
<p>exmpale:</p>
<p>Input:   {4, 1, 5, 8, 9, 3, 2, 6, 7}<br>Divide: {4, 1, 5, 8}, {9, 3, 2, 6, 7}<br>Divide: {4, 1}, {5, 8}, {9, 3}, {2, 6}, {7}<br>Divide: {4}, {1}, {5}, {8}, {9}, {3}, {2}, {6}, {7}</p>
<p>Merge: {1, 4}, {5, 8}, {3, 9}, {2, 6}, {7}<br>Merge: {1, 4, 5, 8}, {2, 3, 6, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 8, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 7 ,8, 9}</p>
<h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-4"><a href="#Golang实现-4" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(in []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> in</span><br><span class="line">	&#125;</span><br><span class="line">	mid := <span class="built_in">len</span>(in) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> merge(mergeSort(in[:mid]), mergeSort(in[mid:]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">			result[i] = left[<span class="number">0</span>]</span><br><span class="line">			left = left[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result[i] = right[<span class="number">0</span>]</span><br><span class="line">			right = right[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(left); j++ &#123;</span><br><span class="line">		result[i] = left[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(right); j++ &#123;</span><br><span class="line">		result[i] = right[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于分治思想的重要排序算法，不像合并排序是按照元素在数组中的位置对它们进行划分，快速排序按照元素的值对它们进行划分。划分是对给定数组中的元素的重新排列。使得A[s]左边的元素都小于等于A[s]，而所有A[s]右边的元素都大于等于A[s]；</p>
<p>显然，建立一个划分以后，A[s]已经位于它在有序数组中的最终位置，接下来我们可以继续对A[s]前和A[s]后的子数组分别进行排序。</p>
<p>注意它与合并排序不同之处在于：</p>
<ul>
<li>在合并排序算法中，将问题划分成两个子问题是很快的，算法的主要工作在于合并子问题的解；</li>
<li>而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并问题的解了。</li>
</ul>
<p>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p>它的最内层循环效率非常，使得在处理随机排列的数组时，速度要比合并排序快（对于堆排序也是如此。堆排序是另一种效率为nlogn的算法）。</p>
<p>人们对这个基本算法，进行了坚持不懈的改良，研究人员在这一领域的重要成果包括：</p>
<ul>
<li>更好的中轴选择方法：例如随即快速排序，它使用随机的元素作为中轴；三平分划分法，它以数组最左边、最右边和最中间的元素的中位数作为中轴。</li>
<li>当子数组足够小时（对于大多数计算机系统而言，元素数为5-15），改用插入排序方法，或者根本就不再对小数组进行排序，而是在快速排序结束后再使用插入排序的方法对整个近似有序的数组进行排序。</li>
<li>一些划分方法的挨近，例如三路划分，将数组分成三段，每段的元素分别小于、等于、大于中轴元素。</li>
</ul>
<p>根据国际上快速排序的权威塞奇威克的说法，如果同时应用这些改进措施，可以将该算法的运行时间削减20%-30%</p>
<p>但是与其他算法一样，快速排序算法也又缺点，它是不稳定的。同时它还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到O(logn)，但是它还是比堆排序O(1)的空间效率差。</p>
<p>最坏情况下，是整个序列都已经有序且完全倒序 ，<br>此时，快速排序退化为冒泡排序，要比较n*（n-1）/2次才能完成</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 不稳定 |</p>
<h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/quickSort.gif" alt><br><img src="/uploads/algorithm-structure-learning/quickSort2.gif" alt></p>
<h3 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> _quickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		partition := partition(arr, left, right)</span><br><span class="line">		_quickSort(arr, left, partition<span class="number">-1</span>)</span><br><span class="line">		_quickSort(arr, partition+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	pivot := left</span><br><span class="line">	index := left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := index; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; arr[pivot] &#123;</span><br><span class="line">			arr[i], arr[index] = arr[index], arr[i]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[pivot], arr[index<span class="number">-1</span>] = arr[index<span class="number">-1</span>], arr[pivot]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 堆排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在一个标准的字典中可能会把“堆”定义成元素的无序堆积，但被称为“堆”的数据结构绝对不符合这个定义。我们更应该把它说成是一种灵巧的，部分有序的数据结构，它尤其使用用来实现优先级队列。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请回忆一下，优先队列是元素的一个集合，其中每个元素都包含一个被成为元素优先级的可排序属性。优先队列支持下面的：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 找出一个具有最高优先级的元素（即最大元素）</span></span><br><span class="line"><span class="string">* 删除一个具有最高优先级的元素</span></span><br><span class="line"><span class="string">* 添加一个元素到集合中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主要是由于这些操作的有效实现，使得堆既龄人感兴趣，又非常具有实用价值。在诸如操作系统的作页调度以及通信网络中流量管理等场景中，非常需要采用优先队列。并且优先队列也常常出现在一些重要的算法，例如Prim算法，Dijkstra算法，曼哈夫编码，还有在分支界限中的应用。堆排序是一种在理论上十分重要的排序算法，它的基础也依赖于堆这一数据结构。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span></span><br><span class="line"><span class="string">小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序的时间雄安率和合并排序的时间效率属于同一类，并且不同的是，堆排序是在位的，也就是说，它并不需要任何额外的存储空间。针对随机文件的计时实验指出，堆排序比快速排序运行得慢，但是和合并排序相比还是有竞争力的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">| 时间复杂度 |  O(nlogn) |</span></span><br><span class="line"><span class="string">| 稳定性 | 不稳定 |</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆可以定义为一颗二叉树，树的节点中包含键（每个节点一个键），并且树满足下面两个条件：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 树的形状要求---这个二叉树是基本完备的（或者简称完全二叉树），这意味着，树的每一层都是满的，除了最后一层最右边的元素可能缺位。</span></span><br><span class="line"><span class="string">1. 父母优势要求，又称为堆特性--每个节点的键都要大于或者等于它的子女的键（对于任何叶子我们认为这个条件都是自动满足的）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请注意，在堆中，键值是从上到下排序的。也就是说，在任何从根到某个叶子的路径上，键值的序列是递减的（如果允许相等键的存在，则是非递增的）。然而，键值之间并不存在从左到右的次序。也就是说，在树的同一层的节点之间，不存在任何关系，更一般地说，在同一节点的左右子树之间也没有任何关系。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面列出堆的重要特性，这些特性都是不难证明的：</span></span><br><span class="line"><span class="string">1. 只存在一颗n个节点的完全二叉树，它的高度等于log2n</span></span><br><span class="line"><span class="string">1. 堆的根总是包含了堆的最大元素</span></span><br><span class="line"><span class="string">1. 堆的一个节点以及该节点的子孙也是一个堆</span></span><br><span class="line"><span class="string">1. 可以用数组来实现堆，方法是用从上到下、从左到右的方式来记录堆的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">虽然大多数处理堆的算法来说，把堆想象成二叉树可以容易地理解它们所隐含的思想，但对于实际实现来说，使用数组会简单得多，效率也高得多。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在数组中，对于一个位于父母位置i(1&lt;=i&lt;=n/2)的键来说，它的子女将会在2i和2i+1，相应地，对于位于i(2&lt;=i&lt;=n)的键来说，它的父母将会在i/2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 动画演示</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort2.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort3.gif)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Golang实现</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	heapify(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">		siftDown(arr, <span class="number">0</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (<span class="built_in">len</span>(arr) - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(heap []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; heap[child] &gt; heap[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> heap[root] &gt; heap[child] &#123;</span><br><span class="line">			heap[root], heap[child] = heap[child], heap[root]</span><br><span class="line">			root = child</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>敲重点</p>
<ul>
<li>这是个线性时间复杂度的算法</li>
<li>不是通过比较的方式</li>
<li>必须有明确的范围</li>
<li>数据规模不能太大，因为需要额外开辟数组空间</li>
</ul>
<p>计数排序的核心是，空间换时间</p>
<p>计数排序，时间复杂度为O(n)；<br>当待排序元素个数很多，但值域范围很窄时，计数排序是很节省空间的；</p>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/countingSort.gif" alt></p>
<h3 id="Golang实现-5"><a href="#Golang实现-5" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="keyword">int</span>, maxValue <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bucketLen := maxValue + <span class="number">1</span></span><br><span class="line">	bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, bucketLen)</span><br><span class="line"></span><br><span class="line">	sortedIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		bucket[arr[i]] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketLen; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> bucket[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			arr[sortedIndex] = i</span><br><span class="line">			sortedIndex += <span class="number">1</span></span><br><span class="line">			bucket[i] -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p>
<p>桶排序的基本思想：</p>
<p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p>
<p>桶排序的适用范围是，待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间。</p>
<p>桶排序，是一种复杂度为O(n)的排序<br>桶排序，是一种稳定的排序<br>桶排序，适用于数据均匀分布在一个区间内的场景</p>
<h3 id="Golang实现-6"><a href="#Golang实现-6" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(array []<span class="keyword">int</span>, bucketSize <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> max, min <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nBuckets := <span class="keyword">int</span>(max-min)/bucketSize + <span class="number">1</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, nBuckets)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nBuckets; i++ &#123;</span><br><span class="line">		buckets[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		idx := <span class="keyword">int</span>(n-min) / bucketSize</span><br><span class="line">		buckets[idx] = <span class="built_in">append</span>(buckets[idx], n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sorted := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bucket) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			insertionSort(bucket)</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, bucket...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p>
<p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p>
<p>基数排序适用于：</p>
<ol>
<li>数据范围较小，建议在小于1000</li>
<li><p>每个数值都要大于等于0</p>
<p>算法描述</p>
</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<ul>
<li>基的选取，可以先从个位开始，也可以先从十位开始，结果是一样的；</li>
<li>基数排序，是一种稳定的排序；</li>
<li><p>时间复杂度，可以认为是线性的O(n)；</p>
<h3 id="LSD动画演示"><a href="#LSD动画演示" class="headerlink" title="LSD动画演示"></a>LSD动画演示</h3><p><img src="/uploads/algorithm-structure-learning/radixSort.gif" alt></p>
<h3 id="Golang实现-7"><a href="#Golang实现-7" class="headerlink" title="Golang实现"></a>Golang实现</h3><blockquote>
<p>这里bucket扩展为两倍支持负数加入排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[<span class="number">0</span>])))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		v := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[i])))</span><br><span class="line">		<span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxDigit := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> max/<span class="number">10</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">		maxDigit++</span><br><span class="line">		max = max / <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> dev, j := <span class="number">1</span>, <span class="number">0</span>; j &lt; maxDigit; j++ &#123;</span><br><span class="line"></span><br><span class="line">		buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">			idx := (arr[i]/dev)%<span class="number">10</span> + <span class="number">10</span></span><br><span class="line">			buckets[idx] = <span class="built_in">append</span>(buckets[idx], arr[i])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">				arr[pos] = v</span><br><span class="line">				pos++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev = dev * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="常见关于排序的问题"><a href="#常见关于排序的问题" class="headerlink" title="常见关于排序的问题"></a>常见关于排序的问题</h2><h3 id="TOP-K"><a href="#TOP-K" class="headerlink" title="TOP K"></a>TOP K</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961587&amp;idx=1&amp;sn=54bf39db7043cc638315caf70f24d94b&amp;chksm=bd2d0d2f8a5a84395246be4522d10fbfc1f744658047d5fb3fad8e9f3c3d76baab3a2ce84867&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我TopK了</a></p>
<h4 id="TOP-K-无序"><a href="#TOP-K-无序" class="headerlink" title="TOP K 无序"></a>TOP K 无序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	buildHeap(arr, k)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; arr[<span class="number">0</span>] &#123;</span><br><span class="line">			arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">			siftDown2(arr, <span class="number">0</span>, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (k - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown2(arr, i, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown2</span><span class="params">(arr []<span class="keyword">int</span>, low, high <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := low</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> child &gt;= high &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; high &amp;&amp; arr[child] &gt; arr[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> arr[root] &gt; arr[child] &#123;</span><br><span class="line">			arr[root], arr[child] = arr[child], arr[root]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TOP-K-有序"><a href="#TOP-K-有序" class="headerlink" title="TOP K 有序"></a>TOP K 有序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKbubble</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>(result, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>-i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h1 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>当你想用二叉树存储大量数据时，只需遵循一条简单的规则：当使用中序遍历时，在每个节点中存储的数据的键将具有递增的顺序。通过遵循这条规则，现在可以把二叉树视作二叉查找树。</p>
<p>二叉搜索树又名有序二叉树，结点元素按固定次序排布，使得我们可以在进行查找等操作时使用二分搜索提高效率。</p>
<p><img src="/uploads/algorithm-structure-learning/bsearcht.png" alt></p>
<p>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</p>
<h2 id="自平衡二叉查找树"><a href="#自平衡二叉查找树" class="headerlink" title="自平衡二叉查找树"></a>自平衡二叉查找树</h2><p>使用二叉查找树我们赢得了查找、插入和删除的时间效率，这些操作都属于O(logn)，但这仅仅在平均情况下成力，在最差情况下，这些操作属于O(n)，因为这种树可能会退化成一种严重不平衡的树，树的高度为n-1。</p>
<p>计算机科学家付出了大量的经历食土寻找一种既能够保留经典二叉查找树的好特性，又能避免它退化到最差情况的数据结构，我们这里所说的好特性主要是指它对于字典操作的对数效率以及它维护了集合元素的顺序。科学家们现在给了两套方案：</p>
<ul>
<li>第一种方法属于实例化简得类型：把一颗不平衡得二叉查找树转变为平衡得形式。因为，我们说这类树是自平衡得。这个思想的特定实现之间的区别在于它们对于平衡的定义是不同的。一颗AVL树要求它的每个节点左右子树的高度差不能超过1。一颗红黑树能够容忍同一节点的一颗子树的高度是另一颗子树的两倍。如果一个节点的插入或者删除产生了一颗违背平衡要求的树，我们就从一系列成为旋转的特定变换种选择一种，重新构造这棵树，使得这颗树满足平衡要求。</li>
<li>第二种方法属于改变表现得类型：它允许一颗查找树的单个节点种不止包含一个元素。这种树的特例是2-3树、2-3-4树以及B树，它们的区别在于查找树的单个节点种能够容纳的元素个数，但它们都达到了很好的平衡。</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>一颗AVL树是一颗二叉查找树，其中每个节点的平衡因子定义为该节点左子树和右子树的高度差，这个平衡因子要么为0，要么为+1或者-1（一颗空树的高度定义为-1。当然，平衡因子也可以定义为左右子树的叶子数的差，而不是高度差）。<br>AVL查找和插入操作的效率都为O(logn)，然后这些令人印象深刻的效率特性是有代价，AVL树的缺点是频繁的旋转、需要维护树的节点的平衡以及总体上的复杂性，尤其是删除操作。这些缺点阻碍了AVL树成为实现字典的标准结构。但同时所蕴含的思想通过旋转来重新平衡一颗二叉树-被证明是富有成效的，也导致人们发现了经典二查找树的其他一些令人感兴趣的变化形式。</p>
<p>最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL</p>
<p>平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。我们可以推出AVL树适合用于插入删除次数比较少，但查找多的情况</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是一种可以包含两种类型节点的树：2节点和3节点。一个2节点值包含一个键K和两个子女（换句话说，一个2节点和一颗经典二叉查找树的节点类型是相同的）。一个3节点包含两个有序的键K1和K2（K1&lt;K2)，并且有3个子女。最左边的子女作为键值小于K1的子树的根，，中间的子女作为键值位于K1和K2之间的子树的根，最右边的子女作为键值大于K2的子树的根。</p>
<p>2-3树的最后一个要求是，树种的所有叶子必须位于同一层，也就是说，一颗2-3树总是高度平衡的：对于每个叶子来说，从树的根到叶子的路径长度都是相同。为了这个特性，我们付出的“代价”是允许查找树的一个节点包含不止一个键。</p>
<p>在2-3树中查找一个给定的键K是非常简单的。我们从根开始，如果根是一个2节点，我们就把它当作一个二叉查找树来操作：如果K等于根的键值，算法停止；如果K小于或者大于根的键值，我们分别在左子树或右子树中继续查找。如果根是一个3节点，在不超过两次比较之后，我们就能知道，是停止查找（K等于根的值），还是应该在根的3颗子树的哪颗中继续查找。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>实现AVL树的一种更容易的方式是：使用被称为红黑树的概念。它利用了两个新概念：</p>
<ol>
<li>在红黑树中，数据只存储在树的叶节点中。也就是说，只有不带子节点的节点才能包含实际的数据。内部节点只用引用。</li>
<li>将每个节点都视作带有红色或黑色。节点的颜色有下面的规则决定：</li>
</ol>
<ul>
<li>所有叶节点都是黑色</li>
<li>在沿着从根出发的任何路径上都不允许出现连续的红色节点</li>
<li><p>树的所有叶节点都必须具有相同的黑色深度，它被定义为叶节点与根之间的黑色节点数量减1</p>
</li>
<li><p>任何一个节点都有颜色，黑色或者红色</p>
</li>
<li>根节点是黑色的</li>
<li>父子节点之间不能出现两个连续的红节点</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等</li>
<li>空节点被认为是黑色的</li>
</ul>
<p>map和set都是用红黑树实现的<br>著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块<br>epoll在内核中的实现，用红黑树管理事件块<br>nginx中，用红黑树管理timer等<br>Java的TreeMap实现</p>
<p>平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><blockquote>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961486&amp;idx=1&amp;sn=b319a87f87797d5d662ab4715666657f&amp;chksm=bd2d0d528a5a84446fb88da7590e6d4e5ad06cfebb5cb57a83cf75056007ba29515c85b9a24c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">数据库索引，到底是什么做的 – 略浅显</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">深入从B树、B+树、B*树谈到R 树</a></li>
</ul>
</blockquote>
<p>B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。</p>
<ul>
<li>不再是二叉搜索，而是m叉搜索；</li>
<li>叶子节点，非叶子节点，都存储数据；</li>
<li>中序遍历，可以获得所有节点；</li>
</ul>
<p>但在此之前，咱们还得简单回顾下一棵m阶的B 树的特性，如下：</p>
<ul>
<li>树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。</li>
<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；</li>
<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<ol>
<li>Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。</li>
<li>Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 </li>
<li>除根结点之外的结点的关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1（叶子结点也必须满足此条关于关键字数的性质，根结点除外）</li>
</ol>
</li>
</ul>
<p>B树为何适合做索引？</p>
<ul>
<li>由于是m分叉的，高度能够大大降低</li>
<li>每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO；</li>
</ul>
<p>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO</p>
<p>我们知道，B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。与本blog之前介绍的红黑树很相似，但在降低磁盘I/0操作方面要更好一些。许多数据库系统都一般使用B树或者B树的各种变形结构，如下文即将要介绍的B+树，B*树来存储信息。 B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p>
<p>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</p>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/m0_37535642/article/details/72356737" target="_blank" rel="noopener">磁盘块是什么？它的大小？</a></li>
<li><a href="http://www.cnblogs.com/valor-xh/p/6669897.html" target="_blank" rel="noopener">电脑中常用的“扇区”、“簇”、“块”、“页”等概念</a></li>
</ul>
</blockquote>
<p>一棵含有N个总关键字数的m阶的B树的最大高度是多少?<br>log_ceil（m/2）(N+1)/2 + 1 </p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树，如上图，仍是m叉搜索树，在B树的基础上，做了一些改进：</p>
<ul>
<li>非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；</li>
<li>叶子之间，增加了链表，获取所有节点，不再需要中序遍历；</li>
</ul>
<p>这些改进让B+树比B树有更优的特性：</p>
<ul>
<li>范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；</li>
<li>叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储</li>
<li>非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引</li>
</ul>
<p>最后，量化说下，为什么m叉的B+树比二叉搜索树的高度大大大大降低？</p>
<p>大概计算一下：</p>
<p>(1)局部性原理，将一个节点的大小设为一页，一页4K，假设一个KEY有8字节，一个节点可以存储500个KEY，即j=500</p>
<p>(2)m叉树，大概m/2&lt;= j &lt;=m，即可以差不多是1000叉树</p>
<p>(3)那么：<br>一层树：1个节点，1<em>500个KEY，大小4K<br>二层树：1000个节点，1000</em>500=50W个KEY，大小1000<em>4K=4M<br>三层树：1000</em>1000个节点，1000<em>1000</em>500=5亿个KEY，大小1000<em>1000</em>4K=4G</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p><a href="https://blog.csdn.net/sunhuaqiang1/article/details/52463257" target="_blank" rel="noopener">Trie树(字典树)</a></p>
<p>Trie并不是平衡树，也不一定非要有序。它主要用于前缀匹配，比如字符串，比如说ip地址，如果字符串长度是固定或者说有限的，那么Trie的深度是可控制的，你可以得到很好的搜索效果，而且插入新数据后不用平衡。不过Trie不像B-tree通用性那么强，你需要针对你自己的实际应用来设计你自己的Trie，比如说你做个字典应用，是用26个字母，还是用unicode来前缀匹配？如果是ip地址搜索，是用二进制来前缀拼配，还是八进制来匹配？</p>
<h1 id="散列法"><a href="#散列法" class="headerlink" title="散列法"></a>散列法</h1><p>散列法的基本思想就是把键分布在一个称为散列表(hash table)的一维数组H[0..m-1]中。我们可以通过对每个键计算某些被称为散列函数(hash function)的与定义函数h的值，来完成这种分布。该函数为每个键指定一个称为散列地址的位于0到m-1之间的整数。</p>
<p>一般来说，散列函数需要满足下列多少有些冲突的要求：</p>
<ul>
<li>散列表的长度相对于键的个数不应过大，但同时也不应过小从而影响算法的时间效率</li>
<li>散列函数需要把键在散列表的单元格中尽可能均匀地分布（因为这个要求，m的值常常被选定为质数。对于大多数应用来说，这个要求还使得散列函数必须考虑键的所有比特位，而不仅仅是其中的某个位）</li>
<li>散列函数必须容易计算</li>
</ul>
<p>显然如果选择的散列表长度m小于键的数量n，会遇到碰撞，这是一种两个（或者更多）键被散列到散列表的同一个单元格的现象。但即使m相对于n足够大，这种碰撞还是会发生的，实际上，在最坏的情况下，所有的键都会散列到散列表同一个单元格中。幸运的是，通过选择适当的散列表长度和散列函数，这种情况很少发生。然后，每一种散列方法都必须要有一种碰撞解决机制。散列有两个主要版本：开散列，也称为分离链；闭散列，也称为开式寻址，在这两个主要版本中，他们的碰撞解决机制是不同的。</p>
<p>在字典的实现中，平衡查找树是散列表的主要竞争对手，因此有必要将两者的主要特征进行比较：</p>
<ul>
<li>渐近时间效率：在使用散列表时，查找、插入、删除操作的效率平均情况下是0(1)，最坏情况（可能性很小）是O(n)。而对于平衡查找树来说，这些操作的时间效率平均和最坏情况都是O(logn)</li>
<li>有序性保留：相对于平衡查找树，散列表并没有假定键是有序的，也通常不保证它们是有序性。这使得散列不太适用于要求按序遍历键值和按范围查询的应用。例如计算位于某个上界和下界之间的键值的个数。</li>
</ul>
<h2 id="开散列（分离链）"><a href="#开散列（分离链）" class="headerlink" title="开散列（分离链）"></a>开散列（分离链）</h2><p>在开散列中，键被存储在附着于散列表单元格上的链表中。每个链表包含着所有散列到该单元格的键。</p>
<p>一般来说，查找的效率取决于链表的长度，而这个长度又取决于字典和散列表的长度以及散列函数的质量。如果该散列函数大致均匀将n个键分布在散列表的m个单元格中，每个链表的长度大约相当于n/m个键。其比率a=n/m被称为散列表的负载因子，它在散列的效率中扮演了一个至关重要的角色。具体来说，假设在成功查找和不成功查找中平均需检查的指针个数分别位S和U，那么它们的值分别应是：</p>
<p>S约等于a+a/2 U=a</p>
<h2 id="闭散列（开式寻址）"><a href="#闭散列（开式寻址）" class="headerlink" title="闭散列（开式寻址）"></a>闭散列（开式寻址）</h2><p>在闭散列中，所有的键都存储在散列表本身中，而没有使用链表（当然，意味着表的长度m至少必须和键的数量n一样大），可以采用不同的策略来解决碰撞，最简单的一种称为线性探查，它检查碰撞发生处后面的单元格。如果该单元格为空，新的键就放置此处；如果下一个单元格被占用了，就检查单元格的直接后继是否可用，以此类推。请注意，如果到达了散列表的尾部，查找就折回表的开始处。也就是说，我们把表作为一个循环数组。</p>
<p>虽然对于这个散列版本来说，查找和插入操作时简单而直接的，但是删除操作则不是这样。一个简单的方法时使用“延迟删除”，也就是说，用一个特殊的符号来标记曾被占用过的位置，以把它们和那些从未被占用过的位置区别开来。</p>
<h1 id="参加面试问题"><a href="#参加面试问题" class="headerlink" title="参加面试问题"></a>参加面试问题</h1><h2 id="两个有序集合合并的方法"><a href="#两个有序集合合并的方法" class="headerlink" title="两个有序集合合并的方法"></a>两个有序集合合并的方法</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959895&amp;idx=1&amp;sn=de25ce2544c088ff9be0b93fd3ea4d15&amp;chksm=bd2d078b8a5a8e9d5ae4339a683d3f980ff2994f3c10c4081c7bab7f0d77f37521de95e974bf&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入浅出搜索架构引擎、方案与细节（上）</a></p>
<h3 id="for-for，土办法，时间复杂度O-nn"><a href="#for-for，土办法，时间复杂度O-nn" class="headerlink" title="for  for，土办法，时间复杂度O(nn)"></a>for <em> for，土办法，时间复杂度O(n</em>n)</h3><p>每个搜索词命中的网页是很多的，O(n*n)的复杂度是明显不能接受的。倒排索引是在创建之初可以进行排序预处理，问题转化成两个有序的list求交集，就方便多了。</p>
<h3 id="有序list求交集，拉链法"><a href="#有序list求交集，拉链法" class="headerlink" title="有序list求交集，拉链法"></a>有序list求交集，拉链法</h3><p>有序集合1{1,3,5,7,8,9}</p>
<p>有序集合2{2,3,4,5,6,7}</p>
<p>两个指针指向首元素，比较元素的大小：</p>
<p>（1）如果相同，放入结果集，随意移动一个指针</p>
<p>（2）否则，移动值较小的一个指针，直到队尾</p>
<p>这种方法的好处是：</p>
<p>（1）集合中的元素最多被比较一次，时间复杂度为O(n)</p>
<p>（2）多个有序集合可以同时进行，这适用于多个分词的item求url_id交集</p>
<p>这个方法就像一条拉链的两边齿轮，一一比对就像拉链，故称为拉链法</p>
<h3 id="分桶并行优化"><a href="#分桶并行优化" class="headerlink" title="分桶并行优化"></a>分桶并行优化</h3><p>数据量大时，url_id分桶水平切分+并行运算是一种常见的优化方法，如果能将list1&lt;url_id&gt;和list2&lt;url_id&gt;分成若干个桶区间，每个区间利用多线程并行求交集，各个线程结果集的并集，作为最终的结果集，能够大大的减少执行时间。</p>
<p>举例：</p>
<p>有序集合1{1,3,5,7,8,9, 10,30,50,70,80,90}</p>
<p>有序集合2{2,3,4,5,6,7, 20,30,40,50,60,70}</p>
<p>求交集，先进行分桶拆分：</p>
<p>桶1的范围为[1, 9]</p>
<p>桶2的范围为[10, 100]</p>
<p>桶3的范围为[101, max_int]</p>
<p>于是：</p>
<p>集合1就拆分成</p>
<p>集合a{1,3,5,7,8,9}</p>
<p>集合b{10,30,50,70,80,90}</p>
<p>集合c{}</p>
<p>集合2就拆分成</p>
<p>集合d{2,3,4,5,6,7}</p>
<p>集合e{20,30,40,50,60,70}</p>
<p>集合e{}</p>
<p>每个桶内的数据量大大降低了，并且每个桶内没有重复元素，可以利用多线程并行计算：</p>
<p>桶1内的集合a和集合d的交集是x{3,5,7}</p>
<p>桶2内的集合b和集合e的交集是y{30, 50, 70}</p>
<p>桶3内的集合c和集合d的交集是z{}</p>
<p>最终，集合1和集合2的交集，是x与y与z的并集，即集合{3,5,7,30,50,70}</p>
<h3 id="bitmap再次优化"><a href="#bitmap再次优化" class="headerlink" title="bitmap再次优化"></a>bitmap再次优化</h3><p>数据进行了水平分桶拆分之后，每个桶内的数据一定处于一个范围之内，如果集合符合这个特点，就可以使用bitmap来表示集合</p>
<p>水平分桶，bitmap优化之后，能极大提高求交集的效率，但时间复杂度仍旧是O(n)</p>
<p>bitmap需要大量连续空间，占用内存较大</p>
<h3 id="跳表skiplist"><a href="#跳表skiplist" class="headerlink" title="跳表skiplist"></a>跳表skiplist</h3><p>有序链表集合求交集，跳表是最常用的数据结构，它可以将有序集合求交集的复杂度由O(n)降至O(log(n))</p>
<p>集合1{1,2,3,4,20,21,22,23,50,60,70}</p>
<p>集合2{50,70}</p>
<p>要求交集，如果用拉链法，会发现1,2,3,4,20,21,22,23都要被无效遍历一次，每个元素都要被比对，时间复杂度为O(n)，能不能每次比对“跳过一些元素”呢？</p>
<p>集合1{1,2,3,4,20,21,22,23,50,60,70}建立跳表时，一级只有{1,20,50}三个元素，二级与普通链表相同</p>
<p>集合2{50,70}由于元素较少，只建立了一级普通链表</p>
<p>如此这般，在实施“拉链”求交集的过程中，set1的指针能够由1跳到20再跳到50，中间能够跳过很多元素，无需进行一一比对，跳表求交集的时间复杂度近似O(log(n))，这是搜索引擎中常见的算法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.bookstack.cn/read/JS-Sorting-Algorithm" target="_blank" rel="noopener">十大经典排序算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/linux-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/linux-learning/" itemprop="url">Linux学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T21:54:54+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Unix的强大原因"><a href="#Unix的强大原因" class="headerlink" title="Unix的强大原因"></a>Unix的强大原因</h1><ul>
<li>Unix很简洁：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，unix仅仅提供几百个系统调用并且有一个非常明确的设计目的</li>
<li>Unix中，所有的东西都被当作文件对待。这种抽象使对数据和设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。</li>
<li>Unix的内核和相关的系统工具软件是用C语言编写而成，正式这个特点使得Unix在硬件体系架构面前都具有龄人惊异移植能力。</li>
<li>Unix的进程创建非常迅速，并且有一个非常独特的fork()系统调用。最后Unix提供了一套非常简单但又很稳定的进程间通信元语，快速简洁的进程创建过程使Unix的程序把目标放在一次执行保质保量地完成一个任务上，而简单稳定的进程间通信机制又可以保证这些单一目的简单程序可以方便地组合在一起，去解决现实中变得越来越复杂的任务。正式由于这种策略和机制分离的设计理念，确保了Unix系统具备清晰的层次化结构。</li>
</ul>
<p>Unix已经发展为了一个支持抢占式多任务、多线程、虚拟内存、换页、动态链接和TCP/IP网络的现代化操作系统。</p>
<p>总结：</p>
<ol>
<li>Unix简洁，提供仅仅几百个系统调用并且每个非常明确的设计目的</li>
<li>Unix抽象能力好，所有东西都被当作文件对待，对数据对设备都是同一套系统调用接口：open()、read()、write()、lseek()和close()</li>
<li>UnixC语言编写，移植能力好</li>
<li>Unix进程创建迅速，还有一套简单好用的进程间通信元语</li>
</ol>
<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Linux是类Unix系统，但它不是Unix。需要说明的是，尽管Linux借鉴了Unix的许多设计并且实现了Unix的API，但Linux没有像其它Unix变种那样直接使用Unix的源代码。必要的时候，它的实现可能和其他的Unix的实现大相径庭，但它没有抛弃Unix的设计目标并且保证了应用程序编程接口的一致。</p>
<p>Linux用途广发，包括的东西也名目繁多。Linux系统的基础是内核、C库、工具集和系统的基本工具，如登陆程序和Shell。Linux系统也支持现代的X Windows系统，这样就可以使用完整的图形用户界面环境，如GNOME。可以在Linux上使用的商业和自由软件数以千计。</p>
<p>总结：</p>
<ol>
<li>Linux不是Unix，只是类Unix</li>
<li>Linux借鉴Unix的设计并实现了Unix的API</li>
</ol>
<h1 id="操作系统和内核简介"><a href="#操作系统和内核简介" class="headerlink" title="操作系统和内核简介"></a>操作系统和内核简介</h1><p>操作系统是指在整个系统中负责完成最基本功能和系统管理的那些部分。这些部分包括内核、设备驱动程序、启动引导程序、命令行SHELL或者其他种类的用户界面、基本的文件管理工具和系统工具。</p>
<p>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分如那件提供的服务，像管理硬件设备、分配系统资源等，内核有时候被称作是管理者或者是操作系统核心。</p>
<p>通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序组成。</p>
<p>对于提供保护机制的现代系统来说，内核独立于普通应用程序，它处于一个<strong>系统态</strong>，拥有受保护的内存空间和访问硬件设备的所有权限，这种系统态和被保护起来的内存空间，统称为<strong>内核空间</strong>。</p>
<p>相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有其他的一些使用限制。</p>
<p>当内核运行的时候，系统以内核态进入内核空间执行，而执行一个普通用户程序时，系统将以用户态进入以用户空间执行。</p>
<p>在系统中运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数再由库函数通过系统调用界面，让内核代其完成各种不同任务。不过也有一些库函数和系统调用就是一一对应的关系，比如，open()库函数除了调用open()系统调用之外，几乎什么都不做。</p>
<p>当一个应用程序执行一条系统调用，我们说内核正在代其执行。如果进一步解释，在这种情况下，应用程序被称为通过系统调用在内核空间执行，而内核被称为运行于进程上下文中。这种交互关系—应用程序通过系统调用界面陷入内核—是应用程序完成其工作的基本行为方式。</p>
<p>内核还要负责管理系统的硬件设备。现有的几乎所有的体系结构，包括全部Linux支持的体系结构，都提供了中断机制。当硬件设备想和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。中断通常对应着一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序相应和处理中断。</p>
<p>为了保证同步，内核可以停用中止—既可以停止所有的中断也可以有选择地停止某个中断号对应的中断。许多操作系统的中断服务程序，包括Linux的，都不在进程上下文中执行，它们在一个与所有进程都无关的、专门的中断上下文中运行。之所以存在这样的一个专门执行环境是为了<strong>保证中断服务程序能够第一时间响应和处理中断请求</strong>，然后快速地退出。</p>
<p>实际上我们可以将每个处理器在任何指定时间点上的活动必须概括为下列三者之一</p>
<ul>
<li>运行于用户空间，执行用户进程</li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行</li>
<li>运行于内核空间，处于中断上下文，<strong>与任何进程无关，处理某个特定的中断</strong></li>
</ul>
<p>即使是边边角角的情况也不例外，比如：当CPU空闲时，内核就会运行一个空进程，处于进程上下文，但运行于内核空间</p>
<p><img src="/uploads/linux/user-kernel-space.png" alt></p>
<p>总结:</p>
<ol>
<li>操作系统是指在整个系统负责完成基本功能和系统管理的部分，包括内核在里面。</li>
<li>内核是操作系统的核心，必须依靠内核提供服务，比如管理硬件设备、分配系统资源等</li>
<li>内核有时候被称作是管理者或者是操作系统核心。</li>
<li>内核通常中断服务程序、CPU处理调度程序、内存管理程序、网络、进程间通信等系统服务组成</li>
<li>内核独立于应用程序，拥有受保护的内存空间和访问硬件设备的权限，处于系统态，这种系统态和被保护的内存空间被统称为内核空间</li>
<li>应用程序在用户空间执行，只能看到允许使用部分系统资源不能直接访问硬件，不能访问内核划给别人的内存范围</li>
<li>内核运行时，系统以内核态进入内核空间执行，普通用户程序执行，系统将以用户态进入用户空间执行</li>
<li>处理器活动三种情况：运行于用户空间，执行用户进程、运行于内核空间，处于进程上下文、运行于内核空间，处于中断上下文</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文（总结）</a></li>
</ul>
<h1 id="Linux内核与传统Unix内核比较"><a href="#Linux内核与传统Unix内核比较" class="headerlink" title="Linux内核与传统Unix内核比较"></a>Linux内核与传统Unix内核比较</h1><ul>
<li>Linux支持动态加载内核模块。尽管Linux内核也是单内核，可是允许在需要的时候动态地卸载和加载部分内核代码</li>
<li>Linux支持对称多处理SMP机制。尽管许多Unix的变体也支持SMP，但传统的Unix并不支持这种机制</li>
<li>Linux内核可以抢占(preemptive)。与传统的Unix变体不同，Linux内核具有允许在内核运行的任务优先执行的能力。在其他各种Unix，只有Solaris和IRIX支持抢占。</li>
<li>Linux对线程支持的实现比较有意思：内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样，只不过是其中的一些共享资源而已。</li>
<li>Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统</li>
<li>Linux忽略了一些被设为时设计得很拙劣的Unix特性，像STREAMS，它还忽略了那些难以实现的过时标准</li>
<li>Linux体现了自由这个词的精髓。现有的Linux特性集就是Linux公开开发模型自由发展的结果</li>
</ul>
<h1 id="Linux-内核版本"><a href="#Linux-内核版本" class="headerlink" title="Linux 内核版本"></a>Linux 内核版本</h1><p>2.6.26.1</p>
<table>
<thead>
<tr>
<th>2</th>
<th>6</th>
<th>26</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>主版本号</td>
<td>从版本号</td>
<td>修订版本号</td>
<td>稳定版本号</td>
</tr>
</tbody>
</table>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>其中涉及进程的定义以及相关的概念，比如线程；然后再讨论Linux中如何管理每个进程。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程就是处于执行期的程序。但进程并不仅仅局限于一段可执行程序代码。通常进程还要其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或者多个执行线程，当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。</p>
<p>执行线程，简称线程，<strong>是在进程中活动的对象</strong>，每个线程都拥有一个独立的<strong>程序计数器、进程栈和一组进程寄存器</strong>。<strong>内核调度的对象是线程而不是进程</strong>。在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包括多个线程的多线程程序司空见惯。</p>
<p>Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程只不过是一种特殊的进程罢了。</p>
<p>进程提供两种虚拟化机制：虚拟处理器和虚拟内存。虽然实际上可能是许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器，而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。有趣的是，在线程之间可以共享虚拟内存但每个都拥有自己的虚拟处理器。</p>
<p>程序本身不是进程，进程是处于执行期的程序以及相关的资源的总称。</p>
<h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>Linux是通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。</p>
<p>内核把进程的列表存放在叫做任务队列的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构。</p>
<p><img src="/uploads/linux/task_list.png" alt></p>
<p>在2.6以前的内核中给，各个进程的task_struct存放在它们内核栈的尾端。这样做视为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。</p>
<p>由于现在用slab分配器动态生成task_struct，所以只需在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个新的结构struct thread_info</p>
<p>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任务实际task_struct的指针。</p>
<p>总结：</p>
<ol>
<li>Linux通过slab分配器分配task_struct，以此达到对象复用和缓存着色</li>
<li>内核把进程的列表存放在任务队列的双向循环链表中。</li>
<li>任务队列中每一项的类型都是 task_struct，称为进程描述符的结构</li>
</ol>
<h2 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h2><p>内核通过一个唯一的进程标志值(process identification value)或PID来标识每个进程。PID是一个数，表示为pid_t隐含类型，实际上就是一个int类型。</p>
<p>为了与老版本的Unix和Linux兼容，PID最大默认为32768，这个值可以通过/proc/sys/kernel/pid_max修改提高上限，一般是够用。</p>
<p>这个最大值很重要，因为它实际表示系统中允许同时存在的进程的最大数目。</p>
<p>内核中大部分处理进程的代码都是直接通过task_struct进行的，因此，通过current宏查找到当前运行进程的进程描述符的速度就显得尤为重要。</p>
<p><img src="/uploads/linux/thread_info.png" alt></p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程描述符中的state域描述了进程的当前状态。系统中的每个进程都必然为下列物种状态标志之一：</p>
<ul>
<li>R ：TASK_RUNNING（运行状态）<br>进程是可执行的；它或者正在执行，或者在运行队列中等待执行。在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程<blockquote>
<p>一个进程最多只能出现在一个CPU的可执行队列中，进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行</p>
</blockquote>
</li>
<li>S ：TASK_INTERRUPTIBLE（可中断、可中断睡眠、睡眠状态）<br>进程正在睡眠（也就是说它被阻塞），等待某些条件（由外部中断触发、或由其他进程触发）的达成，一旦达成，内核就会把进程状态设置为运行。处于此状态的进程会因为接收到信号而提前被换星并随时准备投入运行<blockquote>
<p>比如等待socket连接、等待信号量</p>
</blockquote>
</li>
<li>D ：TASK_UNINTERRUPTIBLE（不可中断）<br>除了就算是接收到信号也不会被换醒或准备投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断状态使用得较少<blockquote>
<ol>
<li>不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</li>
<li>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</li>
</ol>
</blockquote>
</li>
<li>t ：__TASK_TRACED<br>被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪</li>
<li>T ：__TASK_STOPPED（停止）<br>进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号的时候，此外在调试期间接收到任何信号，都会进程进入这种状态。</li>
<li>Z(zombie)：僵死状态</li>
<li>X死亡状态(dead) ：只是⼀个返回状态，你不会在任务列表里看到这个状态</li>
</ul>
<p><img src="/uploads/linux/process_state.png" alt></p>
<h3 id="僵尸进程-Z-zombie"><a href="#僵尸进程-Z-zombie" class="headerlink" title="僵尸进程 Z(zombie)"></a>僵尸进程 Z(zombie)</h3><p>僵尸进程是处于僵死状态的进程（只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程便进入Z状态）</p>
<p>产生原因：<strong>子进程先于父进程退出</strong>，父进程（使用<strong>wait()系统调用</strong>）没有读取到子进程退出的返回代码，这时候子进程为了保存退出原因，因此进入僵死态不会释放所有资源。僵死进程会以终止状态保持在进程表中，并且会⼀直在等待父进程读取其退出状态代码。</p>
<p>危害：维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，假如⼀个父进程创建了很多子进程，但是不回收，就会造成内存资源的浪费，资源泄露。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>相对于僵尸进程，那么必须提到的就是孤儿进程，同僵尸进程相反，假如父进程先于子进程退出，子进程便进入后台运行，成为孤儿进程，孤儿进程随后会被1号init进程领养并回收，也就是将其父进程变为init进程。</p>
<p>在Linux中有两种特殊的进程： </p>
<p>进程0：Linux引导中创建的第一个进程，完成加载系统后，演变为进程调度、交换及存储管理进程。</p>
<p>进程1：init 进程，由0进程创建，完成系统的初始化。是系统中所有其它用户进程的祖先进程。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/sun_life_/article/details/88580785" target="_blank" rel="noopener">Linux 进程基本概念 什么是进程</a><br><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程[总结]</a></p>
<h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><p>可执行程序代码使进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。</p>
<p>一般程序在用户空间执行。当一个程序调执行了系统调用或者触发了某个异常，它就会陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。</p>
<p>除非在此间隙有更高优先级的进程需要执行并由调度器做出了响应调整，否则在内核还没有退出的时候，程序在用户空间会继续执行。</p>
<p>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行-对内核的所有访问都必须通过这些接口。</p>
<p>关于上下文更进程的解释：</p>
<ol>
<li>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</li>
<li>相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。<ul>
<li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
<li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
</li>
</ol>
<p>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。</p>
<p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文（总结）</a></li>
</ul>
<h2 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h2><p><strong>Unix系统的进程之间存在一个明显的继承关系，Linux系统中也是如此。所有进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本(initscript)并执行其他的相关程序，最终完成系统启动的整个过程</strong>。</p>
<p>系统中的<strong>每个进程必有一个父进程</strong>，相应的，每个进程也可以拥有0个或者多个子进程。拥有<strong>同一个父进程的所有进程称为兄弟</strong>。进程间的关系存放在进程描述符中。每个task_struct都包含一个指向其父进程task_struct、叫做parent的指针，还包含一个称为children的子进程链表。</p>
<p>总结：</p>
<ol>
<li>所有进程是PID为1的进程的后代</li>
<li>每个进程都必须由一个父进程</li>
<li>同一个父进程的所有进程称为兄弟</li>
<li>进程描述符中有指向父进程的指针，还有一个指向子进程的链表</li>
</ol>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>Unix的进程创建很特别，许多其他的操作系统都提供产生(spawn)进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。</p>
<p>Unix采用不同的方式，首先fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID和某些资源和统计量（例如，挂起的信号，它没有必要继承）。exec()函数负责读取可执行文件并将其载入地址空间开始运行。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>写时复制技术最初产生于Unix系统，用于实现一种傻瓜式的进程创建：当发出fork()系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为是非常耗时的，因为它需要：</p>
<ul>
<li>为子进程的页表分配页面</li>
<li>为子进程的页分配页面</li>
<li>初始化子进程的页表</li>
<li>把父进程的页复制到子进程相应的页中</li>
</ul>
<p>创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破坏了高速缓存中的内容。</p>
<p>在大多数情况下，这样做常常是毫无意义的（fork()后立即调用exec()），因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。</p>
<p>现在的Unix内核（包括Linux），采用一种更为有效的方法称之为写时复制（或COW）。这种思想相当简单：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</p>
<p>总结：</p>
<ol>
<li>内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程，这种过于粗暴而且效率低下</li>
<li>写时拷贝(copy-on-write)核心思想就先与父进程共享拷贝页，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">Linux写时拷贝技术</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/4495479.html" target="_blank" rel="noopener">Linux进程管理——fork()和写时复制</a></li>
</ul>
<h3 id="fork-运行机制"><a href="#fork-运行机制" class="headerlink" title="fork() 运行机制"></a>fork() 运行机制</h3><p>Linux通过clone()系统调用实现fork()。这个调用通过一系列参数标志来指明父、子进程需要共享的资源。</p>
<p>fork()、vfork()、__clone()库函数都是根据各自需要的参数标志去调用clone(),然后由clone()去调用do_fork()</p>
<p>fork()、vfork()、__clone()-&gt;clone()-&gt;do_fork()</p>
<p>do_fork()该函数调用copy_process()函数，然后让进程开始运行。copy_process运行机制如下：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同</li>
<li>检查并确保创建这个子进程后，用户拥有的进程数目没有超过上限</li>
<li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员被置换为0或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。</li>
<li>子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行</li>
<li>copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0.表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置</li>
<li>调用alloc_pid()为新进程分配一个有效的PID</li>
<li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等，在一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针</li>
</ol>
<p>再回到do_fork()函数，如果copy_process函数成功返回，新创建的子进程被唤醒并让其投入运行。</p>
<p>内核有意选择子进程首先执行，因为一般子进程都回马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，由可能回开始向地址空间写入。</p>
<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。</p>
<p>相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）</p>
<p>Microsoft Windows或是Sun Solaris等操作系统的线程实现与Linux差异非常大。</p>
<p>假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包括指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这样的共享资源。线程本身再去描述它独占的资源。</p>
<p>相反在Linux仅仅创建四个进程并分配四个普通的task_struct结构。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<p>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)</p>
<p>上面的代码缠身供得结果和调用fork()差不多，只是父子两共享地址空间、文件系统资源、文件描述符和信号处理程序。换个说法就是，新建的进程和它的父进程就是流行的所谓线程。</p>
<p>对比一下，一个普通的fork()的实现是：</p>
<p>clone(SIGCHILD,0)</p>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
<p>clone() 参数标志</p>
<table>
<thead>
<tr>
<th>参数标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLONE_FILES</td>
<td>父子进程共享打开的文件</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>父子进程共享文件系统的信息</td>
</tr>
<tr>
<td>CLONE_IDLETASK</td>
<td>将PID设置为0（只供idle进程使用)</td>
</tr>
<tr>
<td>CLONE_NEWS</td>
<td>为子进程创建新的命名空间</td>
</tr>
<tr>
<td>CLONE_PARENT</td>
<td>指定子进程与父进程拥有同一个父进程</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>继续调试子进程</td>
</tr>
<tr>
<td>CLONE_SETTID</td>
<td>将TID回写至用户空间</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>父子进程共享信号处理函数及被阻断的信号</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>父子进程共享System V SEM_UNDO 语义</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>父子进程放入相同的线程组</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>调用vfork()，所以父进程准备睡眠等待子进程将其唤醒</td>
</tr>
<tr>
<td>CLONE_UNTRACED</td>
<td>防止跟踪进程在子进程上强制执行CLONE_PTRACE</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>以TASK_STOPPED 状态开始进程</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_CHILD_CLEARTID</td>
<td>清楚子进程的TID</td>
</tr>
<tr>
<td>CLONE_CHILD_SETTID</td>
<td>设置子进程的TID</td>
</tr>
<tr>
<td>CLONE_PARENT_SETTID</td>
<td>设置父进程的TID</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>父子进程共享地址空间</td>
</tr>
</tbody>
</table>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成—独立运行在内核空间的标准进程。</p>
<p>内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p>
<p>Linux确实会把一些任务交给内核线程去做，像flush和ksofirqd这些任务就是明显的例子。运行 ps -ef 命令，可以看到很多内核线程。这些线程在系统启动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/alantu2018/p/8526916.html" target="_blank" rel="noopener">普通线程和内核线程</a></p>
<h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>进程终结时，内核必须释放它所占的所有资源</p>
<p>进程调用exit()会终结当前进程，可以显式调用，也可以隐式： c语言main函数结束时编译器会自动加入exit调用</p>
<p>exit是系统调用，对应内核里的sys_exit() -&gt; do_exit()</p>
<p>do_exit()，需要做下面这些琐屑的工作：</p>
<ol>
<li>设置标志位标记为退出：将task_struct中的标志成员设置为PF_EXITING</li>
<li>删除所有定时器：调用del_timer_sync()删除任一内核定时器，确保没有定时器再排队，也没有定时器处理程序的运行</li>
<li>有进程记账功能则输出记账信息：如果BSD的进程记账功能是开启的，do_exit()调用acct_update_intergrals()来输出记账信息</li>
<li>释放内存：调用exit_mm()函数释放级才能占用的mm_struct，如果没有别的进程使用它们（也就是没有被共享），就彻底释放它们</li>
<li>调用sem__exit()函数，如果进程排队等候IPC信号，它则离开队列</li>
<li>调用exit_files()和exit_fs，分别递减文件描述符、文件系统数据的引用计数。降至为零，表示没有进程在使用相应的资源，此时可以释放</li>
<li>接着存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作</li>
<li>调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态设为EXIT_ZOMBILE（存放在task_struct结构的exit_state中）</li>
<li>do_exit()调用schedule()切换到新的进程，因为处于EXIT_ZOMBILE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。</li>
</ol>
<p>至此进程的所有资源都被释放掉。并处于EXIT_ZOMBILE退出状态。它占用的所有内存就是内核栈、thread_info、task_struct结构。此时进程存在唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还给系统使用。</p>
<p>标志位设为退出-&gt;删除所有定时器-&gt;有进程记账则输出记账-&gt;释放内存-&gt;退出IPC等候队列-&gt;释放文件相关资源-&gt;设置exit_code-&gt;向父进程发送信号并进程状态设置为EXIT_ZOMBLIE-&gt;切换到新进程</p>
<p><strong>父进程在得知子进程终结时，有责任对该子进程使用wait系统调用</strong>。这个wait函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间（内核栈， thread_info, task_struct）</p>
<p>如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程,孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p>这里联系上面的进程状态一起看。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>在调用了do_exit()函数后，尽管线程已经僵死不能再运行，但系统保留它的进程描述符。</p>
<p><strong>进程终结时所需的清理工作和进程描述符的删除被分开执行</strong>。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才会被释放。</p>
<p>wait()这一族函数都是通过唯一的一个系统调用wait4()来实现的。它的标准动作就是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。</p>
<p>当最终需要释放进程描述符时，release_task()会被调用，运行机制以下：</p>
<ol>
<li>它调用__exit_signal()，改函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务队列中删除该进程</li>
<li>_exit_signal()释放目前僵死进程所使用的生于资源，并进行最终统计和记录</li>
<li>如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程</li>
<li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存</li>
</ol>
<p>至此，进程描述符和所有进程独享的资源就全部释放了</p>
<h3 id="孤儿进程造成的进退维谷"><a href="#孤儿进程造成的进退维谷" class="headerlink" title="孤儿进程造成的进退维谷"></a>孤儿进程造成的进退维谷</h3><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些称为孤儿的进程就会在退出时处于永远的僵死状态，白白的耗费内存。</p>
<p>解决方法就是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做他们的父进程。</p>
<p>在do_exit()中会调用exit_notify()，该函数会调用forget_original_parent()，而后者会调用find_new_reaper()来执行寻父。</p>
<p>一旦系统为进程成功地找到新的父亲进程，就不会再有出现主流僵死进程的危险了，init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>多任务系统可以划分为两大类：非抢占式多任务和抢占式多任务。</p>
<p><strong>Linux提供抢占式多任务模式</strong>，在此模式下，由调度程序来决定什么时候停止一个进程运行，以便其他进程能够得到执行机会。这个强制的挂其动作叫做：抢占。</p>
<p>进程运行的时间是预先设置好的，叫进程的时间片。时间片实际上就是分配给每个可运行进程的处理器时间段。</p>
<p>有效管理时间片能使调度程序从系统全局的角度做出调度决定，避免个别进程独占系统资源。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I/O消耗型和处理器消耗型的进程"></a>I/O消耗型和处理器消耗型的进程</h3><p>进程可以分为IO消耗型和处理器消耗型</p>
<p>调度策略通常要在这两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>调度算法中最基本的一类就是基于优先级的调度。</p>
<p>这是一种根据进程的价值和其对处理器时间的需求来对进程分级的想法。优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度。</p>
<p>Linux采用两种不同的优先级范围：</p>
<ul>
<li>第一种范围是nice值，它的范围是从-20到+19，默认值为0；越小优先级越高</li>
</ul>
<p>ps -el 命令查看系统中进程列表，NI一列就是进程对应的nice值。</p>
<ul>
<li>第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99（包括0和99），相反，越大优先级越高</li>
</ul>
<p>任何实时进程的优先级都高于普通的进程，通过命令 ps -eo state,uid,pid,ppid,rtprio,time,comm，其中列显示为”-“，则说明它不是实时进程。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值；</p>
<p>时间片越长会导致系统对交互的响应欠佳，时间片越短会明显增大进程切换带来的处理器消耗。</p>
<p>IO消耗型不需要长的时间片，而处理器消耗性的进程则希望越长越好（比如这样可以让它们的高速缓存命中率更高）</p>
<p>Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给进程。这一比例受nice值得影响，nice值高则进程赋予权重，nice值低则进程赋予高权重。</p>
<p>Linux系统是抢占式的，Linux使用的CFS调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前小，则新进程立刻投入运行，抢占当前进程，否则推迟其运行。</p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><p>Linux 调度器是以模块方式提供的，这样目的是允许不同类型的进程可以有针对性地选择调度算法。</p>
<p>这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有优先级，基础的调度器它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行哪个程序。</p>
<p>完全公平调度（CFS）是一个针对普通进程的调度类，在Linux中称为SCHED_NORMAL</p>
<p>在CFS算法引入之前，Linux使用过几种不同的调度算法，其中下面这两种比较出名：</p>
<ul>
<li>O(n)调度：在每次进程切换时，内核依次扫描就绪队列上的每一个进程，计算每个进程的优先级，再选择出优先级最高的进程来运行；尽管这个算法理解简单，但是它花费在选择优先级最高进程上的时间却不容忽视。系统中可运行的进程越多，花费的时间就越大，时间复杂度为O(n)</li>
<li>O(1)调度：其基本思想是根据进程的优先级进行调度。进程有两个优先级,一个是静态优先级,一个是动态优先级.静态优先级是用来计算进程运行的时间片长度的,动态优先级是在调度器进行调度时用到的,调度器每次都选取动态优先级最高的进程运行.由于其数据结构设计上采用了一个优先级数组，这样在选择最优进程时时间复杂度为O(1)，所以被称为O(1)调度</li>
</ul>
<p>这两种调度算法，其基本思路都是通过一系列运行指标确定进程的优先级，然后根据进程的优先级确定调度哪个进程，而CFS则转换了一种思路，它不计算优先级，而是通过计算进程消耗的CPU时间（标准化以后的虚拟CPU时间）来确定谁来调度。从而到达所谓的公平性</p>
<p>绝对公平性：</p>
<p>cfs定义了一种新的模型，其基本思路很简单，他把CPU当做一种资源，并记录下每一个进程对该资源使用的情况，在调度时，调度器总是选择消耗资源最少的进程来运行。这就是所谓的“完全公平”。但这种绝对的公平有时也是一种不公平，因为有些进程的工作比其他进程更重要，我们希望能按照权重来分配CPU资源。</p>
<p>相对公平性：</p>
<p>为了区别不同优先级的进程，就是会根据各个进程的权重分配运行时间(nice值)。进程的运行时间计算公式为：分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和；调度周期很好理解，就是将所处于TASK_RUNNING态进程都调度一遍的时间</p>
<p>举个例子来说明一下，比如系统中只两个进程A, B，权重分别为1和2，假设调度周期设为30ms，那么分配给A的CPU时间为:30ms <em> (1/(1+2)) = 10ms；而B的CPU时间为：30ms </em> (2/(1+2)) = 20ms。那么在这30ms中A将运行10ms，B将运行20ms</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><p>在实现层面，Linux通过引入virtual runtime(vruntime)来完成上面的设想，具体的,我们来看下从实际运行时间到vruntime的换算公式</p>
<p>vruntime = 实际运行时间*（NICE_0_LOAD/weight）</p>
<p>实际上vruntime就是根据权重将实际运行时间标准化，标准化之后，各个进程对资源的消耗情况就可以直接通过比较vruntime来知道，比如某个进程的vruntime比较小，我们就可以知道这个进程消耗CPU资源比较少，反之消耗CPU资源就比较多</p>
<p>有了vruntime的概念后，调度算法就非常简单了，谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。<br>或者可以这么理解：CFS的思想就是让每个调度实体（进程）的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间</p>
<p>Linux采用了一颗红黑树（对于多核调度，实际上每一个核有一个自己的红黑树），记录下每一个进程的vruntime，需要调度时，从红黑树中选取一个vruntime最小的进程出来运行</p>
<h3 id="新创建进程的vruntime是多少？"><a href="#新创建进程的vruntime是多少？" class="headerlink" title="新创建进程的vruntime是多少？"></a>新创建进程的vruntime是多少？</h3><p>假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内</p>
<p>创建子进程的具体流程如下：</p>
<ol>
<li>子进程在创建时，vruntime初值首先被设置为min_vruntime；</li>
<li>然后，如果sched_features中设置了START_DEBIT位，vruntime会在min_vruntime的基础上再增大一些。</li>
<li>设置完子进程的vruntime之后，检查sched_child_runs_first参数，如果为1的话，就比较父进程和子进程的vruntime，若是父进程的vruntime更小，就对换父、子进程的vruntime，这样就保证了子进程会在父进程之前运行。</li>
</ol>
<h3 id="休眠进程的vruntime一直保持不变吗？"><a href="#休眠进程的vruntime一直保持不变吗？" class="headerlink" title="休眠进程的vruntime一直保持不变吗？"></a>休眠进程的vruntime一直保持不变吗？</h3><p>如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多</p>
<h3 id="休眠进程在唤醒时会立刻抢占CPU吗？"><a href="#休眠进程在唤醒时会立刻抢占CPU吗？" class="headerlink" title="休眠进程在唤醒时会立刻抢占CPU吗？"></a>休眠进程在唤醒时会立刻抢占CPU吗？</h3><p>这是由CFS的唤醒抢占 特性决定的，即sched_features的WAKEUP_PREEMPT位。</p>
<p>由于休眠进程在唤醒时会获得vruntime的补偿，所以它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。除了交互式进程以外，主动休眠的进程同样也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这类进程往往并不要求快速响应，但是CFS不会把它们与交互式进程区分开来，它们同样也会在每次唤醒时获得vruntime补偿，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。</p>
<h3 id="进程占用的CPU时间片可以无穷小吗？"><a href="#进程占用的CPU时间片可以无穷小吗？" class="headerlink" title="进程占用的CPU时间片可以无穷小吗？"></a>进程占用的CPU时间片可以无穷小吗？</h3><p>参考：<br><a href="https://www.cnblogs.com/tianguiyu/articles/6091378.html" target="_blank" rel="noopener">linux内核分析——CFS（完全公平调度算法）</a><br><a href="https://www.jianshu.com/p/673c9e4817a8" target="_blank" rel="noopener">Linux的公平调度（CFS）原理</a></p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><p>系统 </p>
<ul>
<li>uname -a  查看内核/操作系统/CPU信息 </li>
<li>head -n 1 /etc/issue  查看操作系统版本 </li>
<li>cat /proc/cpuinfo  查看CPU信息 </li>
<li>hostname  查看计算机名 </li>
<li>lspci -tv  列出所有PCI设备 </li>
<li>lsusb -tv  列出所有USB设备 </li>
<li>lsmod  列出加载的内核模块 </li>
<li>env  查看环境变量<br>资源 </li>
<li>free -m  查看内存使用量和交换区使用量 </li>
<li>df -h  查看各分区使用情况 </li>
<li>du -sh  查看指定目录的大小 </li>
<li>grep MemTotal /proc/meminfo  查看内存总量 </li>
<li>grep MemFree /proc/meminfo  查看空闲内存量 </li>
<li>uptime  查看系统运行时间、用户数、负载 </li>
<li>cat /proc/loadavg  查看系统负载<br>磁盘和分区 </li>
<li>mount | column -t  查看挂接的分区状态 </li>
<li>fdisk -l  查看所有分区 </li>
<li>swapon -s  查看所有交换分区 </li>
<li>hdparm -i /dev/hda  查看磁盘参数(仅适用于IDE设备) </li>
<li>dmesg | grep IDE  查看启动时IDE设备检测状况<br>网络 </li>
<li>ifconfig  查看所有网络接口的属性 </li>
<li>iptables -L  查看防火墙设置 </li>
<li>route -n  查看路由表 </li>
<li>netstat -lntp  查看所有监听端口 </li>
<li>netstat -antp  查看所有已经建立的连接 </li>
<li>netstat -s  查看网络统计信息<br>进程 </li>
<li>ps -ef  查看所有进程 </li>
<li>top  实时显示进程状态<br>用户 </li>
<li>w  查看活动用户 </li>
<li>id  查看指定用户信息 </li>
<li>last  查看用户登录日志 </li>
<li>cut -d: -f1 /etc/passwd  查看系统所有用户 </li>
<li>cut -d: -f1 /etc/group  查看系统所有组 </li>
<li>crontab -l  查看当前用户的计划任务<br>服务 </li>
<li>chkconfig -list  列出所有系统服务 </li>
<li>chkconfig -list | grep on  列出所有启动的系统服务<br>程序 </li>
<li>rpm -qa  查看所有安装的软件包</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/redis-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/redis-learning/" itemprop="url">Redis学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T17:20:54+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/es-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/es-learning/" itemprop="url">ElasticSearch 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:46+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><ul>
<li>包含这个关键词的 document list</li>
<li>包含这个关键词的所有 document 的数量：IDF（inverse document frequency）</li>
<li>这个关键词在每个 document 中出现的次数：TF（term frequency）</li>
<li>这个关键词在这个 document 中的POSITION</li>
<li>每个 document 的长度：length norm</li>
<li>包含这个关键词的所有 document 的平均长度</li>
</ul>
<h1 id="相关分数"><a href="#相关分数" class="headerlink" title="相关分数"></a>相关分数</h1><p><a href="https://blog.csdn.net/wangmaohong0717/article/details/60141394" target="_blank" rel="noopener">ElasticSearch 的分数 (_score) 是怎么计算得出 (2.X &amp; 5.X)</a><br><a href="https://blog.csdn.net/weixin_36564655/article/details/82736269" target="_blank" rel="noopener">elasticsearch的TF/IDF打分公式总结</a><br><a href="https://www.elastic.co/cn/elasticon/conf/2016/sf/improved-text-scoring-with-bm25" target="_blank" rel="noopener">improved-text-scoring-with-bm25</a><br><a href="https://www.cnblogs.com/sheeva/p/6847309.html" target="_blank" rel="noopener">Elasticsearch中的相似度模型(原文：Similarity in Elasticsearch)</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/guide/master/scoring-theory.html#idf" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF/IDF"></a>TF/IDF</h2><p>relevance score（相关度得分）算法：简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度</p>
<p>Elasticsearch 使用的是 term frequency/inverse document frequency 算法，简称为 TF/IDF 算法</p>
<pre><code>TF/IDF 有以下三个组成
* Term frequency

某单个关键词(term) 在某文档的某字段中出现的频率次数, 显然, 出现频率越高意味着该文档与搜索的相关度也越高

具体计算公式是 tf(q in d) = sqrt(termFreq)

另外, 索引的时候可以做一些设置, &quot;index_options&quot;: &quot;docs&quot; 的情况下, 只考虑 term 是否出现(命中), 不考虑出现的次数.

* Inverse document frequency

某个关键词(term) 在索引(单个分片)之中出现的频次. 出现频次越高, 这个词的相关度越低. 相对的, 当某个关键词(term)在一大票的文档下面都有出现, 那么这个词在计算得分时候所占的比重就要比那些只在少部分文档出现的词所占的得分比重要低. 说的那么长一句话, 用人话来描述就是 &quot;物以稀为贵&quot;, 比如, &apos;的&apos;, &apos;得&apos;, &apos;the&apos; 这些一般在一些文档中出现的频次都是非常高的, 因此, 这些词占的得分比重远比特殊一些的词(如&apos;Solr&apos;, &apos;Docker&apos;, &apos;哈苏&apos;)占比要低,

具体计算公式是 idf = 1 + ln(numDocs/(docFreq + 1))

* Field-length norm

字段长度, 这个字段长度越短, 那么字段里的每个词的相关度也就越大. 某个关键词(term) 在一个短的句子出现, 其得分比重比在一个长句子中出现要来的高.

具体计算公式是 norm = 1/sqrt(numFieldTerms)
</code></pre><p>最后的得分是三者的乘积 tf <em> idf </em> norm</p>
<p>以上描述的是最原始的针对单个关键字(term)的搜索. 如果是有多个搜索关键词(terms)的时候, 还要用到的 Vector Space Model</p>
<p>Lucene中使用空间向量模型，其基于余弦定理，对于搜索中的每一个词term看做向量中的一维，每一维度的值由Lucene中的tf-idf打分公式给出，最后使用余弦定理获得搜索结果的最终得分。</p>
<p>如果查询复杂些, 或者用到一些修改了分数的查询, 或者索引时候修改了字段的权重, 比如 function_score 之类的,计算方式也就又更复杂一些.</p>
<h3 id="Elasticsearch-5-Lucene-6-的-BM25-算法"><a href="#Elasticsearch-5-Lucene-6-的-BM25-算法" class="headerlink" title="Elasticsearch 5 (Lucene 6) 的 BM25 算法"></a>Elasticsearch 5 (Lucene 6) 的 BM25 算法</h3><p>BM25 的 BM 是缩写自 Best Match, 25 貌似是经过 25 次迭代调整之后得出的算法. 它也是基于 TF/IDF 进化来的. Wikipedia 那个公式看起来很吓唬人, 尤其是那个求和符号, 不过分解开来也是比较好理解的.</p>
<p>总体而言, 主要还是分三部分, TF - IDF - Document Length</p>
<p>IDF 还是和之前的一样. 公式 IDF(q) = 1 + ln(maxDocs/(docFreq + 1))</p>
<p>f(q, D) 是 tf(term frequency)</p>
<p>|d| 是文档的长度, avgdl 是平均文档长度.</p>
<p>先不看 IDF 和 Document Length 的部分, 变成 tf * (k + 1) / (tf + k),</p>
<p>相比传统的 TF/IDF (tf(q in d) = sqrt(termFreq)) 而言, BM25 抑制了 tf 对整体评分的影响程度, 虽然同样都是增函数, 但是, BM25 中, tf 越大, 带来的影响无限趋近于 (k + 1), 这里 k 值通常取 [1.2, 2], 而传统的 TF/IDF 则会没有临界点的无限增长.</p>
<p>而文档长度的影响, 同样的, 可以看到, 命中搜索词的情况下, 文档越短, 相关性越高, 具体影响程度又可以由公式中的 b 来调整, 当设值为 0 的时候, 就跟之前 ‘TF/IDF’ 那篇提到的 “norms”: { “enabled”: false } 一样, 忽略文档长度的影响.</p>
<p>综合起来,k1，b为分数的调节因子</p>
<p>k = 1.2</p>
<p>b = 0.75</p>
<p>idf <em> (tf </em> (k + 1)) / (tf + k <em> (1 - b + b </em> (dl/avgdl)))</p>
<p>最后再对所有的 terms 求和. 就是 Elasticsearch 5 中一般查询的得分了.</p>
<p>饱和度</p>
<p>tf-idf和bm25都默认对于高频率的词项来说，该词项的频率继续升高对相关性的影响实际很小。区别在于BM25在这一点上做的更好一些。在BM25中高频词接近饱和之后会渐进一个边界值，而在tf-idf中则没有边界值。</p>
<p>平均文档长度</p>
<p>tf-idf和BM25之间第二点主要区别是BM25中对文档长度的使用。BM25使用文档长度来补偿长文档通常含有更多词从而在并不相关的情况下获取较高tf分数的情况。然后长文档并不一定是不好的，有些长文档覆盖了更广的范围因此是合理的。BM25通过因子B来做长度补偿,B通过一个调节参数b (0&lt;=b&lt;=1)、文档长度dl和平均文档长度avdl来计算</p>
<h1 id="索引文档的过程（写）"><a href="#索引文档的过程（写）" class="headerlink" title="索引文档的过程（写）"></a>索引文档的过程（写）</h1><p><a href="https://zhuanlan.zhihu.com/p/34669354" target="_blank" rel="noopener">知乎阿里ES专栏-Elasticsearch内核解析 - 写入篇</a><br><a href="https://www.ctolib.com/docs/sfile/ELKstack-guide-cn/elasticsearch/principle/index.html" target="_blank" rel="noopener">ElasticSearch架构原理</a></p>
<p><strong>关键点</strong></p>
<ul>
<li>可靠性：或者是持久性，数据写入系统成功后，数据不会被回滚或丢失。</li>
<li>一致性：数据写入成功后，再次查询时必须能保证读取到最新版本的数据，不能读取到旧数据。</li>
<li>原子性：一个写入或者更新操作，要么完全成功，要么完全失败，不允许出现中间状态。</li>
<li>隔离性：多个写入操作相互不影响。</li>
<li>实时性：写入后是否可以立即被查询到。</li>
<li>性能：写入性能，吞吐量到底怎么样</li>
</ul>
<h2 id="Lucene的写"><a href="#Lucene的写" class="headerlink" title="Lucene的写"></a>Lucene的写</h2><p>Elasticsearch内部使用了Lucene完成索引创建和搜索功能，Lucene中写操作主要是通过IndexWriter类实现，IndexWriter提供三个接口：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long addDocument();</span><br><span class="line">public long updateDocuments();</span><br><span class="line">public long deleteDocuments();</span><br></pre></td></tr></table></figure></p>
<p>通过这三个接口可以完成单个文档的写入，更新和删除功能，包括了分词，倒排创建，正排创建等等所有搜索相关的流程。</p>
<p>只要Doc通过IndesWriter写入后，后面就可以通过IndexSearcher搜索了，看起来功能已经完善了，但是仍然有一些问题没有解：</p>
<ul>
<li>上述操作是单机的，而不是我们需要的分布式。</li>
<li>文档写入Lucene后并不是立即可查询的，需要生成完整的Segment后才可被搜索，如何保证实时性？</li>
<li>Lucene生成的Segment是在内存中，如果机器宕机或掉电后，内存中的Segment会丢失，如何保证数据可靠性 ？</li>
<li>Lucene不支持部分文档更新，但是这又是一个强需求，如何支持部分更新？</li>
</ul>
<p>上述问题，在Lucene中是没有解决的，那么就需要Elasticsearch中解决上述问题。</p>
<p>Elasticsearch在解决上述问题时，除了我们在上一篇《Elasticsearch数据模型简介》中介绍的几种系统字段外，在引擎架构上也引入了多重机制来解决问题。我们再来看Elasticsearch中的写机制。</p>
<h2 id="Elasticsearch的写"><a href="#Elasticsearch的写" class="headerlink" title="Elasticsearch的写"></a>Elasticsearch的写</h2><ol>
<li>每个Index由多个Shard组成，每个Shard有一个主节点和多个副本节点，副本个数可配。但每次写入的时候，写入请求会先根据_routing规则选择发给哪个Shard，Index Request中可以设置使用哪个Filed的值作为路由参数，如果没有设置，则使用Mapping中的配置，如果mapping中也没有配置，则使用_id作为路由参数，然后通过_routing的Hash值选择出Shard（在OperationRouting类中），最后从集群的Meta中找出出该Shard的Primary节点</li>
<li>请求接着会发送给Primary Shard，在Primary Shard上执行成功后，再从Primary Shard上将请求同时发送给多个Replica Shard，请求在多个Replica Shard上执行成功并返回给Primary Shard后，写入请求执行成功，返回结果给客户端</li>
</ol>
<p>这种模式下，写入操作的延时就等于latency = Latency(Primary Write) + Max(Replicas Write)。只要有副本在，写入延时最小也是两次单Shard的写入时延总和，写入效率会较低，但是这样的好处也很明显，避免写入后，单机或磁盘故障导致数据丢失，在数据重要性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。</p>
<p>在每一个Shard中，写入流程分为两部分，先写入Lucene，再写入TransLog。</p>
<ol>
<li>写入请求到达Shard后，先写Lucene文件，创建好索引，此时索引还在内存里面，接着去写TransLog，写完TransLog后，刷新TransLog数据到磁盘上，写磁盘成功后，请求返回给用户。</li>
<li>写Lucene内存后，并不是可被搜索的，需要通过Refresh把内存的对象转成完整的Segment后，然后再次reopen后才能被搜索，一般这个时间设置为1秒钟，导致写入Elasticsearch的文档，最快要1秒钟才可被从搜索到，所以Elasticsearch在搜索方面是NRT（Near Real Time）近实时的系统</li>
<li>每隔一段比较长的时间，比如30分钟后，Lucene会把内存中生成的新Segment刷新到磁盘上，刷新后索引文件已经持久化了，历史的TransLog就没用了，会清空掉旧的TransLog</li>
</ol>
<h2 id="Segment-Merge"><a href="#Segment-Merge" class="headerlink" title="Segment Merge"></a>Segment Merge</h2><p>其中用一句话概括了 Lucene 的设计思路就是”开新文件”。从另一个方面看，开新文件也会给服务器带来负载压力。因为默认每 1 秒，都会有一个新文件产生，每个文件都需要有文件句柄，内存，CPU 使用等各种资源。一天有 86400 秒，设想一下，每次请求要扫描一遍 86400 个文件，这个响应性能绝对好不了！</p>
<p>为了解决这个问题，ES 会不断在后台运行任务，主动将这些零散的 segment 做数据归并，尽量让索引内只保有少量的，每个都比较大的，segment 文件。这个过程是有独立的线程来进行的，并不影响新 segment 的产生。</p>
<p>当归并完成，较大的这个 segment 刷到磁盘后，commit 文件做出相应变更，删除之前几个小 segment，改成新的大 segment。等检索请求都从小 segment 转到大 segment 上以后，删除没用的小 segment。这时候，索引里 segment 数量就下降了。</p>
<h1 id="搜索过程描述"><a href="#搜索过程描述" class="headerlink" title="搜索过程描述"></a>搜索过程描述</h1><p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch</p>
<p>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列</p>
<p>在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的</p>
<p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表</p>
<p>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/richaaaard/p/5226334.html" target="_blank" rel="noopener">在ElasticSearch之下（图解搜索的故事）</a><br><a href="https://blog.csdn.net/hellozhxy/article/details/81459985" target="_blank" rel="noopener">Elasticsearch聚合深入详解——对比Mysql实现</a><br><a href="https://blog.csdn.net/qq_34646817/article/details/82594726" target="_blank" rel="noopener">Elasticsearch 聚合分析详解</a></p>
<h1 id="分布式原理"><a href="#分布式原理" class="headerlink" title="分布式原理"></a>分布式原理</h1><h2 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h2><p>通常，我们只需要在每个节点配置好了集群名称，节点名称，互相通信的节点会根据es自定义的服务发现协议去按照多播的方式来寻找网络上配置在同样集群内的节点。<br>这就是多播模式，但事实上，在阿里云等云服务器上采用多播模式自行搭建 Elasticsearch 将导致各节点无法发现从而集群无法建成，这也是云服务供应商从安全角度考虑的策略，在这样的云服务器上，我们只能采用单播模式搭建集群。<br>所谓的单播，就是在配置中读取到 master 节点信息，直接连入，其效率和安全性都高于多播模式，但是单播存在的问题是如果新增节点是 master 候选节点，则必须更改集群中所有节点的配置。<br>下面的配置开启单播模式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">discovery.zen.ping.multicast.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["master1",</span> <span class="string">"master2"</span><span class="string">,</span> <span class="string">"master3"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是脑裂？"><a href="#什么是脑裂？" class="headerlink" title="什么是脑裂？"></a>什么是脑裂？</h2><p>所谓的脑裂问题，就是在多机热备的高可用 HA 系统中，当两个节点心跳突然断开，就分裂为了两个独立的个体，由于互相失去联系，都认为对方出现了故障，因此都会去争抢对方的资源，争抢启动，由此就会发生严重的后果。<br>举个形象的例子，A 和 B 作为一个双机热备集群的两个节点，各自持有集群的一部分数据 – a 和 b，这时，两机器之间突然无法通信，A 认为 B 已经挂掉，B 认为 A 已经宕机，于是会出现：</p>
<ul>
<li>如果 A 拥有 b 数据的备份，则 A 将以完整数据运行，B 也同样以完整数据运行，这将很可能导致两个节点同时读写共享数据造成数据损坏</li>
<li>如果 A、B 各自仅拥有 a、b 数据，那么两个节点要么均无法启动，要么以瓜分完整共享数据的方式启动</li>
</ul>
<h3 id="产生脑裂的原因"><a href="#产生脑裂的原因" class="headerlink" title="产生脑裂的原因"></a>产生脑裂的原因</h3><ol>
<li>网络问题 – 节点间网络异常造成集群发生物理分离，造成脑裂问</li>
<li>节点负载 – 如果 master 节点负载过高，则可能造成 master 节点停止响应，从而脱离集群，集群重新选主，恢复响应后出现脑裂问题</li>
</ol>
<p>参考：</p>
<p><a href="https://my.oschina.net/weiweiblog/blog/2231223" target="_blank" rel="noopener">Elasticsearch分布式一致性原理剖析(一)-节点篇</a><br><a href="https://www.cnblogs.com/rainwang/p/5725276.html" target="_blank" rel="noopener">如何防止ElasticSearch集群出现脑裂现象</a><br><a href="http://www.pianshen.com/article/9272155752/" target="_blank" rel="noopener">如何防止 Elasticsearch 脑裂问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/mysql-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/mysql-learning/" itemprop="url">Mysql学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:29+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zhuanlan.zhihu.com/p/60348440" target="_blank" rel="noopener">史上最全的大厂Mysql面试题在这里</a><br><a href="https://zhuanlan.zhihu.com/p/60492217" target="_blank" rel="noopener">MySql 三大知识点，索引、锁、事务，原理分析</a></p>
<h1 id="MYSQL-5-6-InnoDB"><a href="#MYSQL-5-6-InnoDB" class="headerlink" title="MYSQL 5.6 InnoDB"></a>MYSQL 5.6 InnoDB</h1><p><img src="/uploads/mysql/mysql-5.6-innodb.jpg" alt="innodb 架构图"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>MySQL 5.7版本：InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、Merge、Federated、Example</p>
<p>常用：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表锁</th>
<th>页锁</th>
<th>行锁</th>
<th>特性</th>
<th>应用场景</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>InnoDB</td>
<td>*</td>
<td></td>
<td>*</td>
<td>支持事务、支持行级锁、支持外键约束、不支持全文索引、支持MVCC</td>
<td>需要频繁更新、删除、需要事务</td>
<td>5.5之后版本中默认的存储引擎</td>
</tr>
<tr>
<td>MyISAM</td>
<td>*</td>
<td></td>
<td></td>
<td>不支持事务、不支持行锁、不支持外键约束、读写并发性能会低、占用资源比较少</td>
<td>以读为主的业务</td>
<td>是ISAM 的扩展格式，5.5.5版本之前的默认存储引擎，MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI</td>
</tr>
<tr>
<td>Memory</td>
<td>*</td>
<td></td>
<td></td>
<td>不支持事务、默认使用哈希（HASH）索引，虽然排序范围过滤的应该使用B+树索引</td>
<td>需要很快的读写速度，它对表的大小有要求，不能建立太大的表，用于查询的临时表</td>
<td>数据均保存在内存中，之前还有个名字叫做 「Heap」</td>
<td></td>
</tr>
<tr>
<td>Archive</td>
<td>*</td>
<td></td>
<td></td>
<td>不支持事务、不支持索引、只支持select 和 insert、提供了压缩功能、高效的插入速度</td>
<td>适合存储大量独立的、作为历史记录的数据</td>
<td></td>
</tr>
</tbody>
</table>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/laowenBlog/p/8405614.html" target="_blank" rel="noopener">MyISAM 存储引擎的特点及优化方法</a></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>关于 Mysql 的锁，各种概念就会喷涌而出，事实上，锁有好几种维度，我们来解释一下</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<p>Mysiam锁模式<br>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。</p>
<ul>
<li>对MyISAM表的读操作(加读锁),不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求.只有当读锁释放后才会执行其它进程的写操作。</li>
<li>对MyISAM表的写操作(加写锁),会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li>
</ul>
<p>innodb锁模式<br>意向锁是InnoDB自动加的，不需要用户干预。<br>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。</p>
<ul>
<li>共享锁： SELECT … LOCK IN SHARE MODE;</li>
<li>排他锁： SELECT … FOR UPDATE;</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>共享锁（读锁 / S 锁）</li>
<li>排它锁（写锁 / X 锁）</li>
</ul>
<p>悲观锁（使用锁，即 for update）：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁</p>
<p>乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</p>
<h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><ul>
<li>Record Lock（单行记录）</li>
<li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li>
<li>Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）</li>
</ul>
<h2 id="默认的读操作，上锁吗"><a href="#默认的读操作，上锁吗" class="headerlink" title="默认的读操作，上锁吗"></a>默认的读操作，上锁吗</h2><p>默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁一般是事务相互等待对方资源，最后形成环路造成的</p>
<h3 id="尽可能避免死锁"><a href="#尽可能避免死锁" class="headerlink" title="尽可能避免死锁"></a>尽可能避免死锁</h3><ol>
<li>以固定的顺序访问表和行</li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大</li>
</ol>
<h3 id="定位死锁原因"><a href="#定位死锁原因" class="headerlink" title="定位死锁原因"></a>定位死锁原因</h3><ol>
<li>通过应用业务日志定位到问题代码，找到相应的事务对应的sql</li>
<li>确定数据库隔离级别</li>
<li>找DBA执行下show InnoDB STATUS看看最近死锁的日志</li>
</ol>
<p>参考：</p>
<p><a href="https://blog.csdn.net/ty_hf/article/details/55338097" target="_blank" rel="noopener">Mysql-各种锁区分</a><br><a href="https://www.cnblogs.com/LBSer/p/5183300.html" target="_blank" rel="noopener">死锁原因</a></p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li><p>MyISAM存储引擎只支持表锁</p>
</li>
<li><p>表记锁有哪些模式？<br>表共享锁(table read lock)、表独占写锁(table write lock)</p>
</li>
<li><p>锁的调度：读写请求同时进行<br>写的优先级大于读的优先级，大量写容易导致读阻塞<br>解决方法：通过更改low priority updates写的优先级；主从（读写）分离来实现负载均衡</p>
</li>
<li><p>查询表级锁争用情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> ‘<span class="keyword">table</span>%’</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Table_locks_waited值高说明表级锁争用情况严重</p>
<ul>
<li>如何控制查询和插入操作的并发进行<br>MyISAM存储引擎有一个系统变量concurrent_insert<br>concurrent_insert=0 不允许并发插入<br>concurrent_insert=1 表中间没有被删除的行，则允许读的同时，表尾插入记录（这是默认设置）<br>concurrent_insert=2 表中间无论有没有被删除的行，都允许表尾插入记录</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通索引</td>
<td>最基本的索引，没有任何约束</td>
</tr>
<tr>
<td>唯一索引</td>
<td>与普通索引类似，但具有唯一约束</td>
</tr>
<tr>
<td>主键索引</td>
<td>特殊的唯一索引 不允许有空值</td>
</tr>
<tr>
<td>复合索引</td>
<td>将多个列组合在一起创建索引 可以覆盖多个列</td>
</tr>
<tr>
<td>外键索引</td>
<td>只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作</td>
</tr>
<tr>
<td>全文索引</td>
<td>MYSQL自带的全文索引只能用于InnoDB、MyISAM，并且只能对英文进行检索</td>
</tr>
</tbody>
</table>
<blockquote>
<p>主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空</p>
</blockquote>
<blockquote>
<p>InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问</p>
</blockquote>
<blockquote>
<p>MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似</p>
</blockquote>
<p><img src="/uploads/mysql/btree.jpg" alt="B树"><br><img src="/uploads/mysql/b+tree.jpg" alt="B+树"></p>
<p>B树： 他会将数据也保存在非页子节点 ，叶子节点之间不存在关系<br>B+树： B+ Tree 将所有的 data 数据都保存到了叶子节点中，非也子节点只保存索引和指针。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务由单独单元的一个或多个SQL语句组成，整个单元的SQL要么成功，要么失败回滚</p>
<h2 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h2><ul>
<li>原子性：事务是一个原子操作单元，整个单元的SQL要么成功，要么失败回滚</li>
<li>一致性：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态（是我们应用层利用事务回滚保证了我们的约束不被破坏）<br><a href="https://www.zhihu.com/question/31346392" target="_blank" rel="noopener">如何理解数据库事务中的一致性的概念</a></li>
<li>隔离性：操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li>
<li>持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</li>
</ul>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/65281198" target="_blank" rel="noopener">程序员，知道Mysql中ACID的原理吗</a></p>
<h3 id="怎么保证一致性？"><a href="#怎么保证一致性？" class="headerlink" title="怎么保证一致性？"></a>怎么保证一致性？</h3><p>分两个层面：</p>
<p>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性，（数据库必须实现了AID才能保证C，也就是C是目的，AID是手段）。</p>
<p>如果事务里出了BUG，违反约束的代码，比如转账转出者没有扣余额，那么一致性就无法保证了。</p>
<p>从应用层面，通过业务逻辑代码判断，判断是否操作符合约束，决定回滚还是提交。</p>
<h3 id="怎么保证原子性？"><a href="#怎么保证原子性？" class="headerlink" title="怎么保证原子性？"></a>怎么保证原子性？</h3><p>利用innoDB的 <strong>undo log</strong>（回滚日志)，是实现原子性的关键，当事务需要回滚的时候能够撤销所有已经成功执行的SQL。</p>
<pre><code>1. 当delete一条数据的时候，需要记录这条数据，回滚的时候，insert这条数据
1. 当update一条数据时候，需要记录之前的旧值，回滚的时候，根据旧值回滚
1. 当insert一条数据，需要记录这条记录的主键，回滚的时候，执行delete操作
</code></pre><p>当调用rollback的时候，便利用undo log回滚到修改之前的样子</p>
<h3 id="怎么保证持久性？"><a href="#怎么保证持久性？" class="headerlink" title="怎么保证持久性？"></a>怎么保证持久性？</h3><p>利用InnoDB的<strong>redo log</strong>，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p>
<p>解决方法就是：事务提交前直接把数据写入磁盘</p>
<p>当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。</p>
<ul>
<li>redo log体积小，只记录哪一页修改了什么，刷盘快</li>
<li>redo log是一直往末尾追加，属于顺序IO</li>
</ul>
<p>当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。</p>
<h3 id="怎么保证隔离性？"><a href="#怎么保证隔离性？" class="headerlink" title="怎么保证隔离性？"></a>怎么保证隔离性？</h3><p>利用锁机制,其中 MVCC（Multi Version Concurrency Control）机制</p>
<p>MVCC : 一句话讲，就是用 同一份数据临时保留多版本的方式 的方式，实现并发控制。</p>
<blockquote>
<p>不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能</p>
</blockquote>
<p>参考：</p>
<p><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">InnoDB存储引擎MVCC实现原理</a><br><a href="https://juejin.im/post/5cdbfec051882515cc7e4afd" target="_blank" rel="noopener">谈谈你对Mysql的MVCC的理解</a><br><a href="https://www.cnblogs.com/FXqufei/p/9795435.html" target="_blank" rel="noopener">关于mysql行级锁中MVCC的一些理解</a></p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><img src="/uploads/mysql/geli-level.jpg" alt></p>
<ul>
<li>没有提交的事务被其他事务读取到了，这叫做 脏读 </li>
<li>其它事务提交后的修改，影响了本次事务的读取，这叫不可重复读<blockquote>
<p>脏读与不可重复读的区别是，脏读是发生在事务没有提交的时候，不可重复读是发生在提交后的</p>
</blockquote>
</li>
<li>同样的条件,第一次和第二次读取的结果集不一样,这叫幻读<blockquote>
<ul>
<li>不可重复读与幻读的区别,不可重读是两次读取同一条记录,幻读是两次读取同一范围记录</li>
<li>幻读是因为其它事务进行insert或者delete,不可重复读是因为其它事务进行了update</li>
</ul>
</blockquote>
</li>
</ul>
<p>参考:</p>
<p><a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html" target="_blank" rel="noopener">强烈推荐阅读,读懂即懂</a></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h2><p><a href="https://zhuanlan.zhihu.com/p/32586602" target="_blank" rel="noopener">MySQL数据库规范及解读</a></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>使用InnoDB存储引擎<br>支持事务、行级锁、并发性能更好、CPU与内存缓存页优化使得资源使用率更高</p>
</li>
<li><p>必须使用utf8(utf8mb4)字符集<br>无需转码 无乱码风险 节省空间</p>
</li>
<li><p>数据表、数据字段必须加入中文注释</p>
</li>
<li><p>禁止使用存储过程、视图、触发器、Event</p>
<p>  高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧！</p>
<p>  总结：<strong>不要让数据库的CPU处理太多逻辑，上浮到服务层，服务水平轻易做到扩展</strong></p>
</li>
<li><p>禁止存储大文件或者大照片</p>
</li>
</ul>
<h3 id="表和字段设计规范"><a href="#表和字段设计规范" class="headerlink" title="表和字段设计规范"></a>表和字段设计规范</h3><ul>
<li><p>禁止使用外键，如果有外键完整性约束，需要应用程序控制</p>
<ol>
<li><p>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁</p>
<p>总结：<strong>外键会增加表与表之间的耦合，update与delete这些操作会设计到相关联的表，十分影响SQL的性能，甚至可能造成死锁</strong></p>
</li>
</ol>
</li>
<li><p>必须把字段定义为NOT NULL并且提供默认值</p>
<ol>
<li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li>
<li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性;同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li>
<li>null值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识</li>
<li><p>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</p>
<p>总结：<strong>会索引、索引统计、值比较都更加复杂，需要更多的存储空间，null的列需要额外的空间来标识</strong></p>
</li>
</ol>
</li>
<li><p>禁止使用TEXT、BLOB类型</p>
<ol>
<li>会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</li>
</ol>
</li>
<li><p>禁止使用ENUM，可使用TINYINT代替</p>
<ol>
<li>增加新的ENUM值要做DDL操作</li>
<li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串</li>
</ol>
</li>
<li><p>表必须有主键，例如自增主键</p>
<ol>
<li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用</li>
<li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li>
<li><p>无主键的表删除，在row模式的主从架构，会导致备库夯住</p>
<p>总结：<strong>有助于提高插入性能，无主键row模式的主从会导致备库</strong></p>
</li>
</ol>
</li>
<li><p>必须使用varchar(20)存储手机号</p>
<ol>
<li>涉及到区号或者国家代号，可能出现+-()</li>
<li>手机号会去做数学运算么?</li>
<li>varchar可以支持模糊查询，例如：like“138%”</li>
</ol>
</li>
<li><p>禁止使用小数存储货币</p>
<ol>
<li>使用整数吧，小数容易导致钱对不上，使用“分”作为单位，这样数据库里就是整数了</li>
</ol>
</li>
</ul>
<h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><ul>
<li><p>单表索引建议控制在5个以内</p>
<ol>
<li>一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</li>
</ol>
</li>
<li><p>单索引字段数不允许超过5个</p>
<ol>
<li>段超过5个时，实际已经起不到有效过滤数据的作用了</li>
</ol>
</li>
<li><p>禁止在更新十分频繁、区分度不高的属性上建立索引</p>
<ol>
<li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li>
<li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</li>
</ol>
</li>
<li><p>建立组合索引，必须把区分度高的字段放在前面</p>
<ol>
<li>能够更加有效的过滤数据</li>
</ol>
</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul>
<li><p>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p>
<p>  <a href="https://www.cnblogs.com/huangsheng/p/6857503.html" target="_blank" rel="noopener">关于SQL中SELECT *（星号）</a></p>
<ol>
<li>读取不需要的列会增加CPU、IO、NET消耗</li>
<li>不能有效的利用覆盖索引</li>
<li>使用SELECT *容易在增加或者删除字段后出现程序BUG</li>
<li>SELECT * 查询两张表的时候，列名一样的话，有可能数据绑定的问题</li>
</ol>
</li>
<li><p>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p>
<ol>
<li>容易在增加或者删除字段后出现程序BUG</li>
</ol>
</li>
<li><p>禁止使用属性隐式转换</p>
<ol>
<li>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？</li>
<li>因为int优先级高于varchar，查询会把phone转换为int，因此需要把表中所有数据改成int，所以必须全表扫描</li>
</ol>
</li>
<li><p>禁止在WHERE条件的属性上使用函数或者表达式</p>
<ol>
<li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描</li>
<li>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li>
</ol>
</li>
<li><p>禁止大表使用JOIN查询，禁止大表使用子查询</p>
<ol>
<li>会产生临时表，消耗较多内存与CPU，极大影响数据库性能，大表指的是数据量在1000万以上的表</li>
</ol>
</li>
<li><p>禁止使用OR条件，必须改为IN查询</p>
<ol>
<li>旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢</li>
</ol>
</li>
<li><p>禁止%开头的模糊查询，负向查询要求必须有携带其它过滤条件（数据范围必须可控）</p>
<ol>
<li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li>
<li>%开头的模糊查询，会导致全表扫描</li>
</ol>
</li>
<li><p>应用程序必须捕获SQL异常，并有相应处理</p>
<ol>
<li>方便维护，及时“查漏补缺”</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/golang-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/golang-learning/" itemprop="url">Go学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:16+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/chapter05/golang.01.md" target="_blank" rel="noopener">Golang面试问题汇总</a></p>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p>Golang 简称 Go，Go 的协程(goroutine) 和我们常见的线程(Thread)一样，拥有其调度器。</p>
<h2 id="调度器的三个基本对象"><a href="#调度器的三个基本对象" class="headerlink" title="调度器的三个基本对象"></a>调度器的三个基本对象</h2><ul>
<li>G (Goroutine)，代表协程，也就是每次代码中使用 go 关键词时候会创建的一个对象</li>
<li>M (Work Thread)，工作线程</li>
<li>P (Processor)，代表一个处理器，又称上下文</li>
</ul>
<h2 id="G-M-P三者的关系与特点"><a href="#G-M-P三者的关系与特点" class="headerlink" title="G-M-P三者的关系与特点"></a>G-M-P三者的关系与特点</h2><ul>
<li>每一个运行的 M 都必须绑定一个 P，线程M 创建后会去检查并执行G (goroutine)对象</li>
<li>每一个 P 保存着一个协程G 的队列</li>
<li>除了每个 P 自身保存的 G 的队列外，调度器还拥有一个全局的 G 队列</li>
<li>M 从队列中提取 G，并执行</li>
<li>P 的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改</li>
<li>M 的个数和 P 的个数不一定一样多（会有休眠的M 或 P不绑定M ）（最大10000）</li>
<li>P 是用一个全局数组（255）来保存的，并且维护着一个全局的 P 空闲链表</li>
</ul>
<p><img src="/uploads/golang/gmp.png" alt></p>
<h2 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h2><ul>
<li>全局G任务队列会和各个本地G任务队列按照一定的策略互相交换。没错，就是协程任务交换。</li>
<li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li>
<li>转移<ul>
<li>局部与全局，全局G个数 / P个数</li>
<li>局部与局部，一次性转移一半</li>
</ul>
</li>
</ul>
<h2 id="Gorutine从入队到执行"><a href="#Gorutine从入队到执行" class="headerlink" title="Gorutine从入队到执行"></a>Gorutine从入队到执行</h2><ol>
<li>当我们创建一个G对象，就是 gorutine，它会加入到本地队列或者全局队列</li>
<li>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件。细节点如下：<ol>
<li>先找到一个空闲的P，如果没有则直接返回</li>
<li>P 个数不会占用超过自己设定的cpu个数</li>
<li>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个空队列</li>
<li>注意这里有一个点：<ul>
<li>无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建</li>
<li>不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满</li>
<li>新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来</li>
</ul>
</li>
</ol>
</li>
<li>M 会启动一个底层线程，循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：<ol>
<li>当前 M 所绑的 P 队列中找</li>
<li>去别的 P 的队列中找</li>
<li>去全局 G 队列中找</li>
</ol>
</li>
<li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li>
<li>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</li>
<li>入口 main 函数，其实是作为一个 goroutine 来执行</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol>
<li>协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 中断，挂起</li>
</ol>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><a href="https://blog.csdn.net/i6448038/article/details/82057424" target="_blank" rel="noopener">解剖Go语言map底层实现</a></p>
<p>map是一个哈希表，数据被安排在一个桶数组里面，每个桶最多存储8个键值对，哈希函数计算出来的值低8位用于选择KEY存储在哪个bucket,高8位用于寻找bucket中的哪个key。</p>
<p>并不是key0/value0/key1/value1的形式，而是key0/key1/value0/value1，这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。</p>
<h1 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="go命令"><a href="#go命令" class="headerlink" title="go命令"></a>go命令</h1><p>#go 实现数值排序</p>
<p>#go 实现字符串查找</p>
<h1 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h1><p>指针类型：</p>
<p>*类型：普通指针，用于传递对象地址，不能进行指针运算。</p>
<p>unsafe.Pointer：通用指针类型，用于转换不同类型的指针，不能进行指针运算。</p>
<p>uintptr：用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。</p>
<p>unsafe.Pointer 可以和 普通指针 进行相互转换。<br>unsafe.Pointer 可以和 uintptr 进行相互转换。</p>
<p>也就是说 unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/tcp-ip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/07/tcp-ip/" itemprop="url">TCP/IP 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-07T14:59:00+08:00">
                2019-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>过去几年中，一直沉溺在业务的开发，当遇到一些疑难杂症网络问题，虽即时可以解决（通过谷歌），但是没有系统性学习网络，现在处于深入做技术的需求，把这个以前遗留的网络知识好好恶补。</p>
<p>在学习资料的选择中，有视频、图书、文章等</p>
<ul>
<li><p>视频资料</p>
<ul>
<li><a href="https://www.bilibili.com/video/av10610680" target="_blank" rel="noopener">https://www.bilibili.com/video/av10610680</a> （在B站学习）<blockquote>
<p>感觉先看完一遍书再看视频会更好些</p>
</blockquote>
</li>
</ul>
</li>
<li><p>图书资料</p>
<ul>
<li>《图解TCP/IP》第5版 <blockquote>
<p>这本书通俗易懂 下面学习笔记也主要依据这本书进行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>优秀文章资料</p>
<ul>
<li>TODO</li>
</ul>
</li>
</ul>
<h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p><img src="/uploads/tcp-ip/osi.png" alt="OSI参考模型"></p>
<p>OSI将通信功能划分了7个分层，称作为OSI参考模型，只是一个模型，它也只是对各层的作用做了一些粗略的界定，并没有对协议和接口进行详细的定义。许多通信协议，都对应了7层中的某个层次，大致可以了解该协议在通信功能中的位置和作用。</p>
<p><strong>OSI协议与OSI参考模型</strong></p>
<p>OSI协议：是为了让异构的计算机之间能够互相通信的、由ISO与ITU-T推进标准化的一种网络体系结构</p>
<p>OSI参考模型：将通信功能划分为7个分层的模型</p>
<p>OSI协议是以OSI参考模型为基础界定了每个阶层的协议与每个阶层之间接口相关的标准</p>
<blockquote>
<ul>
<li>实际的TCP/IP 分层模型与OSI参考模型还有若干区别</li>
</ul>
</blockquote>
<h2 id="OSI参考模型各分层介绍"><a href="#OSI参考模型各分层介绍" class="headerlink" title="OSI参考模型各分层介绍"></a>OSI参考模型各分层介绍</h2><p>OSI参考模型每层作用</p>
<p><img src="/uploads/tcp-ip/osi-func.png" alt="OSI参考模型每层作用"></p>
<p>OSI分层定义与TCP/IP之间的参照关系图</p>
<p><img src="/uploads/tcp-ip/osi-tcp-ip.jpg" alt="OSI TCP/IP"></p>
<blockquote>
<p>下面每层的定义摘自书中，但其实无论百科还是很多学习资料，对每层的描述，都会有点不同</p>
</blockquote>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>为应用程序提供服务并规定应用程序中通信相关的细节，在应用层实现的协议基本都是解决了某一类应用场景的通信需求。比如电子邮件，文件传输，远程登陆</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>将上层应用处理的信息转换为合适的网络传输格式或者将下层的数据转换为上层能够处理的格式，因此这层主要是负责数据格式的转换</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>负责建立与管理会话</p>
<blockquote>
<p>实际的建立连接与断开连接是由传输层进行，会话层主要是负责建立与断开的判断（时机）</p>
</blockquote>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>主要是提供不同主机上的进程之间的逻辑通信（端到端的通信），传输层可以提供可靠传输是该层非常重要的一个作用</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>将数据传输到目的地址，这层主要负责寻址和路由选择</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>负责物理层面上互连的、节点之间的传输</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>负责0、1比特流（0，1序列)与电压高低、光的闪灭之间的互换</p>
<h3 id="传输层与网络层的关系"><a href="#传输层与网络层的关系" class="headerlink" title="传输层与网络层的关系"></a>传输层与网络层的关系</h3><p>在TCP/IP中网络层的IP协议中，不保证数据一定会发送到对端地址，传输过程中会发生数据丢失、顺序混乱等问题。为了解决这个问题，可以由传输层负责提供“正确传输数据的处理”（可靠传输，通过序列号机制、确认应答、超时重传、重复控制等方式）。</p>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="面向有连接与面向无连接"><a href="#面向有连接与面向无连接" class="headerlink" title="面向有连接与面向无连接"></a>面向有连接与面向无连接</h3><p>通过网络发送数据，大致可以分为面向有连接型与面向无连接型</p>
<p><img src="/uploads/tcp-ip/transport-type.png" alt="有连接与无连接"></p>
<blockquote>
<p>关于连接的含义</p>
<p>在不同分层协议中，连接的具体含义可能有所不同。在链路层中的连接，就是指物理的、通信线路的连接。<br>而在传输层则负责创建和管理逻辑上的连接</p>
</blockquote>
<p>面向有连接:：在发送数据之前，需要收发主机之间有一条连接，在该方式下，需要专门进行建立和断开连接的处理。如果与对端无法通信，可以避免发送数据造成浪费</p>
<blockquote>
<p>协议代表：TCP、帧中继、ATM协议</p>
</blockquote>
<p>面向无连接型：不要求建立和断开连接，接收端需要时常确认是否收到数据，因为接收端永远也不知道什么时候有人发数据给自己，发送端不需要确认对端存在，即使不在或者无法接收数据，发送端都会把数据发出去</p>
<blockquote>
<p>协议代表：IP、UDP、以太网协议</p>
</blockquote>
<h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h3><blockquote>
<p>数据交换技术主要是电路交换、报文交换、分组交换，<strong>TCP/IP采用分组交换技术</strong>，因此主要记录分组交换技术，分组交换技术较前面两种交换要新</p>
</blockquote>
<p>分组交换技术（Packet switching technology）也称包交换技术，是将用户传送的数据划分成一定的长度，每个部分叫做一个分组，通过传输分组的方式传输信息的一种技术</p>
<p><img src="/uploads/tcp-ip/packet-switching.png" alt="分组交换"></p>
<p>在分组交换中，由分组交换机（路由器）连接通信线路。路由器收到分组数据会按照顺序缓存在自己的缓冲区（队列），然后再先进先出逐一转发出去。</p>
<p>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此这条线路是共享线路。</p>
<blockquote>
<p>路由器的缓存饱和或者溢出时，甚至可能发生分组数据丢失、无法发送到对端的情况</p>
</blockquote>
<p><img src="/uploads/tcp-ip/packet-switching2.png" alt="分组交换2"></p>
<h2 id="单播、广播、多播-组播-、任播"><a href="#单播、广播、多播-组播-、任播" class="headerlink" title="单播、广播、多播(组播)、任播"></a>单播、广播、多播(组播)、任播</h2><h3 id="单播-unicast"><a href="#单播-unicast" class="headerlink" title="单播 unicast"></a>单播 unicast</h3><p><img src="/uploads/tcp-ip/unicast.png" alt></p>
<p>指1对1的通信，常用的非多播非广播的UDP、TCP消息就是单播</p>
<blockquote>
<p>早期互联网单播的传输足以满足需求，直到1993年，BSD4.4版本中实现了多播，互联网也发生了很大的变化，人们也想分享看的（视频）和听的（音频）。</p>
</blockquote>
<h3 id="广播-broadcast"><a href="#广播-broadcast" class="headerlink" title="广播 broadcast"></a>广播 broadcast</h3><p><img src="/uploads/tcp-ip/broadcast.png" alt></p>
<p>将消息从1台主机发送给与之相连的所有其他主机，广播通信一个典型例子就是电视播放，它将电视信号一起发送给非特定的多个对象。</p>
<p>我们知道电视一般都有自己的频段，只有相应的频段的可接收范围内才能收到电视信号。与之相似，进行广播通信计算机也有它们的广播范围，只有在这个范围内的计算机才能收到相应的广播消息。这个范围叫广播域。</p>
<h3 id="多播-multicast"><a href="#多播-multicast" class="headerlink" title="多播 multicast"></a>多播 multicast</h3><p><img src="/uploads/tcp-ip/multicast.png" alt></p>
<p>多播与广播类似，也是将消息发给多个主机，不同的是多播限定某一组主机作为接收端。</p>
<p>典型的例子是电视会议，由多组人不同地方参加一种远程会议，在这种形式下，会由一台主机发送特定的多台主机。</p>
<h3 id="任播-anycast"><a href="#任播-anycast" class="headerlink" title="任播 anycast"></a>任播 anycast</h3><p><img src="/uploads/tcp-ip/anycast.png" alt></p>
<p>是指在特定的多台主机选择一台作为接收端的一种通信方式，虽然与多播有相似之处，都是面向特定的一群主机，但行为却与多播不同，任播通信是从目标主机群里选择一台最符合网络条件的主机作为目标主机发送消息。通常被选中的主机将返回一个单播信号，虽然发送端主机会只跟这台主机进行通信</p>
<p>典型的例子就是DNS根域名解析服务器</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>在通信传输中，发送端与接收端可以被视为通信主体。它们都能由一个所谓“地址”信息标识出来。</p>
<p>在电话通讯中，电话号码就是“地址”</p>
<p>但在网络通讯中稍微复杂点，每一层的协议使用的地址都不同，比如链路层是MAC地址，网络层是IP地址，传输层是端口号(程序地址)</p>
<p>MAC地址与IP地址区别：</p>
<ol>
<li>MAC地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点，IP地址专注于网络层，将数据包从一个网络转发到另外一个网络</li>
<li>长度不同。IP地址为32位，MAC地址为48位。</li>
<li>分配依据不同。IP地址的分配是基于网络拓扑（容易改变），MAC地址的分配是基于制造商（烧录好一般不改动)。</li>
<li>MAC寻址参考的表叫地址转发表，IP寻址参考的表叫路由控制表</li>
</ol>
<h3 id="地址唯一性"><a href="#地址唯一性" class="headerlink" title="地址唯一性"></a>地址唯一性</h3><p>如果要想地址在通信中发挥作用，需要确定通信的主体。一个地址必须明确表示一个主体对象（主体对象并不代表只有一台设备，也许是N个设备，比如多播、任播接收端设备通常多个）。在同个通信网络中（互联网）不允许出现两个相同地址的通信主体存在。也就是地址必须具备唯一性</p>
<h3 id="地址层次性"><a href="#地址层次性" class="headerlink" title="地址层次性"></a>地址层次性</h3><p>当地址总数不多的情况下，有了唯一的地址，就能定位到通信主体，但是现在地址总数越来越多，如何高效的寻找通信的主体就成为了一个很重要的问题，因此地址还需要有层次性</p>
<p>就像电话号码有国家号、有区号，居住地址有国家、省份、城市、街道</p>
<blockquote>
<p>注意这里的层次性必须满足一个条件，能加快定位通信地址，这才是有效的层次性，MAC地址其实也有层次性，但为什么不是有效的层次性，因为它不能加快定位通信主体</p>
</blockquote>
<p>后面总结IP网际协议的时候，会介绍IP地址的构成</p>
<p><img src="/uploads/tcp-ip/addr.png" alt></p>
<h2 id="连接计算机与计算机的设备"><a href="#连接计算机与计算机的设备" class="headerlink" title="连接计算机与计算机的设备"></a>连接计算机与计算机的设备</h2><p><img src="/uploads/tcp-ip/network.png" alt><br><img src="/uploads/tcp-ip/network2.png" alt></p>
<h1 id="TCP-IP-基础知识"><a href="#TCP-IP-基础知识" class="headerlink" title="TCP/IP 基础知识"></a>TCP/IP 基础知识</h1><p>TODO 补充TCP/IP的发展史 不重要的后续补充</p>
<h2 id="TCP-IP-具体含义"><a href="#TCP-IP-具体含义" class="headerlink" title="TCP/IP 具体含义"></a>TCP/IP 具体含义</h2><p>从字面意义上，有人可能以为是指TCP与IP两种协议，确实也有这么用的时候，但很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称，具体来说，IP或ICMP、TCP或UDP、TELNET或FTP等都属于TCP/IP的协议。TCP/IP一词泛指这些协议，有时也称TCP/IP为网际协议族。</p>
<p><img src="/uploads/tcp-ip/tcp-ip-mean.png" alt></p>
<h2 id="互联网与TCP-IP关系"><a href="#互联网与TCP-IP关系" class="headerlink" title="互联网与TCP/IP关系"></a>互联网与TCP/IP关系</h2><p>互联网的定义：互联网英文单词”Internet”，从字面上理解,internet指的是将多个网络连接使其构成一个足够大的网络。所以internet一词本意就是网际网。</p>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP原本就是为了使用互联网而开发定制的协议族。因此，互联网的协议就是TCP/IP，TCP/IP就是互联网的协议。</p>
<h2 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h2><p><img src="/uploads/tcp-ip/tcpip-with-osi.png" alt></p>
<p>不难看除，TCP/IP分层与OSI参考模型稍有区别。OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪仲程序“。</p>
<h3 id="硬件（物理层）"><a href="#硬件（物理层）" class="headerlink" title="硬件（物理层）"></a>硬件（物理层）</h3><p>TCP/IP最底层是负责数据传输的硬件。这种硬件相当于以太网或电话线路等物理层的设备。关于它的内容一直无法统一定义。因为只要人们在物理层面上所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等有所不同，而在这些方面又没有一个既定的指标。</p>
<h3 id="网络接口层（数据链路层）"><a href="#网络接口层（数据链路层）" class="headerlink" title="网络接口层（数据链路层）"></a>网络接口层（数据链路层）</h3><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。也就是说把它当做让NIC起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p>
<p>有时人们也将网络接口层与硬件层合并起来称为网络通信层。</p>
<h3 id="互联网层（网络层）"><a href="#互联网层（网络层）" class="headerlink" title="互联网层（网络层）"></a>互联网层（网络层）</h3><p>互联网层使用IP协议，它相当于OSI参考模型中的网络层。IP协议是基于IP地址转发分包数据的。</p>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>TCP/IP的传输层有两个具有代表性（TCP、UDP）的协议，该层的功能与OSI参考模型中的传输层类似。</p>
<p>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的就是端口号（上面提到的程序地址）</p>
<h3 id="应用层（会话层及以上的分层）"><a href="#应用层（会话层及以上的分层）" class="headerlink" title="应用层（会话层及以上的分层）"></a>应用层（会话层及以上的分层）</h3><p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时候由一个单一的程序实现，有时也可能由多个程序实现。因此细看TCP/IP的应用层，它不仅实现OSI模型中的应用层内容，还要实现会话层与表示层的功能。</p>
<p>WWW：浏览器与服务端之间通信的协议用的是HTTP，所传输的数据格式主要是HTML。那么HTTP属于OSI应用层协议，HTML则属于表示层的协议。</p>
<p>FTP：在进行文件传输时会创建两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据所用到的数据连接，这两种连接的控制管理属于会话层的功能。</p>
<h2 id="TCP-IP分层模型与通信示例"><a href="#TCP-IP分层模型与通信示例" class="headerlink" title="TCP/IP分层模型与通信示例"></a>TCP/IP分层模型与通信示例</h2><p>假设甲给乙发送邮件，内容为：“早上好”，而从TCP/IP通信上看，是一台计算机A向另一台计算B发送电子邮件。</p>
<p>通这个例子理解一下通信过程。</p>
<p><img src="/uploads/tcp-ip/send-email.png" alt></p>
<ol>
<li>应用程序处理</li>
<li>TCP模块处理</li>
<li>IP模块处理</li>
<li>网络接口（以太网驱动）的处理</li>
</ol>
<h1 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h1><p>TCP/IP中对于OSI参考模型的数据链路层及以下部分（物理层）未作定义。因为TCP/IP以这两层的功能是透明的为前提，然后数据链路的知识对于深入理解TCP/IP与网络起着至关重要的作用。</p>
<h2 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h2><p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p>
<p>数据链路层的协议定义了通过通信媒介互连的设备之间传输规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等媒介。此外各个设备之间有时也会通过交换机（2层，3层，4-7层）、网桥、中继器等中转数据。</p>
<p>计算机是以0、1来表示信息，然而实际的通信媒介之间处理的却是电压的高低、光的闪灭以及电波的强弱。把这信号与二进制的0、1进行转换的正是物理层的责任。数据链路层处理的数据并不是单纯的0、1序列，该层把它们集合为一个叫做“帧”的块，然后进行传输。</p>
<p>数据链路也可以被视为网络传输中的最小单位。</p>
<p>连通全世界的互联网，不外乎是众多的数据链路组成的，因此互联网也被称为“数据链路的集合”。</p>
<h2 id="数据链路相关技术"><a href="#数据链路相关技术" class="headerlink" title="数据链路相关技术"></a>数据链路相关技术</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址用于识别数据链路层中互连的点。以太网或FDDI中，根据IEEE802.3的规范使用MAC地址。其他诸如无线LAN（IEEE802.11a/b/g/n等）、蓝牙设备中也是用相同规格的MAC地址。</p>
<p>MAC地址长48bit,在使用网卡（NIC）的情况下，MAC地址一般会被烧录入到ROM中。</p>
<p><img src="/uploads/tcp-ip/mac.png" alt></p>
<p>在全世界，MAC地址也并不是总是唯一的。这里与上面的“地址”有点冲突，但实际上，即使MAC地址相同，只要不是同属一个数据链路就不会出现问题（也就是一个数据链路内还是保持了唯一性）。</p>
<h3 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h3><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网分类"><a href="#以太网分类" class="headerlink" title="以太网分类"></a>以太网分类</h3><p>以太网因通信电缆的不同及通信速度的差异，衍生出了众多不同的以太网类型。</p>
<p><img src="/uploads/tcp-ip/enetwork.png" alt></p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p>以太网帧前端有一个叫做前导码的部分，它是由0、1数字交替组合而成，表示一个以太网帧的开始也是对端网卡能够确保与其同步的标识。</p>
<p><img src="/uploads/tcp-ip/preamble.png" alt></p>
<p>以太网帧的本体前端是以太网的首部，它总共14个字节，分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p>
<p><img src="/uploads/tcp-ip/enetwork-zhen.png" alt></p>
<p>紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是46-1500个字节，帧尾是一个叫做FCS（帧校验序列）的4个字节。如图，以太网帧与IEEE802.3帧头稍有区别。这里主要记录以太网的帧。</p>
<p>关于主要协议类型参考如下：<br><img src="/uploads/tcp-ip/enetwork-type.png" alt></p>
<h2 id="公共网络"><a href="#公共网络" class="headerlink" title="公共网络"></a>公共网络</h2><p>这里主要记录连接公共通信服务相关的细节。所谓的公共服务通信服务类似于电信运营商（如中国电信）提供的电话网络。人们通过与运营商签约、付费实现联网。</p>
<p>主要记录的两种种模拟电话线路（淘汰），ADSL。其实还有其它的移动通信、有线电视，FTTH，FTTB、专线、VPN。</p>
<p>FTTH 光纤到户 与 FTTB 光线到楼，现在也开始在逐渐覆盖。光纤具有寿命长,无干扰, 带宽几乎无限的优点,是铜线技术所无法比拟的。 </p>
<h3 id="模拟电话线路"><a href="#模拟电话线路" class="headerlink" title="模拟电话线路"></a>模拟电话线路</h3><blockquote>
<p>虽然淘汰了，但还是经历过这个时代，因此还是要讲讲</p>
</blockquote>
<p>模拟电话线路其实是利用固定电话线路进行通信。电话线中的音频带宽用于拨号上网。该方法不需要特殊的通信线路，完全使用已经普及的电话网。</p>
<p>让计算机与电话线相连需要有一个将数字信号转为模拟信号的调制解调器（俗称“猫”）。“猫”的传输速率一般只有56kbps左右，现在基本淘汰了。但是很怀旧所以再记录一下。</p>
<p><img src="/uploads/tcp-ip/mock-tel-link.png" alt></p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>ADSL是对已有的模拟电话线路进行扩展的一种服务，模拟电话线路虽然也能传输高频数字通信，但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率，并会对其他多余频率的信号进行丢弃。现在的电话网逐渐数字化，通过电话线路的信号再经过电信的交换机时会变成64kbps左右的数字信号。因此理论上无法传输比64kbps更块的数字信号。然后，每个话机到电信局交换机之前这段线路，是可以实现高速传输的。</p>
<p>ADSL正式利用了话机到电信局交换机之间的线路，附加了一个叫做分离器的装置，将音频信号（低频信号）和数字信号（高频信号)隔离以免产生噪声干扰。</p>
<p>ADSL中的线路速度根据通信方式或线路的质量以及距离电信局的远近有所不同。从ISP到家里/办公室的速率在1.5Mbps~50Mbps左右，而从家里/办公室到ISP端的速率一般在512kbps~2Mbps左右。</p>
<blockquote>
<p>这里的上下行传输速率不对称，是因为在铜芯电缆线年代，带宽小，且ADSL的宽带利用率下行高于上行，为了能在有限的贷带宽上提高下载速率，所以产生上下行不对称的制式，并且沿用至今。</p>
</blockquote>
<p><img src="/uploads/tcp-ip/adsl.png" alt></p>
<h1 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h1><p>TCP/IP的心脏就是互联网层（网络层），这一层主要由IP协议与ICMP协议两个协议组成。鉴于目前的IP已无法满足互联网的需求，于是出现了更高版本的IPv6。</p>
<h2 id="IP相当于OSI参考模型中第3层"><a href="#IP相当于OSI参考模型中第3层" class="headerlink" title="IP相当于OSI参考模型中第3层"></a>IP相当于OSI参考模型中第3层</h2><p>IP（IPv4、IPv6）相当于OSI参考模型中的第3层—-网络层。</p>
<p>网络层主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end)通信”</p>
<p>网络层的下一层是数据链路层，数据链路层的主要作用是互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p><img src="/uploads/tcp-ip/end-to-end.png" alt></p>
<h2 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h2><p>我们多次提到数据链路层中，是用MAC地址来识别同一链路不同计算机的。在网络层中，也由这种识别的地址信息，一般叫做IP地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP/IP通信中所有的主机或路由器必须设定自己的IP地址。</p>
<p>在网桥与集线器等物理层或数据链路层数据包转发设备中，不需要设置IP地址。因为这些设备只负责将IP包转化为0、1比特流或对数据链路帧的数据部分进行转发，而不需要应对IP协议。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制（Routing)是指将分组数据发送最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。</p>
<p><img src="/uploads/tcp-ip/routing1.png" alt></p>
<h3 id="发送数据至最终目标地址"><a href="#发送数据至最终目标地址" class="headerlink" title="发送数据至最终目标地址"></a>发送数据至最终目标地址</h3><p>Hop 翻译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。</p>
<p><img src="/uploads/tcp-ip/hop-by-hop.png" alt></p>
<h3 id="路由控制表"><a href="#路由控制表" class="headerlink" title="路由控制表"></a>路由控制表</h3><p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由。IP包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/uploads/tcp-ip/luyoukongzhibiao.png" alt></p>
<h2 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h2><h3 id="IP地址定义"><a href="#IP地址定义" class="headerlink" title="IP地址定义"></a>IP地址定义</h3><p>IP地址(IPv4地址)由32位正整数来表示，TCP/IP通信要求将这样的IP地址分配给每一个参与通信的主机。IP地址在计算机内部以二进制方式被处理。然而，由于人类社会并不会习惯采用二进制方式，需要采用一种特殊的方式，那就是将32位IP地址以每8位为一组，分成四组。每组以“.”隔开。再每组数转换为十进制。</p>
<h2 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h2><p><img src="/uploads/tcp-ip/ip-header.png" alt></p>
<ul>
<li>版本</li>
</ul>
<p>由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也是“4”。</p>
<ul>
<li>首部长度</li>
</ul>
<p>由4个比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说当没有可选项时，IP首部的长度为20字节（4*5）</p>
<ul>
<li>区分服务（TOS）</li>
</ul>
<p>由8比特构成，用来表明服务质量。每一位的具体含义如表：</p>
<p><img src="/uploads/tcp-ip/tos.png" alt></p>
<p>tosz整个互联网几乎就没有投入使用。不过已有人提出将TOS字段分为DSCP和ECN两个字段的建议</p>
<p><img src="/uploads/tcp-ip/dscp-ecn.png" alt></p>
<p>DSCP(Different Service Codepoint,差分服务代码点)是TOS的一部分。现在统称为DiffServ，用来进行质量控制。</p>
<p>ECN（Explicit Congestion Notification，显式拥塞通告）用来报告网络拥堵情况，由两个比特构成。</p>
<p><img src="/uploads/tcp-ip/ecn.png" alt></p>
<p>第6位的ECT用以通告上层TCP协议是否处理ECN。当路由器在转发ECN为1的包的过程中，如果出现网络拥堵的情况，就将CE位设置为1.</p>
<ul>
<li>总长度</li>
</ul>
<p>表示IP首部与数据部分合起来的总字节数。该字段长 比特。因此IP包的最大长度为65535字节。目前还不存在能传输65535字节的数据链路。不过，由于有IP分片处理，从IP上一层的角度看，都可以认为能够以IP的最大包长度传输数据。</p>
<ul>
<li>标识（ID）</li>
</ul>
<p>由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识不同。通常每发一个IP包它的值逐渐递增。此外ID相同，如果目标地址、源地址或者协议不同的话，也会被认为是不同的分片。</p>
<ul>
<li>标志（Flag）</li>
</ul>
<p>由3个比特构成，表示包被分片的相关信息。每一位的具体含义如下</p>
<p><img src="/uploads/tcp-ip/ip-flag.png" alt></p>
<ul>
<li>片偏移（FO）</li>
</ul>
<p>由13位比特构成，用来标识被分片的每一个分段相对于原始数据的位置。</p>
<ul>
<li>生存时间（TTL)</li>
</ul>
<p>由8个比特组成，早期设计是想以秒为单位，现在是指可以经过多少个路由器的意思，每经过一个路由器TTL会减1，直到变成0则丢弃该包。</p>
<ul>
<li>协议</li>
</ul>
<p>由8个比特构成，表示IP首部的下一个首部隶属于哪个协议</p>
<ul>
<li>首部校验和</li>
</ul>
<p>由16个比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。</p>
<ul>
<li>源地址</li>
</ul>
<p>由32比特（4字节）构成，表示发送端IP地址</p>
<ul>
<li>目标地址</li>
</ul>
<p>由32比特（4字节）构成，表示接收端IP地址</p>
<ul>
<li>可选项</li>
</ul>
<p>长度可变，通常只有在进行实验或诊断时使用</p>
<p>安全级别、源路径、路径记录、时间戳</p>
<ul>
<li>填充</li>
</ul>
<p>也称作填充物。在有可选项的情况下，首部的长度可能不是32比特的整数倍。为此，通过向字段填充0，调整为32比特</p>
<ul>
<li>数据</li>
</ul>
<p>存入数据。将IP层上层协议的首部也作为数据处理。</p>
<h2 id="显式拥塞通知"><a href="#显式拥塞通知" class="headerlink" title="显式拥塞通知"></a>显式拥塞通知</h2><p>当发生网络拥塞时，发送主机应该减少数据包的发送量。作为IP层上层协议，TCP虽然也能控制网络拥塞，不过它是通过数据包的损坏情况来判断是否发生拥塞。然后这种方法并不能在数据包损坏之前减少数据包的发送量。</p>
<p>为了解决这个问题，人们在IP层增加了一种使用显式拥塞通知的机制，即ECN。</p>
<p>ECN为了实现拥塞功能，将IP首部的TOS字段置换为ENC字段，并在TCP首部的保留位中追加CWR标识和ECE标志。</p>
<p>通知拥塞的时候，要将当前的拥塞情况传达给发送数据包的源地址主机。然后这个通知能不能发出也是一个问题，而且发出去了，如果遇到不支持拥塞控制协议的，那也就没什么实质意义。</p>
<p>因此ECN的机制概括起来就是发送包IP的首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生拥塞。拥塞检查在网络层进行，而且拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。</p>
<p><img src="/uploads/tcp-ip/yongsai.png" alt></p>
<h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><p>我们平常在访问某个网站的时候不使用IP地址，而是使用域名。能够这样做是因为DNS（Domain Name System)提供支持。DNS就是将域名转换具体的IP地址。</p>
<p>DNS如同互联网中的分布式数据库。DNS的传输层即同时支持TCP与UDP。端口一致为53。</p>
<h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p>域名由前缀和后缀组成，前缀是点前而的部分，例如baidu.com，前缀是baidu，而后缀是com，而前缀一般由注册者注册时自定义的。</p>
<p>提供英文字母（a-z，不区分大小写）、数字（0-9）、以及“ - ”（英文中的连词号，即中横线），不能使用空格及特殊字符(如!、$、&amp;、? 等),“ - ”不能用作开头和结尾，部分后缀支持前缀使用多语言。</p>
<p>例如，<a href="http://www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。" target="_blank" rel="noopener">www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。</a></p>
<p>直接调用网站的名字以后，DNS就会将便于人类使用的名字（如<a href="http://www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。" target="_blank" rel="noopener">www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。</a></p>
<p><img src="/uploads/tcp-ip/dns-domain.png" alt></p>
<h2 id="DNS查询机制"><a href="#DNS查询机制" class="headerlink" title="DNS查询机制"></a>DNS查询机制</h2><ol>
<li>查看浏览器内部缓存</li>
</ol>
<p>检测域名是否存在于浏览器缓存中，如果有缓存直接使用，没有则下一步。打开 chrome://net-internals/#dns 即可查看本机浏览器的 dns 缓存。</p>
<ol>
<li>系统缓存</li>
</ol>
<p>浏览器会调用一个类似 gethostbyname 的库函数，此函数会先去检测本地 hosts 文件，查看是否有对应 ip。<br>PS： 这里有一个点，localhost 默认 ip 是 172.0.0.1，这是一个回路段，也叫环回接口。也就是不会发往服务器，是直接在本地打开的。</p>
<ol>
<li>路由器缓存、ISP 缓存</li>
</ol>
<p>如果浏览器和系统缓存都没有，系统的 gethostname 函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。</p>
<ol>
<li>本地 DNS 服务器</li>
</ol>
<p>通常为自己计算机搭建的小型 DNS 服务器，自我使用，属于 DNS 优化的一部分。</p>
<blockquote>
<p>通常由运营商提供的，或者是自己设定的知名DNS解析服务器</p>
</blockquote>
<ol>
<li>域名服务器</li>
</ol>
<p>到此处的过程为：根域服务器（.） -&gt; 顶级域名服务器（eg: .com，.org）-&gt;<br>主域名服务器（eg: google.com）</p>
<h1 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h1><p>ARP译为地址解析协议，以目标主机IP地址为线索，查询其MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP协议只使用IPv4，不能用于IPv6。IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p>
<p>OSI模型有七层，TCP在第4层传输层，IP在第3层网络层，而ARP在第2层数据链路层。高层对低层是有强依赖的，所以TCP的建立前要进行ARP的请求和应答。</p>
<p>ARP高速缓存表在IP层使用。如果每次建立TCP连接都发送ARP请求，会降低效率，因此在主机、交换机、路由器上都会有ARP缓存表。建立TCP连接时先查询ARP缓存表，如果有效，直接读取ARP表项的内容进行第二层数据包的发送；只有表失效时才进行ARP请求和应答进行MAC地址的获取，以建立TCP连接。</p>
<p>下面是分组格式<br><img src="/uploads/tcp-ip/arp2.png" alt></p>
<h2 id="ARP的工作机制"><a href="#ARP的工作机制" class="headerlink" title="ARP的工作机制"></a>ARP的工作机制</h2><p>简单地说，ARP借助ARP请求和ARP响应两种类型的包确定MAC地址。</p>
<p>如果目的IP和自己在同一个网段：<br>当IP层的ARP高速缓存表中存在目的IP对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去<br>当IP层的ARP高速缓存表中不存在目的IP对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求目的IP的MAC，收到ARP应答之后，将应答之中的&lt;IP地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去</p>
<p>如果目的IP地址和自己不在同一个网段，就需要将包发送给默认网关，这需要知道默认网关的MAC地址：<br>当IP层的ARP高速缓存表中存在默认网关对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC<br>当IP层的ARP高速缓存表中不存在默认网关对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求默认网关的MAC，收到ARP应答之后，将应答之中的&lt;默认网关地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去。</p>
<h2 id="MAC地址与IP地址为何缺一不可"><a href="#MAC地址与IP地址为何缺一不可" class="headerlink" title="MAC地址与IP地址为何缺一不可"></a>MAC地址与IP地址为何缺一不可</h2><p>试想一下，假如不使用IP地址，而是通过MAC地址连接世界上所有计算机和节点的情况。仅仅凭一个MAC地址，人们无法知道这台机器所处位置（上面提到的MAC地址无高效寻址层次性），而且如果全世界的设备都用MAC地址相连，那么网桥在习得之前就得向全世界发送包，可想而知会造成多大得网络流量，而且又没有任何集约机制，网桥不得不维护一张巨大的表格来维护所学到的MAC地址，一旦超过了网桥所能承受的上限，网桥将无法正常工作。也就无法通信。</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>免费ARP指主机发送ARP查找自己的IP地址，通常发生在系统引导期间进行接口配置时。<br>与标准ARP的区别就是免费ARP分组的目的IP地址字段封装的是自己的IP地址，即向所在网络请求自己的MAC地址。</p>
<p>免费ARP的作用有：</p>
<ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的 IP地址。<br>正常情况下发送免费ARP请求不会收到ARP应答，如果收到了一个ARP应答，则说明网络中存在与本机相同的IP地址的主机，发生了地址冲突。</li>
<li>更新其他主机高速缓存中旧的硬件地址进行。<br>如果发送免费ARP的主机正好改变了硬件地址，如更换了接口卡。<br>其他主机接收到这个ARP请求的时候，发现自己的ARP高速缓存表中存在对应的IP地址，但是MAC地址不匹配，那么就需要利用接收的ARP请求来更新本地的ARP高速缓存表表项。</li>
<li>网关利用免费ARP防止ARP攻击<br>有些网关设备在一定的时间间隔内向网络主动发送免费ARP报文，让网络内的其他主机更新ARP表项中的网关MAC地址信息，以达到防止或缓解ARP攻击的效果。</li>
<li>利用免费ARP进行ARP攻击<br>ARP协议并不只在发送了ARP请求才接收ARP应答，计算机只要接收到ARP应答数据包，就会使用应答中的IP和MAC地址对本地的ARP缓存进行更新。<br>主机可以构造虚假的免费ARP应答，将ARP的源MAC地址设为错误的MAC地址，并把这个虚假的免费ARP应答发送到网络中，那么所有接收到这个免费ARP应答的主机都会更新本地ARP表项中相应IP地址对应的MAC地址。更新成功后，这些主机的数据报文就会被转发到错误的MAC地址，从而实现了ARP欺骗的攻击。</li>
</ol>
<h1 id="ICMP-互联网控制消息协议"><a href="#ICMP-互联网控制消息协议" class="headerlink" title="ICMP 互联网控制消息协议"></a>ICMP 互联网控制消息协议</h1><p>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能，就可以获得网络是否正常，设置是否正确以及设备有何异常的信息，从而方便网络上定位问题。</p>
<p>ICMP的消息大致分为两种类型：一类是通知出错原因的错误消息，一类是用于诊断的查询消息。</p>
<p><img src="/uploads/tcp-ip/icmp.png" alt></p>
<p>ICMP消息类型与对应消息内容<br><img src="/uploads/tcp-ip/icmp-type.png" alt></p>
<p>ICMP分组格式<br><img src="/uploads/tcp-ip/icmp-packet.jpg" alt></p>
<h2 id="ICMP实现之MTU探索"><a href="#ICMP实现之MTU探索" class="headerlink" title="ICMP实现之MTU探索"></a>ICMP实现之MTU探索</h2><p>所谓路径MTU 探索，是探索与通信对方之间不用分片IP 数据包，就能交流的MTU 大小的功能。MTU大小是指计算机一次能够送出去的数据的最大长度，基本上由网路的种类来决定。例如，以太网的话通常是1500 字节，使用PPPoE 的ADSL 通常是1492 字节。为了实现这个路径MTU 探索，ICMP 被使用着。沿着流程，具体看一下Windows 的MTU 探索的样子吧。</p>
<p><img src="/uploads/tcp-ip/icmp-mtu.jpg" alt></p>
<h1 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h1><p>如果逐一为每一台计算设置IP地址会是件非常繁琐的事情。特别是笔记本、智能终端、平板，每移动到一个地方，都要重新设置IP地址。于是，为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP。</p>
<p>DHCP，动态主机配置协议，前身是BOOTP协议，是一个局域网的网络协议，使用UDP协议工作，常用的2个端口：67(DHCP server),68(DHCP client)。DHCP通常被用于局域网环境，主要作用是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。</p>
<p><img src="/uploads/tcp-ip/dhcp.png" alt></p>
<h2 id="DHCP的工作机制"><a href="#DHCP的工作机制" class="headerlink" title="DHCP的工作机制"></a>DHCP的工作机制</h2><p>使用DHCP之前，首先要架设一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p>
<p><img src="/uploads/tcp-ip/dhcp-flow.png" alt></p>
<p>为了检查所要分配的IP地址以及已经分配了的IP地址可用，DHCP服务器或DHCP客户端必须具备下面功能：</p>
<ol>
<li>DHCP服务器：在分配IP地址前发送ICMP回送请求包，确认没有返回应答。</li>
<li>DHCP客户端：针对从DHCP服务端获得的IP地址发送ARP请求包，确认没有返回应答。</li>
</ol>
<h1 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a>NAT 协议</h1><p>NAT（Network Address Translator)是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除了转换IP外，还出现了可以转换TCP、UDP端口号的NAPT技术，由此实现一个全局IP地址与多个主机的通信。</p>
<p>NAT（NAPT）实际上是为了面临地址枯竭的IPv4而开发的技术。</p>
<h2 id="NAT-工作机制"><a href="#NAT-工作机制" class="headerlink" title="NAT 工作机制"></a>NAT 工作机制</h2><p><img src="/uploads/tcp-ip/nat-flow.png" alt></p>
<p>如上图，以10.0.0.10的主机与163.221.120.9的主机进行通信为例。利用NAT，途中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37)再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址(202.244.174.37)先转换称私有IP10.0.0.10以后再转发。</p>
<p>在NAT（NAPT）路由器内部，有一张自动生成的用来转换地址的表。当10.0.0.10向163.221.120.9发送第一个包时就生成这张表，并按照这张表的映射关系处理。</p>
<p>当私有网络内的多台机器同时都要与外部通信时，仅仅转换IP地址，人们不免担心全局IP地址不够用。这时采用了包含端口号一起转换的方式（NAPT）解决这个问题。</p>
<p><img src="/uploads/tcp-ip/napt.png" alt></p>
<p>留意上图，同端口映射的端口+1。</p>
<p>在TCP的情况下，建立TCP连接首次握手时，SYN包一经发出，就会生成表。又随着收到的关闭连接时发出的FIN包的确认应答从表中删除。</p>
<h1 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h1><p>UDP是User Datagram Protocol的缩写。</p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p>
<p>即使出现网络拥堵的情况下，UDPy也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉也没有纠正功能，如果需要这些细节控制，不得不交由应用程序上去处理。</p>
<p>UDP处理简单又高效，因此也经常用于下面几个方面</p>
<ol>
<li>包总量较少的通信（DNS、SNMP）</li>
<li>视频、音频等多媒体资源（即时通信）</li>
<li>限定于LAN等特定网络的应用通信</li>
<li>广播通信（广播、多播）</li>
</ol>
<h2 id="UDP首部的格式"><a href="#UDP首部的格式" class="headerlink" title="UDP首部的格式"></a>UDP首部的格式</h2><p><img src="/uploads/tcp-ip/udp-header.png" alt></p>
<ul>
<li><p>源端口号<br>表示发送端端口号，字段长16位，该字段是可选项，有时可能不会设置源端口，没有源端口号的时候该字段设置为0，可用于不需要返回的通信中。</p>
</li>
<li><p>目标端口号<br>表示接收端端口，字段长16位</p>
</li>
<li><p>包长度<br>该字段保存了UDP首部的长度和数据的长度之和，单位为字节。</p>
</li>
<li><p>校验和<br>校验和是为了提供可靠的UDP首部和数据而设计，在计算校验和时，附加了UDP伪首部与UDP数据报之前。通过在最后一位增加一个“0”将全长增加16倍。此时将UDP首部的校验和字段设置为“0”。然后以16比特为单位进行1的补码和，并将所得到的1的补码和写入校验和字段。</p>
</li>
</ul>
<p><img src="/uploads/tcp-ip/udp-checksum.png" alt></p>
<p>接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，再进行校验和计算。校验和字段的指是校验和字段以外剩下部分的1的补码和。因此，包括校验和字段在内的所有数据之和结果为“16位全部为1”时，才会被认为所收到的数据是正确的。</p>
<p>UDP中也有可能不用校验和，校验和字段中填入0，这种情况不进行校验和校验，会降低处理的开销。</p>
<h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><p>与UDP区别较大，TCP作为一种面向有连接型的协议，只有在确认通信对端存在时候才会发送数据，从而可以控制通信流量的浪费。它充分实现了数据传输时各种控制，可以进行丢包重发，乱序控制。</p>
<p>我们知道IP协议是不可靠的，为了通过IP数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题，如果不解决这些，也无从谈起可靠传输。</p>
<p>TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><p>在TCP中，当发送端的数据到达接收端的时候，接收端主机会返回一个已收到的消息通知，这个消息叫做确认应答。</p>
<p><img src="/uploads/tcp-ip/tcp-ack1.png" alt></p>
<p>TCP通过肯定的确认应答（ACK）实现可靠的数据传输，当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p>
<p><img src="/uploads/tcp-ip/tcp-ack2.png" alt></p>
<p>在一定时间内没有等到确认应答，发送端可以认为数据已经丢失，并进行重发，由此，即使产生了丢包，仍然能够保证数据达到对端。实现可靠传输。</p>
<p>当然，未收到确认应答并不意味着数据一定丢失，也有可能数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也是会导致发送端没有收到确认应答，从而进行重新发送。</p>
<p><img src="/uploads/tcp-ip/tcp-ack3.png" alt></p>
<p>此外，也有可能因为一些其它的原因导致，确认应答延迟到达，在源主机重发数据以后才能到达的情况也屡见不鲜，此时，源发送主机只要按照机制重发数据即可。但对于目标主机来说，简直一种“灾难”，会反复收到相同的数据，因此就必须引入一种机制（重复控制），能够识别是否已经接收数据，又能判断是否需要接收。</p>
<p>上述这些确认应答处理、重发控制以及重复控制等功能可以通过序列号实现。序列号是按顺序给发送数据的每个一个字节标上号码的编号。这个编号的初始值并不是为0，而是在建立连接以后由随机数生成。接收端查询接收数据TCP首部中序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返回送回去。就这样通过序列号和确认应答，TCP可以实现可靠的传输。</p>
<p><img src="/uploads/tcp-ip/tcp-offset.png" alt></p>
<p>TCP的数据长度并未写入TCP首部，实际是通过IP首部中的数据包长度间接求得。</p>
<h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><p>重发超时是指在重发数据之前，等待确认应答到来的这个特定时间间隔。如果超过了这个时间仍未收到确认应答，则进行重发数据。</p>
<p>TCP要求不论在何种网络环境下都要提高高性能通信，并且无论网络拥堵情况发生何种变化，都要保持这个特性。为此，它在每次发包的时候都会计算往返时间及其偏差，将这个往返时间和偏差值相加重发超时的时间，就是比这个总和要稍微大一点。</p>
<p><img src="/uploads/tcp-ip/tcp-timeout.png" alt></p>
<p>在BSD的Unix以及Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过由于最初的数据包还不知道往返时间所以其重发超时一般设置为6秒。</p>
<p>数据被重发之后若是还是收不到应答，则进行再次重发，等待确认的应答时间将会2、4倍的指数函数延长。</p>
<p>此外，数据也不会被无限、反复地重发。达到一定的重发次数之后，如果仍没有确认应答返回，就判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行中止。</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>TCP是面向连接型的通信传输，面向连接是指在数据通信之前先好通信两端之间的准备工作。</p>
<p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答，如果对端发来确认应答，则认为可以进行数据通信，如果对端的确认应答未能到达，就不会进行数据通信。此外在通信结束时会进行断开连接的处理（FIN包）</p>
<p><img src="/uploads/tcp-ip/tcp-conn.png" alt></p>
<p>可以使用TCP首部用于控制的字段管理连接，一个连接与断开，正常过程至少需要来回发7个包才能完成。</p>
<h3 id="理解TCP三次握手-四次断开的必要性"><a href="#理解TCP三次握手-四次断开的必要性" class="headerlink" title="理解TCP三次握手/四次断开的必要性"></a>理解TCP三次握手/四次断开的必要性</h3><p><a href="https://www.cnblogs.com/qiaoconglovelife/p/5733056.html" target="_blank" rel="noopener">附文章出处</a></p>
<h4 id="三次握手的必要性"><a href="#三次握手的必要性" class="headerlink" title="三次握手的必要性"></a>三次握手的必要性</h4><p><img src="/uploads/tcp-ip/tcp-conn-3.png" alt></p>
<p>必要性：TCP通过三次握手建立可靠的（确保收到）的全双工通信</p>
<ol>
<li>第一次握手和第二次握手（ACK部分）建立了从客户端到服务器传送数据的可靠连接</li>
<li>第二次握手（SYN部分）和第三次握手建立了从服务器到客户端传送数据的可靠连接</li>
<li>由于我们期望建立全双工连接，所以两个方向的通信都是需要的，于是合并了服务器发送的ACK和SYN</li>
<li>第三次握手的必要性：防止已失效的请求报文段突然又传送到了服务端而造成连接的误判。假如客户端发出连接请求A，由于网络原因，服务端并没有收到A，于是客户端又发送了连接请求B，并建立了连接，完成通信，断开连接。这时候，服务端突然又收到了A，于是看作是一次新的连接请求，进行第二次握手，由于不存在第三次握手，所以这时已经建立了TCP连接。但实际上客户端并没有发起连接，所以不会传递数据，那么这条连接就会变成一条死连接</li>
</ol>
<h4 id="四次握手的必要性"><a href="#四次握手的必要性" class="headerlink" title="四次握手的必要性"></a>四次握手的必要性</h4><p><img src="/uploads/tcp-ip/tcp-conn-4.png" alt><br>必要性：为保证单向通信的可行性，所以多一次握手</p>
<ol>
<li>主动断开方发送FIN时，被动断开方要回复ACK，意思是“我收到你的FIN了”</li>
<li>主动断开方发送FIN并不意味着立即关闭TCP连接，而是告诉对方自己没有更多的数据要发送了，只有当对方发完自己的数据再发送FIN后，才意味着关闭TCP连接</li>
<li>被动断开方收到FIN并回复ACK后，此时TCP处于“半关闭”状态，为保证被动断开方可以继续发送数据，所以第二个FIN并不会伴随ACK发送，所以比连接时多一个报文段</li>
</ol>
<h2 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h2><p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS)，最理想的情况是，最大消息长度是IP中正好不会被分片处理的最大数据长度。</p>
<p>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发也是MSS为单位。</p>
<p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS大小。</p>
<p>为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍。在建立连接时，如果某一方忽略MSS选项，可以选为IP包的长度不超过576字节（MSS=576-IP20-TCP20=536）</p>
<p><img src="/uploads/tcp-ip/tcp-mss.png" alt></p>
<h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP以1个段为单位，每发一个段进行一次确认应答处理，这样的传输方式有一个缺点，那么就是包的往返时间越长通信性能越低。</p>
<p>为了解决这个问题，TCP引入了窗口的概念，即使在往返时间较长的情况下，它也能控制网络性能的下降。确认应答不再是以每个段进行确认，而是更大的单位进行确认，转发时间将会被大幅度的缩短。</p>
<p><img src="/uploads/tcp-ip/tcp-window.png" alt></p>
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。<br>这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p>
<p><img src="/uploads/tcp-ip/tcp-window2.png" alt></p>
<p>发送数据中高亮圈起来的部分正式前面提到的窗口，这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需要进行重发。为此发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。</p>
<p>在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端收到的数据。当数据发出后若如期收到确认应答就可以不用进行重发，此时数据就可以从缓冲区清除。</p>
<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也称滑动窗口控制。</p>
<h2 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h2><p>在使用窗口控制中，如果出现段丢失怎么办？</p>
<p>首先，我们先考虑确认应答未能返回的情况，这种情况下，数据已经达到了对端，是已经不需要进行重发的，然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发，而使用了窗口控制，某些确认应答即使丢失了也不需要重发数据。</p>
<p><img src="/uploads/tcp-ip/tcp-window-retry.png" alt></p>
<p>其次，我们来考虑一下某个报文段丢失的情况，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。不过即使接收端主机收到的包序号不连续，也不会将数据丢弃，而是暂存到缓冲区。</p>
<p><img src="/uploads/tcp-ip/tcp-window-retry2.png" alt></p>
<p>当某一个报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”，因此在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断的地返回，而发送端主机如果连续3次收到同一个确认应答，就会将其所丢应的数据进行重发，这种机制比之前的提高的超时管理更加高效，因此也被作高速重发控制。</p>
<p>之所以连续收到3次而不是两次的理由是因为，即使数据段序列号被替换两次也不会触发重发机制。</p>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>TCP提供了一种机制可以让发送端根据接收端的实际接收能力发送数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收的数据大小，于是发送端会发送不超过这个限度的数据，该大小限度就被称作为窗口大小，是由接收端主机决定的。</p>
<p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机可以将自己可以接收的缓存区大小放入这个字段中通知发送端。这个字段的值越大，说明网络的吞吐量越高。</p>
<p>不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。</p>
<p><img src="/uploads/tcp-ip/tcp-stream-ctrl.png" alt></p>
<p>像上面这副图所示，当接收端收到从3001号开始的数据端后其缓冲区满了，不得不暂停停止接收数据，之后，在收到发送窗口更新通知后通信才得以继续，如果这个窗口更新通知中途丢失了，也不要紧，发送端定时会发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包，然而，如果在通信刚开始时就发送大量数据，也可能引发其他问题。</p>
<p>一般来说，计算网络都处于一个共享的环境，因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个叫大量的数据，极有可能会导致网络瘫痪。</p>
<p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>
<p><img src="/uploads/tcp-ip/tcp-yongsai.png" alt></p>
<p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念，于是在慢启动的时候，将这个拥塞窗口的大小设置为1MSS发送数据，之后没收到一个确认应答拥塞窗口增加1，在发送数据包时，将拥塞窗口的大小与接收端通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还要小的数据量。</p>
<p>随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生，为了防止这些，引入了慢启动阈值的概念，只要拥塞窗口的值超过这个阈值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口：</p>
<p><img src="/uploads/tcp-ip/tcp-yongsai-gongshi.png" alt></p>
<p><img src="/uploads/tcp-ip/tcp-yongsai2.png" alt></p>
<p>拥塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。因此，拥塞窗口的大小会呈直线上升的趋势。</p>
<p>TCP刚开始通信的时候，并没有设定相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口大小的一半。</p>
<p>由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为当时窗口大小的一半。然后将窗口的大小设置为该慢启动阈值+3个数据段的大小。</p>
<p>由于窗口的大小会直接影响数据被转发时的吞吐量，所以一般情况下，窗口越大，越会形成高吞吐量的通信。</p>
<h2 id="提高网络利用率的规范"><a href="#提高网络利用率的规范" class="headerlink" title="提高网络利用率的规范"></a>提高网络利用率的规范</h2><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>TCP中为了提高网络的利用率，经常使用一个叫做Nagle的算法。</p>
<p>该算法是指发送端即使还有应该发送的数据，但是如果这部分数据很少的话，则进行延迟发送的一种机制。仅在下面任意一种情况才能发送数据，如果两个条件都不满足，那么暂时等待一段时间以后再进行发送数据。</p>
<ol>
<li>已发送的数据都已经收到确认应答</li>
<li>可以发送的最大段长度已经达到MSS</li>
</ol>
<p>根据这个算法，可以提高网络利用率，但也会发生某种延迟，为此在窗口系统以及机械控制等领域中使用TCP往往会关闭对该算法的使用。</p>
<h3 id="延迟确认应答"><a href="#延迟确认应答" class="headerlink" title="延迟确认应答"></a>延迟确认应答</h3><p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。</p>
<p>当接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率（其实这是窗口控制特有的问题，叫糊涂窗口综合证），为此引入了一个方法，那就是收到数据以后并不立即确认响应，而是延迟一段时间的机制。</p>
<ol>
<li>在没有收到2MSS长度的数据为止不做确认应答（有得操作系统，只要收到两个包即刻返回确认应答）</li>
<li>其他情况下，最大延迟0.5秒发送确认应答。（很多操作系统设置为0.2秒左右）</li>
</ol>
<p>事实上，大可不必为每一个数据段都进行一次确认应答。TCP采用滑动窗口控制机制，因此通常确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。</p>
<p><img src="/uploads/tcp-ip/tcp-delay-reply.png" alt></p>
<h3 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h3><p>根据应用层协议，发送出去的消息到达对端，对端进行处理以后，会返回一个回执。例如，电子邮件协议的SMTP或POP、文件传输FTP中的连接控制部分等。这些应用协议使用同一个连接进行数据的交互。即使是使用WWW的HTTP，从1.1版本开始以后也是如此。</p>
<p>在此类通信中，TCP的确认应答和回执数据可以通过一个包发送，这种方式叫做捎带应答，通过这种机制，可以使收发处理减少一些。</p>
<p>另外，接收数据以后如果立刻确认应答，就无法实现捎带应答，而是将所接收的数据传给应用处理生成返回数据以后在进行发送请求为止，必须一直等待确认应答的发送。也就是说，没有启用延迟确认应答就无法实现捎带应答，延迟确认应答是能够提高网络利用率从而降低计算机处理负荷的一种优的处理机制。</p>
<p><img src="/uploads/tcp-ip/tcp-shaodai-ack.png" alt></p>
<h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><img src="/uploads/tcp-ip/tcp-header.png" alt></p>
<p>TCP中没有表示包长度和数据长度的字段，可由IP层获知TCP的包长度，由TCP包长获取可知数据的长度。</p>
<ul>
<li><p>源端口号<br>表示发送端的端口号，长度16bit</p>
</li>
<li><p>目标端口号<br>表示接收端端口号，长度16bit</p>
</li>
<li><p>序列号<br>字段长32位。序列号（有时也叫序号）是指发送数据的位置。序列号不会从0或1开始，而是再建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，然后每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p>
</li>
<li><p>确认应答号<br>确认应答号字段长度为32为，是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为这个序号以前的数据都已经被正常接收。</p>
</li>
<li><p>数据偏移<br>该字段表示TCP所传输的数据部分应该从TCP包哪个位开始算，当然也可以看作TCP首部的长度。该字段长4位，单位为4字节，不包括首选项字段的话，那么TCP首部为20字节长，因此数据偏移字段可以设置为5.</p>
</li>
<li><p>保留<br>该字段主要为了以后扩展使用，其长度为4位。一般设置为0。</p>
</li>
<li><p>控制位<br>字段长为8位。每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标识也叫做控制位。</p>
</li>
</ul>
<p><img src="/uploads/tcp-ip/tcp-control-flag.png" alt></p>
<ol>
<li>CWR<br> CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</li>
<li>ECE<br> ECE标志表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部ECN为1时，将TCP首部中的ECE设置为1.</li>
<li>URG<br> 该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理的数据，会在后面的紧急指针中在进行解释。</li>
<li>ACK<br> 该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</li>
<li>PSH<br> 该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</li>
<li>RST<br> 该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发送连接请求，也无法进行通信，此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因，导致主机重启的情况，由于所有的连接信息将被全部初始化，所以原有的TCP通信将不能继续进行，这种情况下，如果通信对方发送一个RST设置为1的包，将会使通信强制断开连接。</li>
<li>SYN<br> 用于建立连接，SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的决定。</li>
<li>FIN<br> 该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方之间就可以相互交换FIN位置为1的包TCP段。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是，主机可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</li>
</ol>
<ul>
<li><p>窗口大小<br>该字段为16位，用于通知从相同TCP首部的确认应答号所指位置开始能够接收的字节大小。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p>
</li>
<li><p>校验和<br>TCP的校验和与UDP校验和相似，区别在于TCP的校验和无法关闭。</p>
</li>
</ul>
<p><strong>使用校验和的目的是什么？</strong></p>
<p>有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP也需要进行校验和？</p>
<p>其实相比检查噪声影响导致的错误，TCP与UDP的校验和更是一种进行路由器内存故障或者程序漏洞导致的数据是否被破坏的校验。</p>
<p>路由器的程序中也有可能存在漏洞，或程序异常宕掉的可能性。在互联网中发送数据包要经由好多个路由器，一旦在发送途中某一个路由器发生故障，经过此路由器的包、协议首部或者数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p>
<ul>
<li>紧急指针<br>该字段长为16位，只有在URG控制位为1时有效。该字段的数值表示本报文段中的紧急数据的指针。正确地讲，从数据部分的首位到紧急指针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数据的末尾在报文段中的为止。</li>
</ul>
<p>如何处理紧急数据属于应用的问题，一般暂时中断通信，或中断通信的情况下使用。例如在Web浏览器中点击停止按钮，或者TELNET输入Ctrl+C时都会有URG为1的包。此外，紧急指针也用作表示数据流分段的标志。</p>
<ul>
<li>选项<br>选项字段用于提高TCP的传输性能。因为根据数据偏移（首部长度）进行控制，所以其长度最大为40字节。<br>另外选项字段尽量调整32位的整数倍。</li>
</ul>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>当用户在浏览器的地址里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务端的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p>
<p><img src="/uploads/tcp-ip/http1.png" alt><br><img src="/uploads/tcp-ip/http2.png" alt></p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>用于HTTP协议交互的信息被成为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端叫做响应报文。HTTP报文本身是由多行(CR+LF作换行符)的数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行(CR+LF)来划分。通常，并不一定要有报文主体。</p>
<p><img src="/uploads/tcp-ip/http-packet.png" alt></p>
<h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p>我们来看一下请求报文和响应报文的结构<br><img src="/uploads/tcp-ip/http-packet2.png" alt></p>
<p><img src="/uploads/tcp-ip/http-packet3.png" alt></p>
<p>请求行<br>包含用于请求的方法，请求URI和HTTP版本</p>
<p>状态行<br>包含表明响应结果的状态码，原因短语和HTTP版本</p>
<p>首部字段<br>包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：分别是：通用首部、请求首部、响应首部和实体首部</p>
<p>其他<br>可能包含HTTP的RFC里面未定义的首部（Cookie）</p>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP在传输数据时候可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求，但是，编码的操作需要计算机来完成，因此会消耗更多的CPU。</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文（message)</li>
</ul>
<p>是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</p>
<ul>
<li>实体（entry）</li>
</ul>
<p>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>
<p>通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>下面压缩与复原的流程<br><img src="/uploads/tcp-ip/http-encoder.png" alt></p>
<p>常用的内容编码：</p>
<ul>
<li>gzip (GNU zip）</li>
<li>compress （Unix系统的标准压缩）</li>
<li>deflate （zlib)</li>
<li>identity （不进行编码）</li>
</ul>
<h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够浏览器逐步显示页面。</p>
<p>这种把实体主体分块的功能成为分块传输(chunked transfer coding)</p>
<p><img src="/uploads/tcp-ip/http-chunked-transfer.png" alt></p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体。</p>
<p>HTTP/1.1中存在一种成为传输编码(transfer coding)的机制，它可以在通信技术按某种编码方式传输，但只定义作用于分块传输编码中。</p>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中采纳了多部分对象集合，发送的一份报文主，体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>
<p>多部分对象集合包含的对象如下</p>
<ul>
<li>multipart/form-data：在 Web 表单文件上传时使用</li>
<li>multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</li>
</ul>
<p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p>
<p><img src="/uploads/tcp-ip/http-range-request.png" alt></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p><img src="/uploads/tcp-ip/http-code-type.png" alt></p>
<h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。</p>
<h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<h2 id="加密处理防止被窃听"><a href="#加密处理防止被窃听" class="headerlink" title="加密处理防止被窃听"></a>加密处理防止被窃听</h2><p>在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。</p>
<ul>
<li>通信的加密</li>
</ul>
<p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。</p>
<p>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。</p>
<p><img src="/uploads/tcp-ip/http-tongxin-s.png" alt></p>
<ul>
<li>内容的加密</li>
</ul>
<p>还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。</p>
<p>在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。</p>
<p><img src="/uploads/tcp-ip/http-content-s.png" alt></p>
<p>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。</p>
<h2 id="HTTP-加上加密处理和认证以及完整性保护后即是HTTPS"><a href="#HTTP-加上加密处理和认证以及完整性保护后即是HTTPS" class="headerlink" title="HTTP 加上加密处理和认证以及完整性保护后即是HTTPS"></a>HTTP 加上加密处理和认证以及完整性保护后即是HTTPS</h2><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。</p>
<p><img src="/uploads/tcp-ip/https-ssl.png" alt></p>
<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<h2 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h2><p>在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<ul>
<li>共享密钥加密的困境</li>
</ul>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。 (前面有提到)</p>
<p><img src="/uploads/tcp-ip/share-key.png" alt></p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<ul>
<li>使用两把密钥的公开密钥加密</li>
</ul>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p>
<p><img src="/uploads/tcp-ip/private-public-key.png" alt></p>
<ul>
<li>HTTPS采用混合加密机制</li>
</ul>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<p><img src="/uploads/tcp-ip/hunhe-jiami.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zpl">
          <p class="site-author-name" itemprop="name">Zpl</p>
           
              <p class="site-description motion-element" itemprop="description">随便记一下，顺便骚一下</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zpl</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
