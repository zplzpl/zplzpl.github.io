<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Zpl,Golang,TCP/IP,ElasticSearch,Redis,Mysql,OS,Life">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="随便记一下，顺便骚一下">
<meta name="keywords" content="技术、生活、健身">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员Zpl">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="程序员Zpl">
<meta property="og:description" content="随便记一下，顺便骚一下">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员Zpl">
<meta name="twitter:description" content="随便记一下，顺便骚一下">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>程序员Zpl</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Zpl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code and gym<br>做最强壮的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/algorithm-structure-learning/" itemprop="url">算法与数据结构基础学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:33:38+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。</p>
<h2 id="重要的问题类型"><a href="#重要的问题类型" class="headerlink" title="重要的问题类型"></a>重要的问题类型</h2><p>计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。<br>最重要的问题类型如下：</p>
<ul>
<li>排序</li>
<li>查找</li>
<li>字符串处理</li>
<li>图问题</li>
<li>组合问题</li>
<li>几何问题</li>
<li>数值问题</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序问题要求我们按照升序重新排列给定列表中的数据项。</p>
<p>我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人的平均成绩来对学生记录进行排序，这段特别选定的信息成为键（key）</p>
<p>计算机科学家通常只关心如何对键进行排序，哪怕表中的元素不是记录，也许仅仅是整数。</p>
<p>到目前为止科学家已经开发出了几十种不同的排序算法。但没有一种算法再任何情况下都是最优的。<br>有些算法比较适合随机排列的输入，而另一些则更适合基本有序的列表。有些算法仅适合排列驻留再快速存储器中的列表。而另一些可以用来对存储再磁盘上的大型文件排序，如此等等。</p>
<p>排序算法有两个特性值得一提：</p>
<ul>
<li>如果一个排序算法保留了等值元素的输入中的相对位置，就可以说它是稳定的。</li>
<li>如果一个算法不需要额外的存储空间（除了个别存储单元以外），我们就说它是在位（in-place）</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找问题就是在给定的集合（或者是多重集，它允许多个元素具有相同的值）中找一个给定的值（我们称之为查找键）。</p>
<p>对于查找来说，也没有一种算法在任何情况下都是最优的。有些算法比其他算法速度快，但需要更多的存储空间。有些算法速度非常快，但仅使用于有序的数组。</p>
<p>和排序算法不同，查找算法没有稳定性问题。但会发生其他问题。查找问题就必须结合另外两种操作一起考虑，在数据集合中添加和删除元素的操作。</p>
<p>在这种情况下必须仔细选择数据结构和算法。以便在各种操作的需求之间达到一个平衡。而且对于高效查找（以及添加和删除）的特大型数据集合来说，如何组织其结构是一个不同寻常的挑战，而这对实际应用具有非常重要的意义。</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串是字符表中的符号所构成序列。我们尤其关心文本串，它是由字母、数字以及特殊符号构成的；位串是由“0”和“1”构成的；</p>
<p>如何在文本查找一个给定的词，这一特殊问题引起了研究人员的特别关注，它们成为字符串匹配问题。类似这种查找的特性，人们发明了好几种算法。</p>
<h2 id="图问题"><a href="#图问题" class="headerlink" title="图问题"></a>图问题</h2><p>TODO</p>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>TODO</p>
<h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p>TODO</p>
<h2 id="数值问题"><a href="#数值问题" class="headerlink" title="数值问题"></a>数值问题</h2><p>TODO</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>数据结构定义：对相关的数据项进行组织的特殊架构。</p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一维数组是n个相同数据类型的元素构成的序列，他们连续存储在计算机的存储器种，我们只要指定数组的下标就能够访问这些元素</p>
<p>无论位于数组的什么为止，都能用相等的常量时间访问数组中的任何元素。这种特性不是链表所具有的。</p>
<p>数组可以实现多种其他的数据结构，比较出名是<strong>字符串</strong>。字符串是来自于字母表的字符序列，并以一个特殊字符来标志字符串的结束。<br>字符串的常见操作不同于其他数组的典型操作。字符串的典型操作包括计算字符串的长度，按照字典序（即字母顺序）确定两个字符串在排序时的顺序。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是0个或多个成为节点的元素构成的序列，每个节点包含两类信息：一类是数据；另一类是一个或者多个成为指针的链接，指向链表中其他元素。</p>
<p>如果指向链表其他元素位null的时候表明节点没有后继元素。</p>
<p>单链表中，除了尾节点，每个节点都包含一个指向下一个元素的指针。</p>
<p>为了访问链表中的某个特定元素，我们从链表的首节点开始，沿指针链向前遍历，直到访问到该特定元素为止。因此和数组不同，访问单链表元素所需要的时间依赖于该元素在的链表中的位置。</p>
<p>优点：</p>
<ul>
<li>链表不需要实现分配任何存储空间</li>
<li>插入和删除的效率也非常高，只要相关的节点重新连接就可以了。</li>
</ul>
<p>为了增加链表灵活性，链表通常从一个称为表头的特殊节点开始，这个节点包含链表的长度，包含一个指向头元素的指针，还有可以包含指向尾元素的指针。</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>这是单向链表的扩展结构，其中除了首尾两个节点，每个节点都同时包含指向前趋的指针和指向后继的指针。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列也是一种列表，只是删除元素在列表的一头进行，这一头成为队头（出队），查入元素在表的另一头进行，这一头成为队尾（入队），因此，队列是按照“先进先出”(First-In-First-Out FIFO)的方式运转。</p>
<p>队列也有许多重要的而英勇，其中包括一些图问题的算法。</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>从一个动态改变的候选集合中选择一个优先级最高的元素。有一种数据结构可以满足，称为优先队列。</p>
<p>优先队列是数据项中的一个集合，这些数据项都来自于一些全序域。对优先队列的主要操作包括查找最大元素、删除最大元素和查入新的元素。</p>
<p>我们可以基于数组或者有序数组来实现优先队列，但这两种都不是最高效率的方案，优先队列有更好的实现方法，我们称之为堆(heap)</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种插入和删除操作都只能在端部进行的列表，这一端称为栈顶。</p>
<p>当我们在栈中添加一个元素或者删除一个元素时，该结构都按照一种“后进先出”（Last-In-First-Out LIFO)的方式运转。</p>
<p>栈的应用很广，对于实现递归算法来说时不可缺少的。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树，更精确地说，自由树就是连通无回路图。无回路但不一定连通的图成为森林。</p>
<p>树的边数总是比它的顶点数少1</p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>树的另外一个非常重要的特性就是：树的任意两个顶点之间总是恰好存在一条从一个顶点到另一个顶点的简单路径。这个性质使得以下做法成为可能：</p>
<p>任选自由树种的一个顶点，将它作为所谓的有根树的根。对有根树的描述中，根通常放在最顶上（树的第0层），邻接根的顶点放在根的下面，再下面是跟根距离两条边的顶点，然后以此类推。</p>
<p>有根树扮演很重要的角色，远比自由树重要，它们常常被简称为“树”。也就是说“树”通常是指有根树。</p>
<h4 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h4><p>有序树是一颗有根树，树中每个顶点的所有子女都是有序的。</p>
<h2 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h2><p>分析算法效率一般框架一般有两种：时间效率和空间效率</p>
<ul>
<li>时间雄安率指出算法的运行速度，空间效率涉及算法需要的额外空间。</li>
<li>算法的时间效率主要用它输入规模的函数来度量。该函数计算算法基本操作的执行次数。基本操作是总云心赶时间中工先最大的操作。通常它是算法的最内层循环中最费时的操作。</li>
<li>大多算法的效率可以分为以下几类：常数、对数、线性、线性对数、平方、立方和指数</li>
</ul>
<p>o(1)常数, o(n)线性, o(logn)对数, o(nlogn)线性对数</p>
<ul>
<li>比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。</li>
<li>再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。</li>
<li>再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</li>
<li>O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。</li>
<li>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961615&amp;idx=1&amp;sn=8711d52aa7bbd77db02eded67f6cc299&amp;chksm=bd2d0cd38a5a85c5e767e3be02fe885d0bcc95a9755d1e9b52971aac31b4fbca24227102a578&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我时间复杂度了 -  58沈剑  架构师之路</a></p>
<h1 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h1><p><img src="/uploads/algorithm-structure-learning/sort-table.jpg" alt></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序开始的时候，我们扫描整个列表，找到它最小元素，然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素中的最小元素，再和第二个元素交换位置，把第二小元素放在它的最终位置上。</p>
<p>一般来说，在对该列表进行第i遍扫描的时候，该算法在最后n-i个元素中寻找最小元素，然后拿它和Ai交换。</p>
<p>优点：</p>
<ul>
<li>不需要额外的存储空间</li>
<li>键的交换次数仅为O(n)，或者更精确点时n-1次。这个特性使得选择排序优于许多其他排序</li>
</ul>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 不稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/xuanze.gif" alt></p>
<h3 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(in); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[min] &gt; in[j] &#123;</span><br><span class="line">				min = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		in[i], in[min] = in[min], in[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它比较表中的相邻元素，如果它们是逆序的话，就交换它们的位置。重复多次以后，最终，最大的元素就“沉到”列表最后一个位置。第二遍操作将第二大的元素沉下去。这样一直做，直到n-1遍以后，该列表就排好序了。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/bubbleSort.gif" alt></p>
<h3 id="Golang实现-1"><a href="#Golang实现-1" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[j] &gt; in[j+<span class="number">1</span>] &#123;</span><br><span class="line">				in[j], in[j+<span class="number">1</span>] = in[j+<span class="number">1</span>], in[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>另外有一种扩展算法，是以发明者希尔命名-SHELL排序。此排序提供了一种更好的算法来对较大的文件进行排序。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-2"><a href="#Golang实现-2" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">		cur := in[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; in[j]; j-- &#123;</span><br><span class="line">			in[j+<span class="number">1</span>] = in[j]</span><br><span class="line">		&#125;</span><br><span class="line">		in[j+<span class="number">1</span>] = cur</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。</p>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/shellSort.webp" alt></p>
<h3 id="Golang实现-3"><a href="#Golang实现-3" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">	gap := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> gap &lt; length/<span class="number">3</span> &#123;  <span class="comment">// &lt;O(n^(3/2))</span></span><br><span class="line">		gap = gap*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; length; i++ &#123;</span><br><span class="line">			temp := arr[i]</span><br><span class="line">			j := i - gap</span><br><span class="line">			<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap &#123;</span><br><span class="line">				arr[j+gap] = arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+gap] = temp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并排序（归并排序）"><a href="#合并排序（归并排序）" class="headerlink" title="合并排序（归并排序）"></a>合并排序（归并排序）</h2><p>合并排序是成功应用分治技术的一个完美例子。对于一个需要排序的数组A[0..n-1]，合并排序把它一分为二：A[0..n/2-1]和A[n/2..n-1]，并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 稳定 |</p>
<p>exmpale:</p>
<p>Input:   {4, 1, 5, 8, 9, 3, 2, 6, 7}<br>Divide: {4, 1, 5, 8}, {9, 3, 2, 6, 7}<br>Divide: {4, 1}, {5, 8}, {9, 3}, {2, 6}, {7}<br>Divide: {4}, {1}, {5}, {8}, {9}, {3}, {2}, {6}, {7}</p>
<p>Merge: {1, 4}, {5, 8}, {3, 9}, {2, 6}, {7}<br>Merge: {1, 4, 5, 8}, {2, 3, 6, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 8, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 7 ,8, 9}</p>
<h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-4"><a href="#Golang实现-4" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(in []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> in</span><br><span class="line">	&#125;</span><br><span class="line">	mid := <span class="built_in">len</span>(in) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> merge(mergeSort(in[:mid]), mergeSort(in[mid:]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">			result[i] = left[<span class="number">0</span>]</span><br><span class="line">			left = left[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result[i] = right[<span class="number">0</span>]</span><br><span class="line">			right = right[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(left); j++ &#123;</span><br><span class="line">		result[i] = left[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(right); j++ &#123;</span><br><span class="line">		result[i] = right[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于分治思想的重要排序算法，不像合并排序是按照元素在数组中的位置对它们进行划分，快速排序按照元素的值对它们进行划分。划分是对给定数组中的元素的重新排列。使得A[s]左边的元素都小于等于A[s]，而所有A[s]右边的元素都大于等于A[s]；</p>
<p>显然，建立一个划分以后，A[s]已经位于它在有序数组中的最终位置，接下来我们可以继续对A[s]前和A[s]后的子数组分别进行排序。</p>
<p>注意它与合并排序不同之处在于：</p>
<ul>
<li>在合并排序算法中，将问题划分成两个子问题是很快的，算法的主要工作在于合并子问题的解；</li>
<li>而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并问题的解了。</li>
</ul>
<p>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p>它的最内层循环效率非常，使得在处理随机排列的数组时，速度要比合并排序快（对于堆排序也是如此。堆排序是另一种效率为nlogn的算法）。</p>
<p>人们对这个基本算法，进行了坚持不懈的改良，研究人员在这一领域的重要成果包括：</p>
<ul>
<li>更好的中轴选择方法：例如随即快速排序，它使用随机的元素作为中轴；三平分划分法，它以数组最左边、最右边和最中间的元素的中位数作为中轴。</li>
<li>当子数组足够小时（对于大多数计算机系统而言，元素数为5-15），改用插入排序方法，或者根本就不再对小数组进行排序，而是在快速排序结束后再使用插入排序的方法对整个近似有序的数组进行排序。</li>
<li>一些划分方法的挨近，例如三路划分，将数组分成三段，每段的元素分别小于、等于、大于中轴元素。</li>
</ul>
<p>根据国际上快速排序的权威塞奇威克的说法，如果同时应用这些改进措施，可以将该算法的运行时间削减20%-30%</p>
<p>但是与其他算法一样，快速排序算法也又缺点，它是不稳定的。同时它还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到O(logn)，但是它还是比堆排序O(1)的空间效率差。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 不稳定 |</p>
<h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/quickSort.gif" alt><br><img src="/uploads/algorithm-structure-learning/quickSort2.gif" alt></p>
<h3 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> _quickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		partition := partition(arr, left, right)</span><br><span class="line">		_quickSort(arr, left, partition<span class="number">-1</span>)</span><br><span class="line">		_quickSort(arr, partition+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	pivot := left</span><br><span class="line">	index := left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := index; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; arr[pivot] &#123;</span><br><span class="line">			arr[i], arr[index] = arr[index], arr[i]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[pivot], arr[index<span class="number">-1</span>] = arr[index<span class="number">-1</span>], arr[pivot]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 堆排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在一个标准的字典中可能会把“堆”定义成元素的无序堆积，但被称为“堆”的数据结构绝对不符合这个定义。我们更应该把它说成是一种灵巧的，部分有序的数据结构，它尤其使用用来实现优先级队列。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请回忆一下，优先队列是元素的一个集合，其中每个元素都包含一个被成为元素优先级的可排序属性。优先队列支持下面的：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 找出一个具有最高优先级的元素（即最大元素）</span></span><br><span class="line"><span class="string">* 删除一个具有最高优先级的元素</span></span><br><span class="line"><span class="string">* 添加一个元素到集合中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主要是由于这些操作的有效实现，使得堆既龄人感兴趣，又非常具有实用价值。在诸如操作系统的作页调度以及通信网络中流量管理等场景中，非常需要采用优先队列。并且优先队列也常常出现在一些重要的算法，例如Prim算法，Dijkstra算法，曼哈夫编码，还有在分支界限中的应用。堆排序是一种在理论上十分重要的排序算法，它的基础也依赖于堆这一数据结构。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span></span><br><span class="line"><span class="string">小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序的时间雄安率和合并排序的时间效率属于同一类，并且不同的是，堆排序是在位的，也就是说，它并不需要任何额外的存储空间。针对随机文件的计时实验指出，堆排序比快速排序运行得慢，但是和合并排序相比还是有竞争力的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">| 时间复杂度 |  O(nlogn) |</span></span><br><span class="line"><span class="string">| 稳定性 | 不稳定 |</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆可以定义为一颗二叉树，树的节点中包含键（每个节点一个键），并且树满足下面两个条件：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 树的形状要求---这个二叉树是基本完备的（或者简称完全二叉树），这意味着，树的每一层都是满的，除了最后一层最右边的元素可能缺位。</span></span><br><span class="line"><span class="string">1. 父母优势要求，又称为堆特性--每个节点的键都要大于或者等于它的子女的键（对于任何叶子我们认为这个条件都是自动满足的）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请注意，在堆中，键值是从上到下排序的。也就是说，在任何从根到某个叶子的路径上，键值的序列是递减的（如果允许相等键的存在，则是非递增的）。然而，键值之间并不存在从左到右的次序。也就是说，在树的同一层的节点之间，不存在任何关系，更一般地说，在同一节点的左右子树之间也没有任何关系。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面列出堆的重要特性，这些特性都是不难证明的：</span></span><br><span class="line"><span class="string">1. 只存在一颗n个节点的完全二叉树，它的高度等于log2n</span></span><br><span class="line"><span class="string">1. 堆的根总是包含了堆的最大元素</span></span><br><span class="line"><span class="string">1. 堆的一个节点以及该节点的子孙也是一个堆</span></span><br><span class="line"><span class="string">1. 可以用数组来实现堆，方法是用从上到下、从左到右的方式来记录堆的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">虽然大多数处理堆的算法来说，把堆想象成二叉树可以容易地理解它们所隐含的思想，但对于实际实现来说，使用数组会简单得多，效率也高得多。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在数组中，对于一个位于父母位置i(1&lt;=i&lt;=n/2)的键来说，它的子女将会在2i和2i+1，相应地，对于位于i(2&lt;=i&lt;=n)的键来说，它的父母将会在i/2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 动画演示</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort2.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort3.gif)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Golang实现</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	heapify(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">		siftDown(arr, <span class="number">0</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (<span class="built_in">len</span>(arr) - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(heap []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; heap[child] &gt; heap[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> heap[root] &gt; heap[child] &#123;</span><br><span class="line">			heap[root], heap[child] = heap[child], heap[root]</span><br><span class="line">			root = child</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>敲重点</p>
<ul>
<li>这是个线性时间复杂度的算法</li>
<li>不是通过比较的方式</li>
<li>必须有明确的范围</li>
<li>数据规模不能太大，因为需要额外开辟数组空间</li>
</ul>
<p>计数排序的核心是，空间换时间</p>
<p>计数排序，时间复杂度为O(n)；<br>当待排序元素个数很多，但值域范围很窄时，计数排序是很节省空间的；</p>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/countingSort.gif" alt></p>
<h3 id="Golang实现-5"><a href="#Golang实现-5" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="keyword">int</span>, maxValue <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bucketLen := maxValue + <span class="number">1</span></span><br><span class="line">	bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, bucketLen)</span><br><span class="line"></span><br><span class="line">	sortedIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		bucket[arr[i]] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketLen; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> bucket[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			arr[sortedIndex] = i</span><br><span class="line">			sortedIndex += <span class="number">1</span></span><br><span class="line">			bucket[i] -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p>
<p>桶排序的基本思想：</p>
<p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p>
<p>桶排序的适用范围是，待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间。</p>
<p>桶排序，是一种复杂度为O(n)的排序<br>桶排序，是一种稳定的排序<br>桶排序，适用于数据均匀分布在一个区间内的场景</p>
<h3 id="Golang实现-6"><a href="#Golang实现-6" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(array []<span class="keyword">int</span>, bucketSize <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> max, min <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nBuckets := <span class="keyword">int</span>(max-min)/bucketSize + <span class="number">1</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, nBuckets)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nBuckets; i++ &#123;</span><br><span class="line">		buckets[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		idx := <span class="keyword">int</span>(n-min) / bucketSize</span><br><span class="line">		buckets[idx] = <span class="built_in">append</span>(buckets[idx], n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sorted := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bucket) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			insertionSort(bucket)</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, bucket...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p>
<p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p>
<p>基数排序适用于：</p>
<ol>
<li>数据范围较小，建议在小于1000</li>
<li><p>每个数值都要大于等于0</p>
<p>算法描述</p>
</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<ul>
<li>基的选取，可以先从个位开始，也可以先从十位开始，结果是一样的；</li>
<li>基数排序，是一种稳定的排序；</li>
<li><p>时间复杂度，可以认为是线性的O(n)；</p>
<h3 id="LSD动画演示"><a href="#LSD动画演示" class="headerlink" title="LSD动画演示"></a>LSD动画演示</h3><p><img src="/uploads/algorithm-structure-learning/radixSort.gif" alt></p>
<h3 id="Golang实现-7"><a href="#Golang实现-7" class="headerlink" title="Golang实现"></a>Golang实现</h3><blockquote>
<p>这里bucket扩展为两倍支持负数加入排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[<span class="number">0</span>])))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		v := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[i])))</span><br><span class="line">		<span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxDigit := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> max/<span class="number">10</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">		maxDigit++</span><br><span class="line">		max = max / <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> dev, j := <span class="number">1</span>, <span class="number">0</span>; j &lt; maxDigit; j++ &#123;</span><br><span class="line"></span><br><span class="line">		buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">			idx := (arr[i]/dev)%<span class="number">10</span> + <span class="number">10</span></span><br><span class="line">			buckets[idx] = <span class="built_in">append</span>(buckets[idx], arr[i])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">				arr[pos] = v</span><br><span class="line">				pos++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev = dev * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="常见关于排序的问题"><a href="#常见关于排序的问题" class="headerlink" title="常见关于排序的问题"></a>常见关于排序的问题</h2><h3 id="TOP-K"><a href="#TOP-K" class="headerlink" title="TOP K"></a>TOP K</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961587&amp;idx=1&amp;sn=54bf39db7043cc638315caf70f24d94b&amp;chksm=bd2d0d2f8a5a84395246be4522d10fbfc1f744658047d5fb3fad8e9f3c3d76baab3a2ce84867&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我TopK了</a></p>
<h4 id="TOP-K-无序"><a href="#TOP-K-无序" class="headerlink" title="TOP K 无序"></a>TOP K 无序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	buildHeap(arr, k)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; arr[<span class="number">0</span>] &#123;</span><br><span class="line">			arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">			siftDown2(arr, <span class="number">0</span>, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (k - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown2(arr, i, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown2</span><span class="params">(arr []<span class="keyword">int</span>, low, high <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := low</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> child &gt;= high &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; high &amp;&amp; arr[child] &gt; arr[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> arr[root] &gt; arr[child] &#123;</span><br><span class="line">			arr[root], arr[child] = arr[child], arr[root]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TOP-K-有序"><a href="#TOP-K-有序" class="headerlink" title="TOP K 有序"></a>TOP K 有序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKbubble</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>(result, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>-i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.bookstack.cn/read/JS-Sorting-Algorithm" target="_blank" rel="noopener">十大经典排序算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/linux-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/linux-learning/" itemprop="url">Linux学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T21:54:54+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/redis-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/redis-learning/" itemprop="url">Redis学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T17:20:54+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/es-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/es-learning/" itemprop="url">ElasticSearch 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:46+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/34669354" target="_blank" rel="noopener">知乎阿里ES专栏-Elasticsearch内核解析 - 写入篇</a></p>
<p><a href="https://www.ctolib.com/docs/sfile/ELKstack-guide-cn/elasticsearch/principle/index.html" target="_blank" rel="noopener">ElasticSearch架构原理</a></p>
<p><a href="http://www.cnblogs.com/richaaaard/p/5227477.html" target="_blank" rel="noopener"></a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="索引文档的过程（写）"><a href="#索引文档的过程（写）" class="headerlink" title="索引文档的过程（写）"></a>索引文档的过程（写）</h1><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li>可靠性：或者是持久性，数据写入系统成功后，数据不会被回滚或丢失。</li>
<li>一致性：数据写入成功后，再次查询时必须能保证读取到最新版本的数据，不能读取到旧数据。</li>
<li>原子性：一个写入或者更新操作，要么完全成功，要么完全失败，不允许出现中间状态。</li>
<li>隔离性：多个写入操作相互不影响。</li>
<li>实时性：写入后是否可以立即被查询到。</li>
<li>性能：写入性能，吞吐量到底怎么样。</li>
</ul>
<h2 id="Lucene的写"><a href="#Lucene的写" class="headerlink" title="Lucene的写"></a>Lucene的写</h2><p>Elasticsearch内部使用了Lucene完成索引创建和搜索功能，Lucene中写操作主要是通过IndexWriter类实现，IndexWriter提供三个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long addDocument();</span><br><span class="line">public long updateDocuments();</span><br><span class="line">public long deleteDocuments();</span><br></pre></td></tr></table></figure>
<p>通过这三个接口可以完成单个文档的写入，更新和删除功能，包括了分词，倒排创建，正排创建等等所有搜索相关的流程。<br>只要Doc通过IndesWriter写入后，后面就可以通过IndexSearcher搜索了，看起来功能已经完善了，但是仍然有一些问题没有解：</p>
<ul>
<li>上述操作是单机的，而不是我们需要的分布式。</li>
<li>文档写入Lucene后并不是立即可查询的，需要生成完整的Segment后才可被搜索，如何保证实时性？</li>
<li>Lucene生成的Segment是在内存中，如果机器宕机或掉电后，内存中的Segment会丢失，如何保证数据可靠性 ？</li>
<li>Lucene不支持部分文档更新，但是这又是一个强需求，如何支持部分更新？</li>
</ul>
<p>上述问题，在Lucene中是没有解决的，那么就需要Elasticsearch中解决上述问题。<br>Elasticsearch在解决上述问题时，除了我们在上一篇《Elasticsearch数据模型简介》中介绍的几种系统字段外，在引擎架构上也引入了多重机制来解决问题。我们再来看Elasticsearch中的写机制。</p>
<h2 id="Elasticsearch的写"><a href="#Elasticsearch的写" class="headerlink" title="Elasticsearch的写"></a>Elasticsearch的写</h2><ol>
<li>每个Index由多个Shard组成，每个Shard有一个主节点和多个副本节点，副本个数可配。但每次写入的时候，写入请求会先根据_routing规则选择发给哪个Shard，Index Request中可以设置使用哪个Filed的值作为路由参数，如果没有设置，则使用Mapping中的配置，如果mapping中也没有配置，则使用_id作为路由参数，然后通过_routing的Hash值选择出Shard（在OperationRouting类中），最后从集群的Meta中找出出该Shard的Primary节点</li>
<li>请求接着会发送给Primary Shard，在Primary Shard上执行成功后，再从Primary Shard上将请求同时发送给多个Replica Shard，请求在多个Replica Shard上执行成功并返回给Primary Shard后，写入请求执行成功，返回结果给客户端</li>
</ol>
<blockquote>
<p>这种模式下，写入操作的延时就等于latency = Latency(Primary Write) + Max(Replicas Write)。只要有副本在，写入延时最小也是两次单Shard的写入时延总和，写入效率会较低，但是这样的好处也很明显，避免写入后，单机或磁盘故障导致数据丢失，在数据重要性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。</p>
</blockquote>
<p>在每一个Shard中，写入流程分为两部分，先写入Lucene，再写入TransLog。</p>
<p><img src="/uploads/es/shard-write.jpg" alt></p>
<ol>
<li>写入请求到达Shard后，先写Lucene文件，创建好索引，此时索引还在内存里面，接着去写TransLog，写完TransLog后，刷新TransLog数据到磁盘上，写磁盘成功后，请求返回给用户。</li>
<li>写Lucene内存后，并不是可被搜索的，需要通过Refresh把内存的对象转成完整的Segment后，然后再次reopen后才能被搜索，一般这个时间设置为1秒钟，导致写入Elasticsearch的文档，最快要1秒钟才可被从搜索到，所以Elasticsearch在搜索方面是NRT（Near Real Time）近实时的系统</li>
<li>每隔一段比较长的时间，比如30分钟后，Lucene会把内存中生成的新Segment刷新到磁盘上，刷新后索引文件已经持久化了，历史的TransLog就没用了，会清空掉旧的TransLog</li>
</ol>
<h3 id="Segment-Merge"><a href="#Segment-Merge" class="headerlink" title="Segment Merge"></a>Segment Merge</h3><p>其中用一句话概括了 Lucene 的设计思路就是”开新文件”。从另一个方面看，开新文件也会给服务器带来负载压力。因为默认每 1 秒，都会有一个新文件产生，每个文件都需要有文件句柄，内存，CPU 使用等各种资源。一天有 86400 秒，设想一下，每次请求要扫描一遍 86400 个文件，这个响应性能绝对好不了！</p>
<p>为了解决这个问题，ES 会不断在后台运行任务，主动将这些零散的 segment 做数据归并，尽量让索引内只保有少量的，每个都比较大的，segment 文件。这个过程是有独立的线程来进行的，并不影响新 segment 的产生。</p>
<p>当归并完成，较大的这个 segment 刷到磁盘后，commit 文件做出相应变更，删除之前几个小 segment，改成新的大 segment。等检索请求都从小 segment 转到大 segment 上以后，删除没用的小 segment。这时候，索引里 segment 数量就下降了。</p>
<h1 id="索引文档的过程（读）"><a href="#索引文档的过程（读）" class="headerlink" title="索引文档的过程（读）"></a>索引文档的过程（读）</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/mysql-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/mysql-learning/" itemprop="url">Mysql学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:29+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/golang-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/golang-learning/" itemprop="url">Go学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T11:23:16+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p>Golang 简称 Go，Go 的协程(goroutine) 和我们常见的线程(Thread)一样，拥有其调度器。</p>
<h2 id="调度器的三个基本对象"><a href="#调度器的三个基本对象" class="headerlink" title="调度器的三个基本对象"></a>调度器的三个基本对象</h2><ul>
<li>G (Goroutine)，代表协程，也就是每次代码中使用 go 关键词时候会创建的一个对象</li>
<li>M (Work Thread)，工作线程</li>
<li>P (Processor)，代表一个处理器，又称上下文</li>
</ul>
<h2 id="G-M-P三者的关系与特点"><a href="#G-M-P三者的关系与特点" class="headerlink" title="G-M-P三者的关系与特点"></a>G-M-P三者的关系与特点</h2><ul>
<li>每一个运行的 M 都必须绑定一个 P，线程M 创建后会去检查并执行G (goroutine)对象</li>
<li>每一个 P 保存着一个协程G 的队列</li>
<li>除了每个 P 自身保存的 G 的队列外，调度器还拥有一个全局的 G 队列</li>
<li>M 从队列中提取 G，并执行</li>
<li>P 的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改</li>
<li>M 的个数和 P 的个数不一定一样多（会有休眠的M 或 P不绑定M ）（最大10000）</li>
<li>P 是用一个全局数组（255）来保存的，并且维护着一个全局的 P 空闲链表</li>
</ul>
<p><img src="/uploads/golang/gmp.png" alt></p>
<h2 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h2><ul>
<li>全局G任务队列会和各个本地G任务队列按照一定的策略互相交换。没错，就是协程任务交换。</li>
<li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li>
<li>转移<ul>
<li>局部与全局，全局G个数 / P个数</li>
<li>局部与局部，一次性转移一半</li>
</ul>
</li>
</ul>
<h2 id="Gorutine从入队到执行"><a href="#Gorutine从入队到执行" class="headerlink" title="Gorutine从入队到执行"></a>Gorutine从入队到执行</h2><ol>
<li>当我们创建一个G对象，就是 gorutine，它会加入到本地队列或者全局队列</li>
<li>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件。细节点如下：<ol>
<li>先找到一个空闲的P，如果没有则直接返回</li>
<li>P 个数不会占用超过自己设定的cpu个数</li>
<li>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个空队列</li>
<li>注意这里有一个点：<ul>
<li>无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建</li>
<li>不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满</li>
<li>新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来</li>
</ul>
</li>
</ol>
</li>
<li>M 会启动一个底层线程，循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：<ol>
<li>当前 M 所绑的 P 队列中找</li>
<li>去别的 P 的队列中找</li>
<li>去全局 G 队列中找</li>
</ol>
</li>
<li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li>
<li>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</li>
<li>入口 main 函数，其实是作为一个 goroutine 来执行</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol>
<li>协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 中断，挂起</li>
</ol>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h1 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="go命令"><a href="#go命令" class="headerlink" title="go命令"></a>go命令</h1><p>#go 实现数值排序</p>
<p>#go 实现字符串查找</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/tcp-ip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/07/tcp-ip/" itemprop="url">TCP/IP 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-07T14:59:00+08:00">
                2019-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>过去几年中，一直沉溺在业务的开发，当遇到一些疑难杂症网络问题，虽即时可以解决（通过谷歌），但是没有系统性学习网络，现在处于深入做技术的需求，把这个以前遗留的网络知识好好恶补。</p>
<p>在学习资料的选择中，有视频、图书、文章等</p>
<ul>
<li><p>视频资料</p>
<ul>
<li><a href="https://www.bilibili.com/video/av10610680" target="_blank" rel="noopener">https://www.bilibili.com/video/av10610680</a> （在B站学习）<blockquote>
<p>感觉先看完一遍书再看视频会更好些</p>
</blockquote>
</li>
</ul>
</li>
<li><p>图书资料</p>
<ul>
<li>《图解TCP/IP》第5版 <blockquote>
<p>这本书通俗易懂 下面学习笔记也主要依据这本书进行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>优秀文章资料</p>
<ul>
<li>TODO</li>
</ul>
</li>
</ul>
<h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p><img src="/uploads/tcp-ip/osi.png" alt="OSI参考模型"></p>
<p>OSI将通信功能划分了7个分层，称作为OSI参考模型，只是一个模型，它也只是对各层的作用做了一些粗略的界定，并没有对协议和接口进行详细的定义。许多通信协议，都对应了7层中的某个层次，大致可以了解该协议在通信功能中的位置和作用。</p>
<p><strong>OSI协议与OSI参考模型</strong></p>
<p>OSI协议：是为了让异构的计算机之间能够互相通信的、由ISO与ITU-T推进标准化的一种网络体系结构</p>
<p>OSI参考模型：将通信功能划分为7个分层的模型</p>
<p>OSI协议是以OSI参考模型为基础界定了每个阶层的协议与每个阶层之间接口相关的标准</p>
<blockquote>
<ul>
<li>实际的TCP/IP 分层模型与OSI参考模型还有若干区别</li>
</ul>
</blockquote>
<h2 id="OSI参考模型各分层介绍"><a href="#OSI参考模型各分层介绍" class="headerlink" title="OSI参考模型各分层介绍"></a>OSI参考模型各分层介绍</h2><p>OSI参考模型每层作用</p>
<p><img src="/uploads/tcp-ip/osi-func.png" alt="OSI参考模型每层作用"></p>
<p>OSI分层定义与TCP/IP之间的参照关系图</p>
<p><img src="/uploads/tcp-ip/osi-tcp-ip.jpg" alt="OSI TCP/IP"></p>
<blockquote>
<p>下面每层的定义摘自书中，但其实无论百科还是很多学习资料，对每层的描述，都会有点不同</p>
</blockquote>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>为应用程序提供服务并规定应用程序中通信相关的细节，在应用层实现的协议基本都是解决了某一类应用场景的通信需求。比如电子邮件，文件传输，远程登陆</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>将上层应用处理的信息转换为合适的网络传输格式或者将下层的数据转换为上层能够处理的格式，因此这层主要是负责数据格式的转换</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>负责建立与管理会话</p>
<blockquote>
<p>实际的建立连接与断开连接是由传输层进行，会话层主要是负责建立与断开的判断（时机）</p>
</blockquote>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>主要是提供不同主机上的进程之间的逻辑通信（端到端的通信），传输层可以提供可靠传输是该层非常重要的一个作用</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>将数据传输到目的地址，这层主要负责寻址和路由选择</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>负责物理层面上互连的、节点之间的传输</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>负责0、1比特流（0，1序列)与电压高低、光的闪灭之间的互换</p>
<h3 id="传输层与网络层的关系"><a href="#传输层与网络层的关系" class="headerlink" title="传输层与网络层的关系"></a>传输层与网络层的关系</h3><p>在TCP/IP中网络层的IP协议中，不保证数据一定会发送到对端地址，传输过程中会发生数据丢失、顺序混乱等问题。为了解决这个问题，可以由传输层负责提供“正确传输数据的处理”（可靠传输，通过序列号机制、确认应答、超时重传、重复控制等方式）。</p>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="面向有连接与面向无连接"><a href="#面向有连接与面向无连接" class="headerlink" title="面向有连接与面向无连接"></a>面向有连接与面向无连接</h3><p>通过网络发送数据，大致可以分为面向有连接型与面向无连接型</p>
<p><img src="/uploads/tcp-ip/transport-type.png" alt="有连接与无连接"></p>
<blockquote>
<p>关于连接的含义</p>
<p>在不同分层协议中，连接的具体含义可能有所不同。在链路层中的连接，就是指物理的、通信线路的连接。<br>而在传输层则负责创建和管理逻辑上的连接</p>
</blockquote>
<p>面向有连接:：在发送数据之前，需要收发主机之间有一条连接，在该方式下，需要专门进行建立和断开连接的处理。如果与对端无法通信，可以避免发送数据造成浪费</p>
<blockquote>
<p>协议代表：TCP、帧中继、ATM协议</p>
</blockquote>
<p>面向无连接型：不要求建立和断开连接，接收端需要时常确认是否收到数据，因为接收端永远也不知道什么时候有人发数据给自己，发送端不需要确认对端存在，即使不在或者无法接收数据，发送端都会把数据发出去</p>
<blockquote>
<p>协议代表：IP、UDP、以太网协议</p>
</blockquote>
<h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h3><blockquote>
<p>数据交换技术主要是电路交换、报文交换、分组交换，<strong>TCP/IP采用分组交换技术</strong>，因此主要记录分组交换技术，分组交换技术较前面两种交换要新</p>
</blockquote>
<p>分组交换技术（Packet switching technology）也称包交换技术，是将用户传送的数据划分成一定的长度，每个部分叫做一个分组，通过传输分组的方式传输信息的一种技术</p>
<p><img src="/uploads/tcp-ip/packet-switching.png" alt="分组交换"></p>
<p>在分组交换中，由分组交换机（路由器）连接通信线路。路由器收到分组数据会按照顺序缓存在自己的缓冲区（队列），然后再先进先出逐一转发出去。</p>
<p>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此这条线路是共享线路。</p>
<blockquote>
<p>路由器的缓存饱和或者溢出时，甚至可能发生分组数据丢失、无法发送到对端的情况</p>
</blockquote>
<p><img src="/uploads/tcp-ip/packet-switching2.png" alt="分组交换2"></p>
<h2 id="单播、广播、多播-组播-、任播"><a href="#单播、广播、多播-组播-、任播" class="headerlink" title="单播、广播、多播(组播)、任播"></a>单播、广播、多播(组播)、任播</h2><h3 id="单播-unicast"><a href="#单播-unicast" class="headerlink" title="单播 unicast"></a>单播 unicast</h3><p><img src="/uploads/tcp-ip/unicast.png" alt></p>
<p>指1对1的通信，常用的非多播非广播的UDP、TCP消息就是单播</p>
<blockquote>
<p>早期互联网单播的传输足以满足需求，直到1993年，BSD4.4版本中实现了多播，互联网也发生了很大的变化，人们也想分享看的（视频）和听的（音频）。</p>
</blockquote>
<h3 id="广播-broadcast"><a href="#广播-broadcast" class="headerlink" title="广播 broadcast"></a>广播 broadcast</h3><p><img src="/uploads/tcp-ip/broadcast.png" alt></p>
<p>将消息从1台主机发送给与之相连的所有其他主机，广播通信一个典型例子就是电视播放，它将电视信号一起发送给非特定的多个对象。</p>
<p>我们知道电视一般都有自己的频段，只有相应的频段的可接收范围内才能收到电视信号。与之相似，进行广播通信计算机也有它们的广播范围，只有在这个范围内的计算机才能收到相应的广播消息。这个范围叫广播域。</p>
<h3 id="多播-multicast"><a href="#多播-multicast" class="headerlink" title="多播 multicast"></a>多播 multicast</h3><p><img src="/uploads/tcp-ip/multicast.png" alt></p>
<p>多播与广播类似，也是将消息发给多个主机，不同的是多播限定某一组主机作为接收端。</p>
<p>典型的例子是电视会议，由多组人不同地方参加一种远程会议，在这种形式下，会由一台主机发送特定的多台主机。</p>
<h3 id="任播-anycast"><a href="#任播-anycast" class="headerlink" title="任播 anycast"></a>任播 anycast</h3><p><img src="/uploads/tcp-ip/anycast.png" alt></p>
<p>是指在特定的多台主机选择一台作为接收端的一种通信方式，虽然与多播有相似之处，都是面向特定的一群主机，但行为却与多播不同，任播通信是从目标主机群里选择一台最符合网络条件的主机作为目标主机发送消息。通常被选中的主机将返回一个单播信号，虽然发送端主机会只跟这台主机进行通信</p>
<p>典型的例子就是DNS根域名解析服务器</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>在通信传输中，发送端与接收端可以被视为通信主体。它们都能由一个所谓“地址”信息标识出来。</p>
<p>在电话通讯中，电话号码就是“地址”</p>
<p>但在网络通讯中稍微复杂点，每一层的协议使用的地址都不同，比如链路层是MAC地址，网络层是IP地址，传输层是端口号(程序地址)</p>
<p>MAC地址与IP地址区别：</p>
<ol>
<li>MAC地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点，IP地址专注于网络层，将数据包从一个网络转发到另外一个网络</li>
<li>长度不同。IP地址为32位，MAC地址为48位。</li>
<li>分配依据不同。IP地址的分配是基于网络拓扑（容易改变），MAC地址的分配是基于制造商（烧录好一般不改动)。</li>
<li>MAC寻址参考的表叫地址转发表，IP寻址参考的表叫路由控制表</li>
</ol>
<h3 id="地址唯一性"><a href="#地址唯一性" class="headerlink" title="地址唯一性"></a>地址唯一性</h3><p>如果要想地址在通信中发挥作用，需要确定通信的主体。一个地址必须明确表示一个主体对象（主体对象并不代表只有一台设备，也许是N个设备，比如多播、任播接收端设备通常多个）。在同个通信网络中（互联网）不允许出现两个相同地址的通信主体存在。也就是地址必须具备唯一性</p>
<h3 id="地址层次性"><a href="#地址层次性" class="headerlink" title="地址层次性"></a>地址层次性</h3><p>当地址总数不多的情况下，有了唯一的地址，就能定位到通信主体，但是现在地址总数越来越多，如何高效的寻找通信的主体就成为了一个很重要的问题，因此地址还需要有层次性</p>
<p>就像电话号码有国家号、有区号，居住地址有国家、省份、城市、街道</p>
<blockquote>
<p>注意这里的层次性必须满足一个条件，能加快定位通信地址，这才是有效的层次性，MAC地址其实也有层次性，但为什么不是有效的层次性，因为它不能加快定位通信主体</p>
</blockquote>
<p>后面总结IP网际协议的时候，会介绍IP地址的构成</p>
<p><img src="/uploads/tcp-ip/addr.png" alt></p>
<h2 id="连接计算机与计算机的设备"><a href="#连接计算机与计算机的设备" class="headerlink" title="连接计算机与计算机的设备"></a>连接计算机与计算机的设备</h2><p><img src="/uploads/tcp-ip/network.png" alt><br><img src="/uploads/tcp-ip/network2.png" alt></p>
<h1 id="TCP-IP-基础知识"><a href="#TCP-IP-基础知识" class="headerlink" title="TCP/IP 基础知识"></a>TCP/IP 基础知识</h1><p>TODO 补充TCP/IP的发展史 不重要的后续补充</p>
<h2 id="TCP-IP-具体含义"><a href="#TCP-IP-具体含义" class="headerlink" title="TCP/IP 具体含义"></a>TCP/IP 具体含义</h2><p>从字面意义上，有人可能以为是指TCP与IP两种协议，确实也有这么用的时候，但很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称，具体来说，IP或ICMP、TCP或UDP、TELNET或FTP等都属于TCP/IP的协议。TCP/IP一词泛指这些协议，有时也称TCP/IP为网际协议族。</p>
<p><img src="/uploads/tcp-ip/tcp-ip-mean.png" alt></p>
<h2 id="互联网与TCP-IP关系"><a href="#互联网与TCP-IP关系" class="headerlink" title="互联网与TCP/IP关系"></a>互联网与TCP/IP关系</h2><p>互联网的定义：互联网英文单词”Internet”，从字面上理解,internet指的是将多个网络连接使其构成一个足够大的网络。所以internet一词本意就是网际网。</p>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP原本就是为了使用互联网而开发定制的协议族。因此，互联网的协议就是TCP/IP，TCP/IP就是互联网的协议。</p>
<h2 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h2><p><img src="/uploads/tcp-ip/tcpip-with-osi.png" alt></p>
<p>不难看除，TCP/IP分层与OSI参考模型稍有区别。OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开发哪仲程序“。</p>
<h3 id="硬件（物理层）"><a href="#硬件（物理层）" class="headerlink" title="硬件（物理层）"></a>硬件（物理层）</h3><p>TCP/IP最底层是负责数据传输的硬件。这种硬件相当于以太网或电话线路等物理层的设备。关于它的内容一直无法统一定义。因为只要人们在物理层面上所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等有所不同，而在这些方面又没有一个既定的指标。</p>
<h3 id="网络接口层（数据链路层）"><a href="#网络接口层（数据链路层）" class="headerlink" title="网络接口层（数据链路层）"></a>网络接口层（数据链路层）</h3><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。也就是说把它当做让NIC起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。</p>
<p>有时人们也将网络接口层与硬件层合并起来称为网络通信层。</p>
<h3 id="互联网层（网络层）"><a href="#互联网层（网络层）" class="headerlink" title="互联网层（网络层）"></a>互联网层（网络层）</h3><p>互联网层使用IP协议，它相当于OSI参考模型中的网络层。IP协议是基于IP地址转发分包数据的。</p>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>TCP/IP的传输层有两个具有代表性（TCP、UDP）的协议，该层的功能与OSI参考模型中的传输层类似。</p>
<p>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的就是端口号（上面提到的程序地址）</p>
<h3 id="应用层（会话层及以上的分层）"><a href="#应用层（会话层及以上的分层）" class="headerlink" title="应用层（会话层及以上的分层）"></a>应用层（会话层及以上的分层）</h3><p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时候由一个单一的程序实现，有时也可能由多个程序实现。因此细看TCP/IP的应用层，它不仅实现OSI模型中的应用层内容，还要实现会话层与表示层的功能。</p>
<p>WWW：浏览器与服务端之间通信的协议用的是HTTP，所传输的数据格式主要是HTML。那么HTTP属于OSI应用层协议，HTML则属于表示层的协议。</p>
<p>FTP：在进行文件传输时会创建两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据所用到的数据连接，这两种连接的控制管理属于会话层的功能。</p>
<h2 id="TCP-IP分层模型与通信示例"><a href="#TCP-IP分层模型与通信示例" class="headerlink" title="TCP/IP分层模型与通信示例"></a>TCP/IP分层模型与通信示例</h2><p>假设甲给乙发送邮件，内容为：“早上好”，而从TCP/IP通信上看，是一台计算机A向另一台计算B发送电子邮件。</p>
<p>通这个例子理解一下通信过程。</p>
<p><img src="/uploads/tcp-ip/send-email.png" alt></p>
<ol>
<li>应用程序处理</li>
<li>TCP模块处理</li>
<li>IP模块处理</li>
<li>网络接口（以太网驱动）的处理</li>
</ol>
<h1 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h1><p>TCP/IP中对于OSI参考模型的数据链路层及以下部分（物理层）未作定义。因为TCP/IP以这两层的功能是透明的为前提，然后数据链路的知识对于深入理解TCP/IP与网络起着至关重要的作用。</p>
<h2 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h2><p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p>
<p>数据链路层的协议定义了通过通信媒介互连的设备之间传输规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等媒介。此外各个设备之间有时也会通过交换机（2层，3层，4-7层）、网桥、中继器等中转数据。</p>
<p>计算机是以0、1来表示信息，然而实际的通信媒介之间处理的却是电压的高低、光的闪灭以及电波的强弱。把这信号与二进制的0、1进行转换的正是物理层的责任。数据链路层处理的数据并不是单纯的0、1序列，该层把它们集合为一个叫做“帧”的块，然后进行传输。</p>
<p>数据链路也可以被视为网络传输中的最小单位。</p>
<p>连通全世界的互联网，不外乎是众多的数据链路组成的，因此互联网也被称为“数据链路的集合”。</p>
<h2 id="数据链路相关技术"><a href="#数据链路相关技术" class="headerlink" title="数据链路相关技术"></a>数据链路相关技术</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址用于识别数据链路层中互连的点。以太网或FDDI中，根据IEEE802.3的规范使用MAC地址。其他诸如无线LAN（IEEE802.11a/b/g/n等）、蓝牙设备中也是用相同规格的MAC地址。</p>
<p>MAC地址长48bit,在使用网卡（NIC）的情况下，MAC地址一般会被烧录入到ROM中。</p>
<p><img src="/uploads/tcp-ip/mac.png" alt></p>
<p>在全世界，MAC地址也并不是总是唯一的。这里与上面的“地址”有点冲突，但实际上，即使MAC地址相同，只要不是同属一个数据链路就不会出现问题（也就是一个数据链路内还是保持了唯一性）。</p>
<h3 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h3><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网分类"><a href="#以太网分类" class="headerlink" title="以太网分类"></a>以太网分类</h3><p>以太网因通信电缆的不同及通信速度的差异，衍生出了众多不同的以太网类型。</p>
<p><img src="/uploads/tcp-ip/enetwork.png" alt></p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p>以太网帧前端有一个叫做前导码的部分，它是由0、1数字交替组合而成，表示一个以太网帧的开始也是对端网卡能够确保与其同步的标识。</p>
<p><img src="/uploads/tcp-ip/preamble.png" alt></p>
<p>以太网帧的本体前端是以太网的首部，它总共14个字节，分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p>
<p><img src="/uploads/tcp-ip/enetwork-zhen.png" alt></p>
<p>紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是46-1500个字节，帧尾是一个叫做FCS（帧校验序列）的4个字节。如图，以太网帧与IEEE802.3帧头稍有区别。这里主要记录以太网的帧。</p>
<p>关于主要协议类型参考如下：<br><img src="/uploads/tcp-ip/enetwork-type.png" alt></p>
<h2 id="公共网络"><a href="#公共网络" class="headerlink" title="公共网络"></a>公共网络</h2><p>这里主要记录连接公共通信服务相关的细节。所谓的公共服务通信服务类似于电信运营商（如中国电信）提供的电话网络。人们通过与运营商签约、付费实现联网。</p>
<p>主要记录的两种种模拟电话线路（淘汰），ADSL。其实还有其它的移动通信、有线电视，FTTH，FTTB、专线、VPN。</p>
<p>FTTH 光纤到户 与 FTTB 光线到楼，现在也开始在逐渐覆盖。光纤具有寿命长,无干扰, 带宽几乎无限的优点,是铜线技术所无法比拟的。 </p>
<h3 id="模拟电话线路"><a href="#模拟电话线路" class="headerlink" title="模拟电话线路"></a>模拟电话线路</h3><blockquote>
<p>虽然淘汰了，但还是经历过这个时代，因此还是要讲讲</p>
</blockquote>
<p>模拟电话线路其实是利用固定电话线路进行通信。电话线中的音频带宽用于拨号上网。该方法不需要特殊的通信线路，完全使用已经普及的电话网。</p>
<p>让计算机与电话线相连需要有一个将数字信号转为模拟信号的调制解调器（俗称“猫”）。“猫”的传输速率一般只有56kbps左右，现在基本淘汰了。但是很怀旧所以再记录一下。</p>
<p><img src="/uploads/tcp-ip/mock-tel-link.png" alt></p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>ADSL是对已有的模拟电话线路进行扩展的一种服务，模拟电话线路虽然也能传输高频数字通信，但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率，并会对其他多余频率的信号进行丢弃。现在的电话网逐渐数字化，通过电话线路的信号再经过电信的交换机时会变成64kbps左右的数字信号。因此理论上无法传输比64kbps更块的数字信号。然后，每个话机到电信局交换机之前这段线路，是可以实现高速传输的。</p>
<p>ADSL正式利用了话机到电信局交换机之间的线路，附加了一个叫做分离器的装置，将音频信号（低频信号）和数字信号（高频信号)隔离以免产生噪声干扰。</p>
<p>ADSL中的线路速度根据通信方式或线路的质量以及距离电信局的远近有所不同。从ISP到家里/办公室的速率在1.5Mbps~50Mbps左右，而从家里/办公室到ISP端的速率一般在512kbps~2Mbps左右。</p>
<blockquote>
<p>这里的上下行传输速率不对称，是因为在铜芯电缆线年代，带宽小，且ADSL的宽带利用率下行高于上行，为了能在有限的贷带宽上提高下载速率，所以产生上下行不对称的制式，并且沿用至今。</p>
</blockquote>
<p><img src="/uploads/tcp-ip/adsl.png" alt></p>
<h1 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h1><p>TCP/IP的心脏就是互联网层（网络层），这一层主要由IP协议与ICMP协议两个协议组成。鉴于目前的IP已无法满足互联网的需求，于是出现了更高版本的IPv6。</p>
<h2 id="IP相当于OSI参考模型中第3层"><a href="#IP相当于OSI参考模型中第3层" class="headerlink" title="IP相当于OSI参考模型中第3层"></a>IP相当于OSI参考模型中第3层</h2><p>IP（IPv4、IPv6）相当于OSI参考模型中的第3层—-网络层。</p>
<p>网络层主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end)通信”</p>
<p>网络层的下一层是数据链路层，数据链路层的主要作用是互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p><img src="/uploads/tcp-ip/end-to-end.png" alt></p>
<h2 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h2><p>我们多次提到数据链路层中，是用MAC地址来识别同一链路不同计算机的。在网络层中，也由这种识别的地址信息，一般叫做IP地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在TCP/IP通信中所有的主机或路由器必须设定自己的IP地址。</p>
<p>在网桥与集线器等物理层或数据链路层数据包转发设备中，不需要设置IP地址。因为这些设备只负责将IP包转化为0、1比特流或对数据链路帧的数据部分进行转发，而不需要应对IP协议。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制（Routing)是指将分组数据发送最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。</p>
<p><img src="/uploads/tcp-ip/routing1.png" alt></p>
<h3 id="发送数据至最终目标地址"><a href="#发送数据至最终目标地址" class="headerlink" title="发送数据至最终目标地址"></a>发送数据至最终目标地址</h3><p>Hop 翻译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。</p>
<p><img src="/uploads/tcp-ip/hop-by-hop.png" alt></p>
<h3 id="路由控制表"><a href="#路由控制表" class="headerlink" title="路由控制表"></a>路由控制表</h3><p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由。IP包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/uploads/tcp-ip/luyoukongzhibiao.png" alt></p>
<h2 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h2><h3 id="IP地址定义"><a href="#IP地址定义" class="headerlink" title="IP地址定义"></a>IP地址定义</h3><p>IP地址(IPv4地址)由32位正整数来表示，TCP/IP通信要求将这样的IP地址分配给每一个参与通信的主机。IP地址在计算机内部以二进制方式被处理。然而，由于人类社会并不会习惯采用二进制方式，需要采用一种特殊的方式，那就是将32位IP地址以每8位为一组，分成四组。每组以“.”隔开。再每组数转换为十进制。</p>
<h2 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h2><p><img src="/uploads/tcp-ip/ip-header.png" alt></p>
<ul>
<li>版本</li>
</ul>
<p>由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也是“4”。</p>
<ul>
<li>首部长度</li>
</ul>
<p>由4个比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说当没有可选项时，IP首部的长度为20字节（4*5）</p>
<ul>
<li>区分服务（TOS）</li>
</ul>
<p>由8比特构成，用来表明服务质量。每一位的具体含义如表：</p>
<p><img src="/uploads/tcp-ip/tos.png" alt></p>
<p>tosz整个互联网几乎就没有投入使用。不过已有人提出将TOS字段分为DSCP和ECN两个字段的建议</p>
<p><img src="/uploads/tcp-ip/dscp-ecn.png" alt></p>
<p>DSCP(Different Service Codepoint,差分服务代码点)是TOS的一部分。现在统称为DiffServ，用来进行质量控制。</p>
<p>ECN（Explicit Congestion Notification，显式拥塞通告）用来报告网络拥堵情况，由两个比特构成。</p>
<p><img src="/uploads/tcp-ip/ecn.png" alt></p>
<p>第6位的ECT用以通告上层TCP协议是否处理ECN。当路由器在转发ECN为1的包的过程中，如果出现网络拥堵的情况，就将CE位设置为1.</p>
<ul>
<li>总长度</li>
</ul>
<p>表示IP首部与数据部分合起来的总字节数。该字段长 比特。因此IP包的最大长度为65535字节。目前还不存在能传输65535字节的数据链路。不过，由于有IP分片处理，从IP上一层的角度看，都可以认为能够以IP的最大包长度传输数据。</p>
<ul>
<li>标识（ID）</li>
</ul>
<p>由16比特构成，用于分片重组。同一个分片的标识值相同，不同分片的标识不同。通常每发一个IP包它的值逐渐递增。此外ID相同，如果目标地址、源地址或者协议不同的话，也会被认为是不同的分片。</p>
<ul>
<li>标志（Flag）</li>
</ul>
<p>由3个比特构成，表示包被分片的相关信息。每一位的具体含义如下</p>
<p><img src="/uploads/tcp-ip/ip-flag.png" alt></p>
<ul>
<li>片偏移（FO）</li>
</ul>
<p>由13位比特构成，用来标识被分片的每一个分段相对于原始数据的位置。</p>
<ul>
<li>生存时间（TTL)</li>
</ul>
<p>由8个比特组成，早期设计是想以秒为单位，现在是指可以经过多少个路由器的意思，每经过一个路由器TTL会减1，直到变成0则丢弃该包。</p>
<ul>
<li>协议</li>
</ul>
<p>由8个比特构成，表示IP首部的下一个首部隶属于哪个协议</p>
<ul>
<li>首部校验和</li>
</ul>
<p>由16个比特（2个字节）构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分。它主要用来确保IP数据报不被破坏。</p>
<ul>
<li>源地址</li>
</ul>
<p>由32比特（4字节）构成，表示发送端IP地址</p>
<ul>
<li>目标地址</li>
</ul>
<p>由32比特（4字节）构成，表示接收端IP地址</p>
<ul>
<li>可选项</li>
</ul>
<p>长度可变，通常只有在进行实验或诊断时使用</p>
<p>安全级别、源路径、路径记录、时间戳</p>
<ul>
<li>填充</li>
</ul>
<p>也称作填充物。在有可选项的情况下，首部的长度可能不是32比特的整数倍。为此，通过向字段填充0，调整为32比特</p>
<ul>
<li>数据</li>
</ul>
<p>存入数据。将IP层上层协议的首部也作为数据处理。</p>
<h2 id="显式拥塞通知"><a href="#显式拥塞通知" class="headerlink" title="显式拥塞通知"></a>显式拥塞通知</h2><p>当发生网络拥塞时，发送主机应该减少数据包的发送量。作为IP层上层协议，TCP虽然也能控制网络拥塞，不过它是通过数据包的损坏情况来判断是否发生拥塞。然后这种方法并不能在数据包损坏之前减少数据包的发送量。</p>
<p>为了解决这个问题，人们在IP层增加了一种使用显式拥塞通知的机制，即ECN。</p>
<p>ECN为了实现拥塞功能，将IP首部的TOS字段置换为ENC字段，并在TCP首部的保留位中追加CWR标识和ECE标志。</p>
<p>通知拥塞的时候，要将当前的拥塞情况传达给发送数据包的源地址主机。然后这个通知能不能发出也是一个问题，而且发出去了，如果遇到不支持拥塞控制协议的，那也就没什么实质意义。</p>
<p>因此ECN的机制概括起来就是发送包IP的首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生拥塞。拥塞检查在网络层进行，而且拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。</p>
<p><img src="/uploads/tcp-ip/yongsai.png" alt></p>
<h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><p>我们平常在访问某个网站的时候不使用IP地址，而是使用域名。能够这样做是因为DNS（Domain Name System)提供支持。DNS就是将域名转换具体的IP地址。</p>
<p>DNS如同互联网中的分布式数据库。DNS的传输层即同时支持TCP与UDP。端口一致为53。</p>
<h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p>域名由前缀和后缀组成，前缀是点前而的部分，例如baidu.com，前缀是baidu，而后缀是com，而前缀一般由注册者注册时自定义的。</p>
<p>提供英文字母（a-z，不区分大小写）、数字（0-9）、以及“ - ”（英文中的连词号，即中横线），不能使用空格及特殊字符(如!、$、&amp;、? 等),“ - ”不能用作开头和结尾，部分后缀支持前缀使用多语言。</p>
<p>例如，<a href="http://www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。" target="_blank" rel="noopener">www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。</a></p>
<p>直接调用网站的名字以后，DNS就会将便于人类使用的名字（如<a href="http://www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。" target="_blank" rel="noopener">www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。</a></p>
<p><img src="/uploads/tcp-ip/dns-domain.png" alt></p>
<h2 id="DNS查询机制"><a href="#DNS查询机制" class="headerlink" title="DNS查询机制"></a>DNS查询机制</h2><ol>
<li>查看浏览器内部缓存</li>
</ol>
<p>检测域名是否存在于浏览器缓存中，如果有缓存直接使用，没有则下一步。打开 chrome://net-internals/#dns 即可查看本机浏览器的 dns 缓存。</p>
<ol>
<li>系统缓存</li>
</ol>
<p>浏览器会调用一个类似 gethostbyname 的库函数，此函数会先去检测本地 hosts 文件，查看是否有对应 ip。<br>PS： 这里有一个点，localhost 默认 ip 是 172.0.0.1，这是一个回路段，也叫环回接口。也就是不会发往服务器，是直接在本地打开的。</p>
<ol>
<li>路由器缓存、ISP 缓存</li>
</ol>
<p>如果浏览器和系统缓存都没有，系统的 gethostname 函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。</p>
<ol>
<li>本地 DNS 服务器</li>
</ol>
<p>通常为自己计算机搭建的小型 DNS 服务器，自我使用，属于 DNS 优化的一部分。</p>
<blockquote>
<p>通常由运营商提供的，或者是自己设定的知名DNS解析服务器</p>
</blockquote>
<ol>
<li>域名服务器</li>
</ol>
<p>到此处的过程为：根域服务器（.） -&gt; 顶级域名服务器（eg: .com，.org）-&gt;<br>主域名服务器（eg: google.com）</p>
<h1 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h1><p>ARP译为地址解析协议，以目标主机IP地址为线索，查询其MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP协议只使用IPv4，不能用于IPv6。IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p>
<p>OSI模型有七层，TCP在第4层传输层，IP在第3层网络层，而ARP在第2层数据链路层。高层对低层是有强依赖的，所以TCP的建立前要进行ARP的请求和应答。</p>
<p>ARP高速缓存表在IP层使用。如果每次建立TCP连接都发送ARP请求，会降低效率，因此在主机、交换机、路由器上都会有ARP缓存表。建立TCP连接时先查询ARP缓存表，如果有效，直接读取ARP表项的内容进行第二层数据包的发送；只有表失效时才进行ARP请求和应答进行MAC地址的获取，以建立TCP连接。</p>
<p>下面是分组格式<br><img src="/uploads/tcp-ip/arp2.png" alt></p>
<h2 id="ARP的工作机制"><a href="#ARP的工作机制" class="headerlink" title="ARP的工作机制"></a>ARP的工作机制</h2><p>简单地说，ARP借助ARP请求和ARP响应两种类型的包确定MAC地址。</p>
<p>如果目的IP和自己在同一个网段：<br>当IP层的ARP高速缓存表中存在目的IP对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去<br>当IP层的ARP高速缓存表中不存在目的IP对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求目的IP的MAC，收到ARP应答之后，将应答之中的&lt;IP地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去</p>
<p>如果目的IP地址和自己不在同一个网段，就需要将包发送给默认网关，这需要知道默认网关的MAC地址：<br>当IP层的ARP高速缓存表中存在默认网关对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC<br>当IP层的ARP高速缓存表中不存在默认网关对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求默认网关的MAC，收到ARP应答之后，将应答之中的&lt;默认网关地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去。</p>
<h2 id="MAC地址与IP地址为何缺一不可"><a href="#MAC地址与IP地址为何缺一不可" class="headerlink" title="MAC地址与IP地址为何缺一不可"></a>MAC地址与IP地址为何缺一不可</h2><p>试想一下，假如不使用IP地址，而是通过MAC地址连接世界上所有计算机和节点的情况。仅仅凭一个MAC地址，人们无法知道这台机器所处位置（上面提到的MAC地址无高效寻址层次性），而且如果全世界的设备都用MAC地址相连，那么网桥在习得之前就得向全世界发送包，可想而知会造成多大得网络流量，而且又没有任何集约机制，网桥不得不维护一张巨大的表格来维护所学到的MAC地址，一旦超过了网桥所能承受的上限，网桥将无法正常工作。也就无法通信。</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>免费ARP指主机发送ARP查找自己的IP地址，通常发生在系统引导期间进行接口配置时。<br>与标准ARP的区别就是免费ARP分组的目的IP地址字段封装的是自己的IP地址，即向所在网络请求自己的MAC地址。</p>
<p>免费ARP的作用有：</p>
<ol>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的 IP地址。<br>正常情况下发送免费ARP请求不会收到ARP应答，如果收到了一个ARP应答，则说明网络中存在与本机相同的IP地址的主机，发生了地址冲突。</li>
<li>更新其他主机高速缓存中旧的硬件地址进行。<br>如果发送免费ARP的主机正好改变了硬件地址，如更换了接口卡。<br>其他主机接收到这个ARP请求的时候，发现自己的ARP高速缓存表中存在对应的IP地址，但是MAC地址不匹配，那么就需要利用接收的ARP请求来更新本地的ARP高速缓存表表项。</li>
<li>网关利用免费ARP防止ARP攻击<br>有些网关设备在一定的时间间隔内向网络主动发送免费ARP报文，让网络内的其他主机更新ARP表项中的网关MAC地址信息，以达到防止或缓解ARP攻击的效果。</li>
<li>利用免费ARP进行ARP攻击<br>ARP协议并不只在发送了ARP请求才接收ARP应答，计算机只要接收到ARP应答数据包，就会使用应答中的IP和MAC地址对本地的ARP缓存进行更新。<br>主机可以构造虚假的免费ARP应答，将ARP的源MAC地址设为错误的MAC地址，并把这个虚假的免费ARP应答发送到网络中，那么所有接收到这个免费ARP应答的主机都会更新本地ARP表项中相应IP地址对应的MAC地址。更新成功后，这些主机的数据报文就会被转发到错误的MAC地址，从而实现了ARP欺骗的攻击。</li>
</ol>
<h1 id="ICMP-互联网控制消息协议"><a href="#ICMP-互联网控制消息协议" class="headerlink" title="ICMP 互联网控制消息协议"></a>ICMP 互联网控制消息协议</h1><p>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能，就可以获得网络是否正常，设置是否正确以及设备有何异常的信息，从而方便网络上定位问题。</p>
<p>ICMP的消息大致分为两种类型：一类是通知出错原因的错误消息，一类是用于诊断的查询消息。</p>
<p><img src="/uploads/tcp-ip/icmp.png" alt></p>
<p>ICMP消息类型与对应消息内容<br><img src="/uploads/tcp-ip/icmp-type.png" alt></p>
<p>ICMP分组格式<br><img src="/uploads/tcp-ip/icmp-packet.jpg" alt></p>
<h2 id="ICMP实现之MTU探索"><a href="#ICMP实现之MTU探索" class="headerlink" title="ICMP实现之MTU探索"></a>ICMP实现之MTU探索</h2><p>所谓路径MTU 探索，是探索与通信对方之间不用分片IP 数据包，就能交流的MTU 大小的功能。MTU大小是指计算机一次能够送出去的数据的最大长度，基本上由网路的种类来决定。例如，以太网的话通常是1500 字节，使用PPPoE 的ADSL 通常是1492 字节。为了实现这个路径MTU 探索，ICMP 被使用着。沿着流程，具体看一下Windows 的MTU 探索的样子吧。</p>
<p><img src="/uploads/tcp-ip/icmp-mtu.jpg" alt></p>
<h1 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h1><p>如果逐一为每一台计算设置IP地址会是件非常繁琐的事情。特别是笔记本、智能终端、平板，每移动到一个地方，都要重新设置IP地址。于是，为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP。</p>
<p>DHCP，动态主机配置协议，前身是BOOTP协议，是一个局域网的网络协议，使用UDP协议工作，常用的2个端口：67(DHCP server),68(DHCP client)。DHCP通常被用于局域网环境，主要作用是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。</p>
<p><img src="/uploads/tcp-ip/dhcp.png" alt></p>
<h2 id="DHCP的工作机制"><a href="#DHCP的工作机制" class="headerlink" title="DHCP的工作机制"></a>DHCP的工作机制</h2><p>使用DHCP之前，首先要架设一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p>
<p><img src="/uploads/tcp-ip/dhcp-flow.png" alt></p>
<p>为了检查所要分配的IP地址以及已经分配了的IP地址可用，DHCP服务器或DHCP客户端必须具备下面功能：</p>
<ol>
<li>DHCP服务器：在分配IP地址前发送ICMP回送请求包，确认没有返回应答。</li>
<li>DHCP客户端：针对从DHCP服务端获得的IP地址发送ARP请求包，确认没有返回应答。</li>
</ol>
<h1 id="NAT-协议"><a href="#NAT-协议" class="headerlink" title="NAT 协议"></a>NAT 协议</h1><p>NAT（Network Address Translator)是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除了转换IP外，还出现了可以转换TCP、UDP端口号的NAPT技术，由此实现一个全局IP地址与多个主机的通信。</p>
<p>NAT（NAPT）实际上是为了面临地址枯竭的IPv4而开发的技术。</p>
<h2 id="NAT-工作机制"><a href="#NAT-工作机制" class="headerlink" title="NAT 工作机制"></a>NAT 工作机制</h2><p><img src="/uploads/tcp-ip/nat-flow.png" alt></p>
<p>如上图，以10.0.0.10的主机与163.221.120.9的主机进行通信为例。利用NAT，途中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37)再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址(202.244.174.37)先转换称私有IP10.0.0.10以后再转发。</p>
<p>在NAT（NAPT）路由器内部，有一张自动生成的用来转换地址的表。当10.0.0.10向163.221.120.9发送第一个包时就生成这张表，并按照这张表的映射关系处理。</p>
<p>当私有网络内的多台机器同时都要与外部通信时，仅仅转换IP地址，人们不免担心全局IP地址不够用。这时采用了包含端口号一起转换的方式（NAPT）解决这个问题。</p>
<p><img src="/uploads/tcp-ip/napt.png" alt></p>
<p>留意上图，同端口映射的端口+1。</p>
<p>在TCP的情况下，建立TCP连接首次握手时，SYN包一经发出，就会生成表。又随着收到的关闭连接时发出的FIN包的确认应答从表中删除。</p>
<h1 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h1><p>UDP是User Datagram Protocol的缩写。</p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p>
<p>即使出现网络拥堵的情况下，UDPy也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉也没有纠正功能，如果需要这些细节控制，不得不交由应用程序上去处理。</p>
<p>UDP处理简单又高效，因此也经常用于下面几个方面</p>
<ol>
<li>包总量较少的通信（DNS、SNMP）</li>
<li>视频、音频等多媒体资源（即时通信）</li>
<li>限定于LAN等特定网络的应用通信</li>
<li>广播通信（广播、多播）</li>
</ol>
<h2 id="UDP首部的格式"><a href="#UDP首部的格式" class="headerlink" title="UDP首部的格式"></a>UDP首部的格式</h2><p><img src="/uploads/tcp-ip/udp-header.png" alt></p>
<ul>
<li><p>源端口号<br>表示发送端端口号，字段长16位，该字段是可选项，有时可能不会设置源端口，没有源端口号的时候该字段设置为0，可用于不需要返回的通信中。</p>
</li>
<li><p>目标端口号<br>表示接收端端口，字段长16位</p>
</li>
<li><p>包长度<br>该字段保存了UDP首部的长度和数据的长度之和，单位为字节。</p>
</li>
<li><p>校验和<br>校验和是为了提供可靠的UDP首部和数据而设计，在计算校验和时，附加了UDP伪首部与UDP数据报之前。通过在最后一位增加一个“0”将全长增加16倍。此时将UDP首部的校验和字段设置为“0”。然后以16比特为单位进行1的补码和，并将所得到的1的补码和写入校验和字段。</p>
</li>
</ul>
<p><img src="/uploads/tcp-ip/udp-checksum.png" alt></p>
<p>接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，再进行校验和计算。校验和字段的指是校验和字段以外剩下部分的1的补码和。因此，包括校验和字段在内的所有数据之和结果为“16位全部为1”时，才会被认为所收到的数据是正确的。</p>
<p>UDP中也有可能不用校验和，校验和字段中填入0，这种情况不进行校验和校验，会降低处理的开销。</p>
<h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><p>与UDP区别较大，TCP作为一种面向有连接型的协议，只有在确认通信对端存在时候才会发送数据，从而可以控制通信流量的浪费。它充分实现了数据传输时各种控制，可以进行丢包重发，乱序控制。</p>
<p>我们知道IP协议是不可靠的，为了通过IP数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题，如果不解决这些，也无从谈起可靠传输。</p>
<p>TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><p>在TCP中，当发送端的数据到达接收端的时候，接收端主机会返回一个已收到的消息通知，这个消息叫做确认应答。</p>
<p><img src="/uploads/tcp-ip/tcp-ack1.png" alt></p>
<p>TCP通过肯定的确认应答（ACK）实现可靠的数据传输，当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p>
<p><img src="/uploads/tcp-ip/tcp-ack2.png" alt></p>
<p>在一定时间内没有等到确认应答，发送端可以认为数据已经丢失，并进行重发，由此，即使产生了丢包，仍然能够保证数据达到对端。实现可靠传输。</p>
<p>当然，未收到确认应答并不意味着数据一定丢失，也有可能数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也是会导致发送端没有收到确认应答，从而进行重新发送。</p>
<p><img src="/uploads/tcp-ip/tcp-ack3.png" alt></p>
<p>此外，也有可能因为一些其它的原因导致，确认应答延迟到达，在源主机重发数据以后才能到达的情况也屡见不鲜，此时，源发送主机只要按照机制重发数据即可。但对于目标主机来说，简直一种“灾难”，会反复收到相同的数据，因此就必须引入一种机制（重复控制），能够识别是否已经接收数据，又能判断是否需要接收。</p>
<p>上述这些确认应答处理、重发控制以及重复控制等功能可以通过序列号实现。序列号是按顺序给发送数据的每个一个字节标上号码的编号。这个编号的初始值并不是为0，而是在建立连接以后由随机数生成。接收端查询接收数据TCP首部中序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返回送回去。就这样通过序列号和确认应答，TCP可以实现可靠的传输。</p>
<p><img src="/uploads/tcp-ip/tcp-offset.png" alt></p>
<p>TCP的数据长度并未写入TCP首部，实际是通过IP首部中的数据包长度间接求得。</p>
<h2 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h2><p>重发超时是指在重发数据之前，等待确认应答到来的这个特定时间间隔。如果超过了这个时间仍未收到确认应答，则进行重发数据。</p>
<p>TCP要求不论在何种网络环境下都要提高高性能通信，并且无论网络拥堵情况发生何种变化，都要保持这个特性。为此，它在每次发包的时候都会计算往返时间及其偏差，将这个往返时间和偏差值相加重发超时的时间，就是比这个总和要稍微大一点。</p>
<p><img src="/uploads/tcp-ip/tcp-timeout.png" alt></p>
<p>在BSD的Unix以及Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过由于最初的数据包还不知道往返时间所以其重发超时一般设置为6秒。</p>
<p>数据被重发之后若是还是收不到应答，则进行再次重发，等待确认的应答时间将会2、4倍的指数函数延长。</p>
<p>此外，数据也不会被无限、反复地重发。达到一定的重发次数之后，如果仍没有确认应答返回，就判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行中止。</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>TCP是面向连接型的通信传输，面向连接是指在数据通信之前先好通信两端之间的准备工作。</p>
<p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答，如果对端发来确认应答，则认为可以进行数据通信，如果对端的确认应答未能到达，就不会进行数据通信。此外在通信结束时会进行断开连接的处理（FIN包）</p>
<p><img src="/uploads/tcp-ip/tcp-conn.png" alt></p>
<p>可以使用TCP首部用于控制的字段管理连接，一个连接与断开，正常过程至少需要来回发7个包才能完成。</p>
<h3 id="理解TCP三次握手-四次断开的必要性"><a href="#理解TCP三次握手-四次断开的必要性" class="headerlink" title="理解TCP三次握手/四次断开的必要性"></a>理解TCP三次握手/四次断开的必要性</h3><p><a href="https://www.cnblogs.com/qiaoconglovelife/p/5733056.html" target="_blank" rel="noopener">附文章出处</a></p>
<h4 id="三次握手的必要性"><a href="#三次握手的必要性" class="headerlink" title="三次握手的必要性"></a>三次握手的必要性</h4><p><img src="/uploads/tcp-ip/tcp-conn-3.png" alt></p>
<p>必要性：TCP通过三次握手建立可靠的（确保收到）的全双工通信</p>
<ol>
<li>第一次握手和第二次握手（ACK部分）建立了从客户端到服务器传送数据的可靠连接</li>
<li>第二次握手（SYN部分）和第三次握手建立了从服务器到客户端传送数据的可靠连接</li>
<li>由于我们期望建立全双工连接，所以两个方向的通信都是需要的，于是合并了服务器发送的ACK和SYN</li>
<li>第三次握手的必要性：防止已失效的请求报文段突然又传送到了服务端而造成连接的误判。假如客户端发出连接请求A，由于网络原因，服务端并没有收到A，于是客户端又发送了连接请求B，并建立了连接，完成通信，断开连接。这时候，服务端突然又收到了A，于是看作是一次新的连接请求，进行第二次握手，由于不存在第三次握手，所以这时已经建立了TCP连接。但实际上客户端并没有发起连接，所以不会传递数据，那么这条连接就会变成一条死连接</li>
</ol>
<h4 id="四次握手的必要性"><a href="#四次握手的必要性" class="headerlink" title="四次握手的必要性"></a>四次握手的必要性</h4><p><img src="/uploads/tcp-ip/tcp-conn-4.png" alt><br>必要性：为保证单向通信的可行性，所以多一次握手</p>
<ol>
<li>主动断开方发送FIN时，被动断开方要回复ACK，意思是“我收到你的FIN了”</li>
<li>主动断开方发送FIN并不意味着立即关闭TCP连接，而是告诉对方自己没有更多的数据要发送了，只有当对方发完自己的数据再发送FIN后，才意味着关闭TCP连接</li>
<li>被动断开方收到FIN并回复ACK后，此时TCP处于“半关闭”状态，为保证被动断开方可以继续发送数据，所以第二个FIN并不会伴随ACK发送，所以比连接时多一个报文段</li>
</ol>
<h2 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h2><p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS)，最理想的情况是，最大消息长度是IP中正好不会被分片处理的最大数据长度。</p>
<p>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发也是MSS为单位。</p>
<p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS大小。</p>
<p>为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍。在建立连接时，如果某一方忽略MSS选项，可以选为IP包的长度不超过576字节（MSS=576-IP20-TCP20=536）</p>
<p><img src="/uploads/tcp-ip/tcp-mss.png" alt></p>
<h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP以1个段为单位，每发一个段进行一次确认应答处理，这样的传输方式有一个缺点，那么就是包的往返时间越长通信性能越低。</p>
<p>为了解决这个问题，TCP引入了窗口的概念，即使在往返时间较长的情况下，它也能控制网络性能的下降。确认应答不再是以每个段进行确认，而是更大的单位进行确认，转发时间将会被大幅度的缩短。</p>
<p><img src="/uploads/tcp-ip/tcp-window.png" alt></p>
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。<br>这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p>
<p><img src="/uploads/tcp-ip/tcp-window2.png" alt></p>
<p>发送数据中高亮圈起来的部分正式前面提到的窗口，这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需要进行重发。为此发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。</p>
<p>在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端收到的数据。当数据发出后若如期收到确认应答就可以不用进行重发，此时数据就可以从缓冲区清除。</p>
<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也称滑动窗口控制。</p>
<h2 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h2><p>在使用窗口控制中，如果出现段丢失怎么办？</p>
<p>首先，我们先考虑确认应答未能返回的情况，这种情况下，数据已经达到了对端，是已经不需要进行重发的，然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发，而使用了窗口控制，某些确认应答即使丢失了也不需要重发数据。</p>
<p><img src="/uploads/tcp-ip/tcp-window-retry.png" alt></p>
<p>其次，我们来考虑一下某个报文段丢失的情况，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。不过即使接收端主机收到的包序号不连续，也不会将数据丢弃，而是暂存到缓冲区。</p>
<p><img src="/uploads/tcp-ip/tcp-window-retry2.png" alt></p>
<p>当某一个报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”，因此在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断的地返回，而发送端主机如果连续3次收到同一个确认应答，就会将其所丢应的数据进行重发，这种机制比之前的提高的超时管理更加高效，因此也被作高速重发控制。</p>
<p>之所以连续收到3次而不是两次的理由是因为，即使数据段序列号被替换两次也不会触发重发机制。</p>
<h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>TCP提供了一种机制可以让发送端根据接收端的实际接收能力发送数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收的数据大小，于是发送端会发送不超过这个限度的数据，该大小限度就被称作为窗口大小，是由接收端主机决定的。</p>
<p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机可以将自己可以接收的缓存区大小放入这个字段中通知发送端。这个字段的值越大，说明网络的吞吐量越高。</p>
<p>不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。</p>
<p><img src="/uploads/tcp-ip/tcp-stream-ctrl.png" alt></p>
<p>像上面这副图所示，当接收端收到从3001号开始的数据端后其缓冲区满了，不得不暂停停止接收数据，之后，在收到发送窗口更新通知后通信才得以继续，如果这个窗口更新通知中途丢失了，也不要紧，发送端定时会发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包，然而，如果在通信刚开始时就发送大量数据，也可能引发其他问题。</p>
<p>一般来说，计算网络都处于一个共享的环境，因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个叫大量的数据，极有可能会导致网络瘫痪。</p>
<p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>
<p><img src="/uploads/tcp-ip/tcp-yongsai.png" alt></p>
<p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念，于是在慢启动的时候，将这个拥塞窗口的大小设置为1MSS发送数据，之后没收到一个确认应答拥塞窗口增加1，在发送数据包时，将拥塞窗口的大小与接收端通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还要小的数据量。</p>
<p>随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生，为了防止这些，引入了慢启动阈值的概念，只要拥塞窗口的值超过这个阈值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口：</p>
<p><img src="/uploads/tcp-ip/tcp-yongsai-gongshi.png" alt></p>
<p><img src="/uploads/tcp-ip/tcp-yongsai2.png" alt></p>
<p>拥塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。因此，拥塞窗口的大小会呈直线上升的趋势。</p>
<p>TCP刚开始通信的时候，并没有设定相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口大小的一半。</p>
<p>由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为当时窗口大小的一半。然后将窗口的大小设置为该慢启动阈值+3个数据段的大小。</p>
<p>由于窗口的大小会直接影响数据被转发时的吞吐量，所以一般情况下，窗口越大，越会形成高吞吐量的通信。</p>
<h2 id="提高网络利用率的规范"><a href="#提高网络利用率的规范" class="headerlink" title="提高网络利用率的规范"></a>提高网络利用率的规范</h2><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>TCP中为了提高网络的利用率，经常使用一个叫做Nagle的算法。</p>
<p>该算法是指发送端即使还有应该发送的数据，但是如果这部分数据很少的话，则进行延迟发送的一种机制。仅在下面任意一种情况才能发送数据，如果两个条件都不满足，那么暂时等待一段时间以后再进行发送数据。</p>
<ol>
<li>已发送的数据都已经收到确认应答</li>
<li>可以发送的最大段长度已经达到MSS</li>
</ol>
<p>根据这个算法，可以提高网络利用率，但也会发生某种延迟，为此在窗口系统以及机械控制等领域中使用TCP往往会关闭对该算法的使用。</p>
<h3 id="延迟确认应答"><a href="#延迟确认应答" class="headerlink" title="延迟确认应答"></a>延迟确认应答</h3><p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。</p>
<p>当接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率（其实这是窗口控制特有的问题，叫糊涂窗口综合证），为此引入了一个方法，那就是收到数据以后并不立即确认响应，而是延迟一段时间的机制。</p>
<ol>
<li>在没有收到2MSS长度的数据为止不做确认应答（有得操作系统，只要收到两个包即刻返回确认应答）</li>
<li>其他情况下，最大延迟0.5秒发送确认应答。（很多操作系统设置为0.2秒左右）</li>
</ol>
<p>事实上，大可不必为每一个数据段都进行一次确认应答。TCP采用滑动窗口控制机制，因此通常确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。</p>
<p><img src="/uploads/tcp-ip/tcp-delay-reply.png" alt></p>
<h3 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h3><p>根据应用层协议，发送出去的消息到达对端，对端进行处理以后，会返回一个回执。例如，电子邮件协议的SMTP或POP、文件传输FTP中的连接控制部分等。这些应用协议使用同一个连接进行数据的交互。即使是使用WWW的HTTP，从1.1版本开始以后也是如此。</p>
<p>在此类通信中，TCP的确认应答和回执数据可以通过一个包发送，这种方式叫做捎带应答，通过这种机制，可以使收发处理减少一些。</p>
<p>另外，接收数据以后如果立刻确认应答，就无法实现捎带应答，而是将所接收的数据传给应用处理生成返回数据以后在进行发送请求为止，必须一直等待确认应答的发送。也就是说，没有启用延迟确认应答就无法实现捎带应答，延迟确认应答是能够提高网络利用率从而降低计算机处理负荷的一种优的处理机制。</p>
<p><img src="/uploads/tcp-ip/tcp-shaodai-ack.png" alt></p>
<h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><img src="/uploads/tcp-ip/tcp-header.png" alt></p>
<p>TCP中没有表示包长度和数据长度的字段，可由IP层获知TCP的包长度，由TCP包长获取可知数据的长度。</p>
<ul>
<li><p>源端口号<br>表示发送端的端口号，长度16bit</p>
</li>
<li><p>目标端口号<br>表示接收端端口号，长度16bit</p>
</li>
<li><p>序列号<br>字段长32位。序列号（有时也叫序号）是指发送数据的位置。序列号不会从0或1开始，而是再建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，然后每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p>
</li>
<li><p>确认应答号<br>确认应答号字段长度为32为，是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为这个序号以前的数据都已经被正常接收。</p>
</li>
<li><p>数据偏移<br>该字段表示TCP所传输的数据部分应该从TCP包哪个位开始算，当然也可以看作TCP首部的长度。该字段长4位，单位为4字节，不包括首选项字段的话，那么TCP首部为20字节长，因此数据偏移字段可以设置为5.</p>
</li>
<li><p>保留<br>该字段主要为了以后扩展使用，其长度为4位。一般设置为0。</p>
</li>
<li><p>控制位<br>字段长为8位。每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标识也叫做控制位。</p>
</li>
</ul>
<p><img src="/uploads/tcp-ip/tcp-control-flag.png" alt></p>
<ol>
<li>CWR<br> CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</li>
<li>ECE<br> ECE标志表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部ECN为1时，将TCP首部中的ECE设置为1.</li>
<li>URG<br> 该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理的数据，会在后面的紧急指针中在进行解释。</li>
<li>ACK<br> 该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。</li>
<li>PSH<br> 该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</li>
<li>RST<br> 该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发送连接请求，也无法进行通信，此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因，导致主机重启的情况，由于所有的连接信息将被全部初始化，所以原有的TCP通信将不能继续进行，这种情况下，如果通信对方发送一个RST设置为1的包，将会使通信强制断开连接。</li>
<li>SYN<br> 用于建立连接，SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的决定。</li>
<li>FIN<br> 该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方之间就可以相互交换FIN位置为1的包TCP段。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是，主机可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</li>
</ol>
<ul>
<li><p>窗口大小<br>该字段为16位，用于通知从相同TCP首部的确认应答号所指位置开始能够接收的字节大小。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p>
</li>
<li><p>校验和<br>TCP的校验和与UDP校验和相似，区别在于TCP的校验和无法关闭。</p>
</li>
</ul>
<p><strong>使用校验和的目的是什么？</strong></p>
<p>有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP也需要进行校验和？</p>
<p>其实相比检查噪声影响导致的错误，TCP与UDP的校验和更是一种进行路由器内存故障或者程序漏洞导致的数据是否被破坏的校验。</p>
<p>路由器的程序中也有可能存在漏洞，或程序异常宕掉的可能性。在互联网中发送数据包要经由好多个路由器，一旦在发送途中某一个路由器发生故障，经过此路由器的包、协议首部或者数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p>
<ul>
<li>紧急指针<br>该字段长为16位，只有在URG控制位为1时有效。该字段的数值表示本报文段中的紧急数据的指针。正确地讲，从数据部分的首位到紧急指针所指示的位置为止为紧急数据。因此也可以说紧急指针指出了紧急数据的末尾在报文段中的为止。</li>
</ul>
<p>如何处理紧急数据属于应用的问题，一般暂时中断通信，或中断通信的情况下使用。例如在Web浏览器中点击停止按钮，或者TELNET输入Ctrl+C时都会有URG为1的包。此外，紧急指针也用作表示数据流分段的标志。</p>
<ul>
<li>选项<br>选项字段用于提高TCP的传输性能。因为根据数据偏移（首部长度）进行控制，所以其长度最大为40字节。<br>另外选项字段尽量调整32位的整数倍。</li>
</ul>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>当用户在浏览器的地址里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务端的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p>
<p><img src="/uploads/tcp-ip/http1.png" alt><br><img src="/uploads/tcp-ip/http2.png" alt></p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>用于HTTP协议交互的信息被成为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端叫做响应报文。HTTP报文本身是由多行(CR+LF作换行符)的数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行(CR+LF)来划分。通常，并不一定要有报文主体。</p>
<p><img src="/uploads/tcp-ip/http-packet.png" alt></p>
<h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p>我们来看一下请求报文和响应报文的结构<br><img src="/uploads/tcp-ip/http-packet2.png" alt></p>
<p><img src="/uploads/tcp-ip/http-packet3.png" alt></p>
<p>请求行<br>包含用于请求的方法，请求URI和HTTP版本</p>
<p>状态行<br>包含表明响应结果的状态码，原因短语和HTTP版本</p>
<p>首部字段<br>包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：分别是：通用首部、请求首部、响应首部和实体首部</p>
<p>其他<br>可能包含HTTP的RFC里面未定义的首部（Cookie）</p>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP在传输数据时候可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求，但是，编码的操作需要计算机来完成，因此会消耗更多的CPU。</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文（message)</li>
</ul>
<p>是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</p>
<ul>
<li>实体（entry）</li>
</ul>
<p>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>
<p>通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>下面压缩与复原的流程<br><img src="/uploads/tcp-ip/http-encoder.png" alt></p>
<p>常用的内容编码：</p>
<ul>
<li>gzip (GNU zip）</li>
<li>compress （Unix系统的标准压缩）</li>
<li>deflate （zlib)</li>
<li>identity （不进行编码）</li>
</ul>
<h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够浏览器逐步显示页面。</p>
<p>这种把实体主体分块的功能成为分块传输(chunked transfer coding)</p>
<p><img src="/uploads/tcp-ip/http-chunked-transfer.png" alt></p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体。</p>
<p>HTTP/1.1中存在一种成为传输编码(transfer coding)的机制，它可以在通信技术按某种编码方式传输，但只定义作用于分块传输编码中。</p>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中采纳了多部分对象集合，发送的一份报文主，体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>
<p>多部分对象集合包含的对象如下</p>
<ul>
<li>multipart/form-data：在 Web 表单文件上传时使用</li>
<li>multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</li>
</ul>
<p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p>
<p><img src="/uploads/tcp-ip/http-range-request.png" alt></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p><img src="/uploads/tcp-ip/http-code-type.png" alt></p>
<h1 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h1><p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。</p>
<h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<h2 id="加密处理防止被窃听"><a href="#加密处理防止被窃听" class="headerlink" title="加密处理防止被窃听"></a>加密处理防止被窃听</h2><p>在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。</p>
<ul>
<li>通信的加密</li>
</ul>
<p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。</p>
<p>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。</p>
<p><img src="/uploads/tcp-ip/http-tongxin-s.png" alt></p>
<ul>
<li>内容的加密</li>
</ul>
<p>还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。</p>
<p>在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。</p>
<p><img src="/uploads/tcp-ip/http-content-s.png" alt></p>
<p>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。</p>
<h2 id="HTTP-加上加密处理和认证以及完整性保护后即是HTTPS"><a href="#HTTP-加上加密处理和认证以及完整性保护后即是HTTPS" class="headerlink" title="HTTP 加上加密处理和认证以及完整性保护后即是HTTPS"></a>HTTP 加上加密处理和认证以及完整性保护后即是HTTPS</h2><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。</p>
<p><img src="/uploads/tcp-ip/https-ssl.png" alt></p>
<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<h2 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h2><p>在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<ul>
<li>共享密钥加密的困境</li>
</ul>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。 (前面有提到)</p>
<p><img src="/uploads/tcp-ip/share-key.png" alt></p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<ul>
<li>使用两把密钥的公开密钥加密</li>
</ul>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p>
<p><img src="/uploads/tcp-ip/private-public-key.png" alt></p>
<ul>
<li>HTTPS采用混合加密机制</li>
</ul>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<p><img src="/uploads/tcp-ip/hunhe-jiami.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zpl">
          <p class="site-author-name" itemprop="name">Zpl</p>
           
              <p class="site-description motion-element" itemprop="description">随便记一下，顺便骚一下</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zpl</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
