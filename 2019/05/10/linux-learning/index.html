<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Zpl,Golang,TCP/IP,ElasticSearch,Redis,Mysql,OS,Life">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Unix的强大原因 Unix很简洁：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，unix仅仅提供几百个系统调用并且有一个非常明确的设计目的 Unix中，所有的东西都被当作文件对待。这种抽象使对数据和设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。 Unix的内核和相关的系统工具软件是用C语言编写而成，正式这个特">
<meta name="keywords" content="技术、生活、健身">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/05/10/linux-learning/index.html">
<meta property="og:site_name" content="程序员Zpl">
<meta property="og:description" content="Unix的强大原因 Unix很简洁：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，unix仅仅提供几百个系统调用并且有一个非常明确的设计目的 Unix中，所有的东西都被当作文件对待。这种抽象使对数据和设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。 Unix的内核和相关的系统工具软件是用C语言编写而成，正式这个特">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/uploads/linux/user-kernel-space.png">
<meta property="og:image" content="http://yoursite.com/uploads/linux/task_list.png">
<meta property="og:image" content="http://yoursite.com/uploads/linux/thread_info.png">
<meta property="og:image" content="http://yoursite.com/uploads/linux/process_state.png">
<meta property="og:updated_time" content="2019-05-30T06:19:07.836Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux学习笔记">
<meta name="twitter:description" content="Unix的强大原因 Unix很简洁：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，unix仅仅提供几百个系统调用并且有一个非常明确的设计目的 Unix中，所有的东西都被当作文件对待。这种抽象使对数据和设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。 Unix的内核和相关的系统工具软件是用C语言编写而成，正式这个特">
<meta name="twitter:image" content="http://yoursite.com/uploads/linux/user-kernel-space.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/10/linux-learning/">





  <title>Linux学习笔记 | 程序员Zpl</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Zpl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code and gym<br>做最强壮的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/linux-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T21:54:54+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Unix的强大原因"><a href="#Unix的强大原因" class="headerlink" title="Unix的强大原因"></a>Unix的强大原因</h1><ul>
<li>Unix很简洁：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，unix仅仅提供几百个系统调用并且有一个非常明确的设计目的</li>
<li>Unix中，所有的东西都被当作文件对待。这种抽象使对数据和设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。</li>
<li>Unix的内核和相关的系统工具软件是用C语言编写而成，正式这个特点使得Unix在硬件体系架构面前都具有龄人惊异移植能力。</li>
<li>Unix的进程创建非常迅速，并且有一个非常独特的fork()系统调用。最后Unix提供了一套非常简单但又很稳定的进程间通信元语，快速简洁的进程创建过程使Unix的程序把目标放在一次执行保质保量地完成一个任务上，而简单稳定的进程间通信机制又可以保证这些单一目的简单程序可以方便地组合在一起，去解决现实中变得越来越复杂的任务。正式由于这种策略和机制分离的设计理念，确保了Unix系统具备清晰的层次化结构。</li>
</ul>
<p>Unix已经发展为了一个支持抢占式多任务、多线程、虚拟内存、换页、动态链接和TCP/IP网络的现代化操作系统。</p>
<p>总结：</p>
<ol>
<li>Unix简洁，提供仅仅几百个系统调用并且每个非常明确的设计目的</li>
<li>Unix抽象能力好，所有东西都被当作文件对待，对数据对设备都是同一套系统调用接口：open()、read()、write()、lseek()和close()</li>
<li>UnixC语言编写，移植能力好</li>
<li>Unix进程创建迅速，还有一套简单好用的进程间通信元语</li>
</ol>
<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Linux是类Unix系统，但它不是Unix。需要说明的是，尽管Linux借鉴了Unix的许多设计并且实现了Unix的API，但Linux没有像其它Unix变种那样直接使用Unix的源代码。必要的时候，它的实现可能和其他的Unix的实现大相径庭，但它没有抛弃Unix的设计目标并且保证了应用程序编程接口的一致。</p>
<p>Linux用途广发，包括的东西也名目繁多。Linux系统的基础是内核、C库、工具集和系统的基本工具，如登陆程序和Shell。Linux系统也支持现代的X Windows系统，这样就可以使用完整的图形用户界面环境，如GNOME。可以在Linux上使用的商业和自由软件数以千计。</p>
<p>总结：</p>
<ol>
<li>Linux不是Unix，只是类Unix</li>
<li>Linux借鉴Unix的设计并实现了Unix的API</li>
</ol>
<h1 id="操作系统和内核简介"><a href="#操作系统和内核简介" class="headerlink" title="操作系统和内核简介"></a>操作系统和内核简介</h1><p>操作系统是指在整个系统中负责完成最基本功能和系统管理的那些部分。这些部分包括内核、设备驱动程序、启动引导程序、命令行SHELL或者其他种类的用户界面、基本的文件管理工具和系统工具。</p>
<p>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分如那件提供的服务，像管理硬件设备、分配系统资源等，内核有时候被称作是管理者或者是操作系统核心。</p>
<p>通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序组成。</p>
<p>对于提供保护机制的现代系统来说，内核独立于普通应用程序，它处于一个<strong>系统态</strong>，拥有受保护的内存空间和访问硬件设备的所有权限，这种系统态和被保护起来的内存空间，统称为<strong>内核空间</strong>。</p>
<p>相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有其他的一些使用限制。</p>
<p>当内核运行的时候，系统以内核态进入内核空间执行，而执行一个普通用户程序时，系统将以用户态进入以用户空间执行。</p>
<p>在系统中运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数再由库函数通过系统调用界面，让内核代其完成各种不同任务。不过也有一些库函数和系统调用就是一一对应的关系，比如，open()库函数除了调用open()系统调用之外，几乎什么都不做。</p>
<p>当一个应用程序执行一条系统调用，我们说内核正在代其执行。如果进一步解释，在这种情况下，应用程序被称为通过系统调用在内核空间执行，而内核被称为运行于进程上下文中。这种交互关系—应用程序通过系统调用界面陷入内核—是应用程序完成其工作的基本行为方式。</p>
<p>内核还要负责管理系统的硬件设备。现有的几乎所有的体系结构，包括全部Linux支持的体系结构，都提供了中断机制。当硬件设备想和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。中断通常对应着一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序相应和处理中断。</p>
<p>为了保证同步，内核可以停用中止—既可以停止所有的中断也可以有选择地停止某个中断号对应的中断。许多操作系统的中断服务程序，包括Linux的，都不在进程上下文中执行，它们在一个与所有进程都无关的、专门的中断上下文中运行。之所以存在这样的一个专门执行环境是为了<strong>保证中断服务程序能够第一时间响应和处理中断请求</strong>，然后快速地退出。</p>
<p>实际上我们可以将每个处理器在任何指定时间点上的活动必须概括为下列三者之一</p>
<ul>
<li>运行于用户空间，执行用户进程</li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行</li>
<li>运行于内核空间，处于中断上下文，<strong>与任何进程无关，处理某个特定的中断</strong></li>
</ul>
<p>即使是边边角角的情况也不例外，比如：当CPU空闲时，内核就会运行一个空进程，处于进程上下文，但运行于内核空间</p>
<p><img src="/uploads/linux/user-kernel-space.png" alt></p>
<p>总结:</p>
<ol>
<li>操作系统是指在整个系统负责完成基本功能和系统管理的部分，包括内核在里面。</li>
<li>内核是操作系统的核心，必须依靠内核提供服务，比如管理硬件设备、分配系统资源等</li>
<li>内核有时候被称作是管理者或者是操作系统核心。</li>
<li>内核通常中断服务程序、CPU处理调度程序、内存管理程序、网络、进程间通信等系统服务组成</li>
<li>内核独立于应用程序，拥有受保护的内存空间和访问硬件设备的权限，处于系统态，这种系统态和被保护的内存空间被统称为内核空间</li>
<li>应用程序在用户空间执行，只能看到允许使用部分系统资源不能直接访问硬件，不能访问内核划给别人的内存范围</li>
<li>内核运行时，系统以内核态进入内核空间执行，普通用户程序执行，系统将以用户态进入用户空间执行</li>
<li>处理器活动三种情况：运行于用户空间，执行用户进程、运行于内核空间，处于进程上下文、运行于内核空间，处于中断上下文</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文（总结）</a></li>
</ul>
<h1 id="Linux内核与传统Unix内核比较"><a href="#Linux内核与传统Unix内核比较" class="headerlink" title="Linux内核与传统Unix内核比较"></a>Linux内核与传统Unix内核比较</h1><ul>
<li>Linux支持动态加载内核模块。尽管Linux内核也是单内核，可是允许在需要的时候动态地卸载和加载部分内核代码</li>
<li>Linux支持对称多处理SMP机制。尽管许多Unix的变体也支持SMP，但传统的Unix并不支持这种机制</li>
<li>Linux内核可以抢占(preemptive)。与传统的Unix变体不同，Linux内核具有允许在内核运行的任务优先执行的能力。在其他各种Unix，只有Solaris和IRIX支持抢占。</li>
<li>Linux对线程支持的实现比较有意思：内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样，只不过是其中的一些共享资源而已。</li>
<li>Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统</li>
<li>Linux忽略了一些被设为时设计得很拙劣的Unix特性，像STREAMS，它还忽略了那些难以实现的过时标准</li>
<li>Linux体现了自由这个词的精髓。现有的Linux特性集就是Linux公开开发模型自由发展的结果</li>
</ul>
<h1 id="Linux-内核版本"><a href="#Linux-内核版本" class="headerlink" title="Linux 内核版本"></a>Linux 内核版本</h1><p>2.6.26.1</p>
<table>
<thead>
<tr>
<th>2</th>
<th>6</th>
<th>26</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>主版本号</td>
<td>从版本号</td>
<td>修订版本号</td>
<td>稳定版本号</td>
</tr>
</tbody>
</table>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>其中涉及进程的定义以及相关的概念，比如线程；然后再讨论Linux中如何管理每个进程。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程就是处于执行期的程序。但进程并不仅仅局限于一段可执行程序代码。通常进程还要其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或者多个执行线程，当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。</p>
<p>执行线程，简称线程，<strong>是在进程中活动的对象</strong>，每个线程都拥有一个独立的<strong>程序计数器、进程栈和一组进程寄存器</strong>。<strong>内核调度的对象是线程而不是进程</strong>。在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包括多个线程的多线程程序司空见惯。</p>
<p>Linux系统的线程实现非常特别：它对线程和进程并不特别区分。对Linux而言，线程只不过是一种特殊的进程罢了。</p>
<p>进程提供两种虚拟化机制：虚拟处理器和虚拟内存。虽然实际上可能是许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器，而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。有趣的是，在线程之间可以共享虚拟内存但每个都拥有自己的虚拟处理器。</p>
<p>程序本身不是进程，进程是处于执行期的程序以及相关的资源的总称。</p>
<h2 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h2><p>Linux是通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。</p>
<p>内核把进程的列表存放在叫做任务队列的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构。</p>
<p><img src="/uploads/linux/task_list.png" alt></p>
<p>在2.6以前的内核中给，各个进程的task_struct存放在它们内核栈的尾端。这样做视为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。</p>
<p>由于现在用slab分配器动态生成task_struct，所以只需在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个新的结构struct thread_info</p>
<p>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任务实际task_struct的指针。</p>
<p>总结：</p>
<ol>
<li>Linux通过slab分配器分配task_struct，以此达到对象复用和缓存着色</li>
<li>内核把进程的列表存放在任务队列的双向循环链表中。</li>
<li>任务队列中每一项的类型都是 task_struct，称为进程描述符的结构</li>
</ol>
<h2 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h2><p>内核通过一个唯一的进程标志值(process identification value)或PID来标识每个进程。PID是一个数，表示为pid_t隐含类型，实际上就是一个int类型。</p>
<p>为了与老版本的Unix和Linux兼容，PID最大默认为32768，这个值可以通过/proc/sys/kernel/pid_max修改提高上限，一般是够用。</p>
<p>这个最大值很重要，因为它实际表示系统中允许同时存在的进程的最大数目。</p>
<p>内核中大部分处理进程的代码都是直接通过task_struct进行的，因此，通过current宏查找到当前运行进程的进程描述符的速度就显得尤为重要。</p>
<p><img src="/uploads/linux/thread_info.png" alt></p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程描述符中的state域描述了进程的当前状态。系统中的每个进程都必然为下列物种状态标志之一：</p>
<ul>
<li>R ：TASK_RUNNING（运行状态）<br>进程是可执行的；它或者正在执行，或者在运行队列中等待执行。在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程<blockquote>
<p>一个进程最多只能出现在一个CPU的可执行队列中，进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行</p>
</blockquote>
</li>
<li>S ：TASK_INTERRUPTIBLE（可中断、可中断睡眠、睡眠状态）<br>进程正在睡眠（也就是说它被阻塞），等待某些条件（由外部中断触发、或由其他进程触发）的达成，一旦达成，内核就会把进程状态设置为运行。处于此状态的进程会因为接收到信号而提前被换星并随时准备投入运行<blockquote>
<p>比如等待socket连接、等待信号量</p>
</blockquote>
</li>
<li>D ：TASK_UNINTERRUPTIBLE（不可中断）<br>除了就算是接收到信号也不会被换醒或准备投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断状态使用得较少<blockquote>
<ol>
<li>不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</li>
<li>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</li>
</ol>
</blockquote>
</li>
<li>t ：__TASK_TRACED<br>被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪</li>
<li>T ：__TASK_STOPPED（停止）<br>进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号的时候，此外在调试期间接收到任何信号，都会进程进入这种状态。</li>
<li>Z(zombie)：僵死状态</li>
<li>X死亡状态(dead) ：只是⼀个返回状态，你不会在任务列表里看到这个状态</li>
</ul>
<p><img src="/uploads/linux/process_state.png" alt></p>
<h3 id="僵尸进程-Z-zombie"><a href="#僵尸进程-Z-zombie" class="headerlink" title="僵尸进程 Z(zombie)"></a>僵尸进程 Z(zombie)</h3><p>僵尸进程是处于僵死状态的进程（只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程便进入Z状态）</p>
<p>产生原因：<strong>子进程先于父进程退出</strong>，父进程（使用<strong>wait()系统调用</strong>）没有读取到子进程退出的返回代码，这时候子进程为了保存退出原因，因此进入僵死态不会释放所有资源。僵死进程会以终止状态保持在进程表中，并且会⼀直在等待父进程读取其退出状态代码。</p>
<p>危害：维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，假如⼀个父进程创建了很多子进程，但是不回收，就会造成内存资源的浪费，资源泄露。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>相对于僵尸进程，那么必须提到的就是孤儿进程，同僵尸进程相反，假如父进程先于子进程退出，子进程便进入后台运行，成为孤儿进程，孤儿进程随后会被1号init进程领养并回收，也就是将其父进程变为init进程。</p>
<p>在Linux中有两种特殊的进程： </p>
<p>进程0：Linux引导中创建的第一个进程，完成加载系统后，演变为进程调度、交换及存储管理进程。</p>
<p>进程1：init 进程，由0进程创建，完成系统的初始化。是系统中所有其它用户进程的祖先进程。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/sun_life_/article/details/88580785" target="_blank" rel="noopener">Linux 进程基本概念 什么是进程</a><br><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程[总结]</a></p>
<h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><p>可执行程序代码使进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。</p>
<p>一般程序在用户空间执行。当一个程序调执行了系统调用或者触发了某个异常，它就会陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。</p>
<p>除非在此间隙有更高优先级的进程需要执行并由调度器做出了响应调整，否则在内核还没有退出的时候，程序在用户空间会继续执行。</p>
<p>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行-对内核的所有访问都必须通过这些接口。</p>
<p>关于上下文更进程的解释：</p>
<ol>
<li>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</li>
<li>相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。<ul>
<li>用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
<li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
</ul>
</li>
</ol>
<p>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。</p>
<p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文（总结）</a></li>
</ul>
<h2 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h2><p><strong>Unix系统的进程之间存在一个明显的继承关系，Linux系统中也是如此。所有进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本(initscript)并执行其他的相关程序，最终完成系统启动的整个过程</strong>。</p>
<p>系统中的<strong>每个进程必有一个父进程</strong>，相应的，每个进程也可以拥有0个或者多个子进程。拥有<strong>同一个父进程的所有进程称为兄弟</strong>。进程间的关系存放在进程描述符中。每个task_struct都包含一个指向其父进程task_struct、叫做parent的指针，还包含一个称为children的子进程链表。</p>
<p>总结：</p>
<ol>
<li>所有进程是PID为1的进程的后代</li>
<li>每个进程都必须由一个父进程</li>
<li>同一个父进程的所有进程称为兄弟</li>
<li>进程描述符中有指向父进程的指针，还有一个指向子进程的链表</li>
</ol>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>Unix的进程创建很特别，许多其他的操作系统都提供产生(spawn)进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。</p>
<p>Unix采用不同的方式，首先fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID和某些资源和统计量（例如，挂起的信号，它没有必要继承）。exec()函数负责读取可执行文件并将其载入地址空间开始运行。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>写时复制技术最初产生于Unix系统，用于实现一种傻瓜式的进程创建：当发出fork()系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为是非常耗时的，因为它需要：</p>
<ul>
<li>为子进程的页表分配页面</li>
<li>为子进程的页分配页面</li>
<li>初始化子进程的页表</li>
<li>把父进程的页复制到子进程相应的页中</li>
</ul>
<p>创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破坏了高速缓存中的内容。</p>
<p>在大多数情况下，这样做常常是毫无意义的（fork()后立即调用exec()），因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。</p>
<p>现在的Unix内核（包括Linux），采用一种更为有效的方法称之为写时复制（或COW）。这种思想相当简单：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</p>
<p>总结：</p>
<ol>
<li>内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程，这种过于粗暴而且效率低下</li>
<li>写时拷贝(copy-on-write)核心思想就先与父进程共享拷贝页，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">Linux写时拷贝技术</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/4495479.html" target="_blank" rel="noopener">Linux进程管理——fork()和写时复制</a></li>
</ul>
<h3 id="fork-运行机制"><a href="#fork-运行机制" class="headerlink" title="fork() 运行机制"></a>fork() 运行机制</h3><p>Linux通过clone()系统调用实现fork()。这个调用通过一系列参数标志来指明父、子进程需要共享的资源。</p>
<p>fork()、vfork()、__clone()库函数都是根据各自需要的参数标志去调用clone(),然后由clone()去调用do_fork()</p>
<p>fork()、vfork()、__clone()-&gt;clone()-&gt;do_fork()</p>
<p>do_fork()该函数调用copy_process()函数，然后让进程开始运行。copy_process运行机制如下：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同</li>
<li>检查并确保创建这个子进程后，用户拥有的进程数目没有超过上限</li>
<li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员被置换为0或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。</li>
<li>子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行</li>
<li>copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0.表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置</li>
<li>调用alloc_pid()为新进程分配一个有效的PID</li>
<li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等，在一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针</li>
</ol>
<p>再回到do_fork()函数，如果copy_process函数成功返回，新创建的子进程被唤醒并让其投入运行。</p>
<p>内核有意选择子进程首先执行，因为一般子进程都回马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，由可能回开始向地址空间写入。</p>
<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。</p>
<p>相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）</p>
<p>Microsoft Windows或是Sun Solaris等操作系统的线程实现与Linux差异非常大。</p>
<p>假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包括指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这样的共享资源。线程本身再去描述它独占的资源。</p>
<p>相反在Linux仅仅创建四个进程并分配四个普通的task_struct结构。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<p>clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)</p>
<p>上面的代码缠身供得结果和调用fork()差不多，只是父子两共享地址空间、文件系统资源、文件描述符和信号处理程序。换个说法就是，新建的进程和它的父进程就是流行的所谓线程。</p>
<p>对比一下，一个普通的fork()的实现是：</p>
<p>clone(SIGCHILD,0)</p>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
<p>clone() 参数标志</p>
<table>
<thead>
<tr>
<th>参数标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLONE_FILES</td>
<td>父子进程共享打开的文件</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>父子进程共享文件系统的信息</td>
</tr>
<tr>
<td>CLONE_IDLETASK</td>
<td>将PID设置为0（只供idle进程使用)</td>
</tr>
<tr>
<td>CLONE_NEWS</td>
<td>为子进程创建新的命名空间</td>
</tr>
<tr>
<td>CLONE_PARENT</td>
<td>指定子进程与父进程拥有同一个父进程</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>继续调试子进程</td>
</tr>
<tr>
<td>CLONE_SETTID</td>
<td>将TID回写至用户空间</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>父子进程共享信号处理函数及被阻断的信号</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>父子进程共享System V SEM_UNDO 语义</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>父子进程放入相同的线程组</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>调用vfork()，所以父进程准备睡眠等待子进程将其唤醒</td>
</tr>
<tr>
<td>CLONE_UNTRACED</td>
<td>防止跟踪进程在子进程上强制执行CLONE_PTRACE</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>以TASK_STOPPED 状态开始进程</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_CHILD_CLEARTID</td>
<td>清楚子进程的TID</td>
</tr>
<tr>
<td>CLONE_CHILD_SETTID</td>
<td>设置子进程的TID</td>
</tr>
<tr>
<td>CLONE_PARENT_SETTID</td>
<td>设置父进程的TID</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>父子进程共享地址空间</td>
</tr>
</tbody>
</table>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成—独立运行在内核空间的标准进程。</p>
<p>内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p>
<p>Linux确实会把一些任务交给内核线程去做，像flush和ksofirqd这些任务就是明显的例子。运行 ps -ef 命令，可以看到很多内核线程。这些线程在系统启动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/alantu2018/p/8526916.html" target="_blank" rel="noopener">普通线程和内核线程</a></p>
<h2 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h2><p>进程终结时，内核必须释放它所占的所有资源</p>
<p>进程调用exit()会终结当前进程，可以显式调用，也可以隐式： c语言main函数结束时编译器会自动加入exit调用</p>
<p>exit是系统调用，对应内核里的sys_exit() -&gt; do_exit()</p>
<p>do_exit()，需要做下面这些琐屑的工作：</p>
<ol>
<li>设置标志位标记为退出：将task_struct中的标志成员设置为PF_EXITING</li>
<li>删除所有定时器：调用del_timer_sync()删除任一内核定时器，确保没有定时器再排队，也没有定时器处理程序的运行</li>
<li>有进程记账功能则输出记账信息：如果BSD的进程记账功能是开启的，do_exit()调用acct_update_intergrals()来输出记账信息</li>
<li>释放内存：调用exit_mm()函数释放级才能占用的mm_struct，如果没有别的进程使用它们（也就是没有被共享），就彻底释放它们</li>
<li>调用sem__exit()函数，如果进程排队等候IPC信号，它则离开队列</li>
<li>调用exit_files()和exit_fs，分别递减文件描述符、文件系统数据的引用计数。降至为零，表示没有进程在使用相应的资源，此时可以释放</li>
<li>接着存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作</li>
<li>调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态设为EXIT_ZOMBILE（存放在task_struct结构的exit_state中）</li>
<li>do_exit()调用schedule()切换到新的进程，因为处于EXIT_ZOMBILE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。</li>
</ol>
<p>至此进程的所有资源都被释放掉。并处于EXIT_ZOMBILE退出状态。它占用的所有内存就是内核栈、thread_info、task_struct结构。此时进程存在唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还给系统使用。</p>
<p>标志位设为退出-&gt;删除所有定时器-&gt;有进程记账则输出记账-&gt;释放内存-&gt;退出IPC等候队列-&gt;释放文件相关资源-&gt;设置exit_code-&gt;向父进程发送信号并进程状态设置为EXIT_ZOMBLIE-&gt;切换到新进程</p>
<p><strong>父进程在得知子进程终结时，有责任对该子进程使用wait系统调用</strong>。这个wait函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间（内核栈， thread_info, task_struct）</p>
<p>如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程,孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
<p>这里联系上面的进程状态一起看。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>在调用了do_exit()函数后，尽管线程已经僵死不能再运行，但系统保留它的进程描述符。</p>
<p><strong>进程终结时所需的清理工作和进程描述符的删除被分开执行</strong>。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才会被释放。</p>
<p>wait()这一族函数都是通过唯一的一个系统调用wait4()来实现的。它的标准动作就是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。</p>
<p>当最终需要释放进程描述符时，release_task()会被调用，运行机制以下：</p>
<ol>
<li>它调用__exit_signal()，改函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务队列中删除该进程</li>
<li>_exit_signal()释放目前僵死进程所使用的生于资源，并进行最终统计和记录</li>
<li>如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程</li>
<li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存</li>
</ol>
<p>至此，进程描述符和所有进程独享的资源就全部释放了</p>
<h3 id="孤儿进程造成的进退维谷"><a href="#孤儿进程造成的进退维谷" class="headerlink" title="孤儿进程造成的进退维谷"></a>孤儿进程造成的进退维谷</h3><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些称为孤儿的进程就会在退出时处于永远的僵死状态，白白的耗费内存。</p>
<p>解决方法就是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做他们的父进程。</p>
<p>在do_exit()中会调用exit_notify()，该函数会调用forget_original_parent()，而后者会调用find_new_reaper()来执行寻父。</p>
<p>一旦系统为进程成功地找到新的父亲进程，就不会再有出现主流僵死进程的危险了，init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>多任务系统可以划分为两大类：非抢占式多任务和抢占式多任务。</p>
<p><strong>Linux提供抢占式多任务模式</strong>，在此模式下，由调度程序来决定什么时候停止一个进程运行，以便其他进程能够得到执行机会。这个强制的挂其动作叫做：抢占。</p>
<p>进程运行的时间是预先设置好的，叫进程的时间片。时间片实际上就是分配给每个可运行进程的处理器时间段。</p>
<p>有效管理时间片能使调度程序从系统全局的角度做出调度决定，避免个别进程独占系统资源。</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="I-O消耗型和处理器消耗型的进程"><a href="#I-O消耗型和处理器消耗型的进程" class="headerlink" title="I/O消耗型和处理器消耗型的进程"></a>I/O消耗型和处理器消耗型的进程</h3><p>进程可以分为IO消耗型和处理器消耗型</p>
<p>调度策略通常要在这两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>调度算法中最基本的一类就是基于优先级的调度。</p>
<p>这是一种根据进程的价值和其对处理器时间的需求来对进程分级的想法。优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度。</p>
<p>Linux采用两种不同的优先级范围：</p>
<ul>
<li>第一种范围是nice值，它的范围是从-20到+19，默认值为0；越小优先级越高</li>
</ul>
<p>ps -el 命令查看系统中进程列表，NI一列就是进程对应的nice值。</p>
<ul>
<li>第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99（包括0和99），相反，越大优先级越高</li>
</ul>
<p>任何实时进程的优先级都高于普通的进程，通过命令 ps -eo state,uid,pid,ppid,rtprio,time,comm，其中列显示为”-“，则说明它不是实时进程。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值；</p>
<p>时间片越长会导致系统对交互的响应欠佳，时间片越短会明显增大进程切换带来的处理器消耗。</p>
<p>IO消耗型不需要长的时间片，而处理器消耗性的进程则希望越长越好（比如这样可以让它们的高速缓存命中率更高）</p>
<p>Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给进程。这一比例受nice值得影响，nice值高则进程赋予权重，nice值低则进程赋予高权重。</p>
<p>Linux系统是抢占式的，Linux使用的CFS调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前小，则新进程立刻投入运行，抢占当前进程，否则推迟其运行。</p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><p>Linux 调度器是以模块方式提供的，这样目的是允许不同类型的进程可以有针对性地选择调度算法。</p>
<p>这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有优先级，基础的调度器它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行哪个程序。</p>
<p>完全公平调度（CFS）是一个针对普通进程的调度类，在Linux中称为SCHED_NORMAL</p>
<p>在CFS算法引入之前，Linux使用过几种不同的调度算法，其中下面这两种比较出名：</p>
<ul>
<li>O(n)调度：在每次进程切换时，内核依次扫描就绪队列上的每一个进程，计算每个进程的优先级，再选择出优先级最高的进程来运行；尽管这个算法理解简单，但是它花费在选择优先级最高进程上的时间却不容忽视。系统中可运行的进程越多，花费的时间就越大，时间复杂度为O(n)</li>
<li>O(1)调度：其基本思想是根据进程的优先级进行调度。进程有两个优先级,一个是静态优先级,一个是动态优先级.静态优先级是用来计算进程运行的时间片长度的,动态优先级是在调度器进行调度时用到的,调度器每次都选取动态优先级最高的进程运行.由于其数据结构设计上采用了一个优先级数组，这样在选择最优进程时时间复杂度为O(1)，所以被称为O(1)调度</li>
</ul>
<p>这两种调度算法，其基本思路都是通过一系列运行指标确定进程的优先级，然后根据进程的优先级确定调度哪个进程，而CFS则转换了一种思路，它不计算优先级，而是通过计算进程消耗的CPU时间（标准化以后的虚拟CPU时间）来确定谁来调度。从而到达所谓的公平性</p>
<p>绝对公平性：</p>
<p>cfs定义了一种新的模型，其基本思路很简单，他把CPU当做一种资源，并记录下每一个进程对该资源使用的情况，在调度时，调度器总是选择消耗资源最少的进程来运行。这就是所谓的“完全公平”。但这种绝对的公平有时也是一种不公平，因为有些进程的工作比其他进程更重要，我们希望能按照权重来分配CPU资源。</p>
<p>相对公平性：</p>
<p>为了区别不同优先级的进程，就是会根据各个进程的权重分配运行时间(nice值)。进程的运行时间计算公式为：分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和；调度周期很好理解，就是将所处于TASK_RUNNING态进程都调度一遍的时间</p>
<p>举个例子来说明一下，比如系统中只两个进程A, B，权重分别为1和2，假设调度周期设为30ms，那么分配给A的CPU时间为:30ms <em> (1/(1+2)) = 10ms；而B的CPU时间为：30ms </em> (2/(1+2)) = 20ms。那么在这30ms中A将运行10ms，B将运行20ms</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><p>在实现层面，Linux通过引入virtual runtime(vruntime)来完成上面的设想，具体的,我们来看下从实际运行时间到vruntime的换算公式</p>
<p>vruntime = 实际运行时间*（NICE_0_LOAD/weight）</p>
<p>实际上vruntime就是根据权重将实际运行时间标准化，标准化之后，各个进程对资源的消耗情况就可以直接通过比较vruntime来知道，比如某个进程的vruntime比较小，我们就可以知道这个进程消耗CPU资源比较少，反之消耗CPU资源就比较多</p>
<p>有了vruntime的概念后，调度算法就非常简单了，谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。<br>或者可以这么理解：CFS的思想就是让每个调度实体（进程）的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间</p>
<p>Linux采用了一颗红黑树（对于多核调度，实际上每一个核有一个自己的红黑树），记录下每一个进程的vruntime，需要调度时，从红黑树中选取一个vruntime最小的进程出来运行</p>
<h3 id="新创建进程的vruntime是多少？"><a href="#新创建进程的vruntime是多少？" class="headerlink" title="新创建进程的vruntime是多少？"></a>新创建进程的vruntime是多少？</h3><p>假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内</p>
<p>创建子进程的具体流程如下：</p>
<ol>
<li>子进程在创建时，vruntime初值首先被设置为min_vruntime；</li>
<li>然后，如果sched_features中设置了START_DEBIT位，vruntime会在min_vruntime的基础上再增大一些。</li>
<li>设置完子进程的vruntime之后，检查sched_child_runs_first参数，如果为1的话，就比较父进程和子进程的vruntime，若是父进程的vruntime更小，就对换父、子进程的vruntime，这样就保证了子进程会在父进程之前运行。</li>
</ol>
<h3 id="休眠进程的vruntime一直保持不变吗？"><a href="#休眠进程的vruntime一直保持不变吗？" class="headerlink" title="休眠进程的vruntime一直保持不变吗？"></a>休眠进程的vruntime一直保持不变吗？</h3><p>如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多</p>
<h3 id="休眠进程在唤醒时会立刻抢占CPU吗？"><a href="#休眠进程在唤醒时会立刻抢占CPU吗？" class="headerlink" title="休眠进程在唤醒时会立刻抢占CPU吗？"></a>休眠进程在唤醒时会立刻抢占CPU吗？</h3><p>这是由CFS的唤醒抢占 特性决定的，即sched_features的WAKEUP_PREEMPT位。</p>
<p>由于休眠进程在唤醒时会获得vruntime的补偿，所以它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。除了交互式进程以外，主动休眠的进程同样也会在唤醒时获得补偿，例如通过调用sleep()、nanosleep()的方式，定时醒来完成特定任务，这类进程往往并不要求快速响应，但是CFS不会把它们与交互式进程区分开来，它们同样也会在每次唤醒时获得vruntime补偿，这有可能会导致其它更重要的应用进程被抢占，有损整体性能。</p>
<h3 id="进程占用的CPU时间片可以无穷小吗？"><a href="#进程占用的CPU时间片可以无穷小吗？" class="headerlink" title="进程占用的CPU时间片可以无穷小吗？"></a>进程占用的CPU时间片可以无穷小吗？</h3><p>参考：<br><a href="https://www.cnblogs.com/tianguiyu/articles/6091378.html" target="_blank" rel="noopener">linux内核分析——CFS（完全公平调度算法）</a><br><a href="https://www.jianshu.com/p/673c9e4817a8" target="_blank" rel="noopener">Linux的公平调度（CFS）原理</a></p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/10/redis-learning/" rel="next" title="Redis学习笔记">
                <i class="fa fa-chevron-left"></i> Redis学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/18/algorithm-structure-learning/" rel="prev" title="算法与数据结构基础学习笔记">
                算法与数据结构基础学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zpl">
          <p class="site-author-name" itemprop="name">Zpl</p>
           
              <p class="site-description motion-element" itemprop="description">随便记一下，顺便骚一下</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Unix的强大原因"><span class="nav-number">1.</span> <span class="nav-text">Unix的强大原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux简介"><span class="nav-number">2.</span> <span class="nav-text">Linux简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统和内核简介"><span class="nav-number">3.</span> <span class="nav-text">操作系统和内核简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux内核与传统Unix内核比较"><span class="nav-number">4.</span> <span class="nav-text">Linux内核与传统Unix内核比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-内核版本"><span class="nav-number">5.</span> <span class="nav-text">Linux 内核版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程管理"><span class="nav-number">6.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">6.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程描述符及任务结构"><span class="nav-number">6.2.</span> <span class="nav-text">进程描述符及任务结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程描述符的存放"><span class="nav-number">6.3.</span> <span class="nav-text">进程描述符的存放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态"><span class="nav-number">6.4.</span> <span class="nav-text">进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#僵尸进程-Z-zombie"><span class="nav-number">6.4.1.</span> <span class="nav-text">僵尸进程 Z(zombie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程"><span class="nav-number">6.4.2.</span> <span class="nav-text">孤儿进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程上下文"><span class="nav-number">6.5.</span> <span class="nav-text">进程上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程家族树"><span class="nav-number">6.6.</span> <span class="nav-text">进程家族树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程创建"><span class="nav-number">6.7.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写时拷贝"><span class="nav-number">6.7.1.</span> <span class="nav-text">写时拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-运行机制"><span class="nav-number">6.7.2.</span> <span class="nav-text">fork() 运行机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程在Linux中的实现"><span class="nav-number">6.8.</span> <span class="nav-text">线程在Linux中的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建线程"><span class="nav-number">6.8.1.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核线程"><span class="nav-number">6.8.2.</span> <span class="nav-text">内核线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程终结"><span class="nav-number">6.9.</span> <span class="nav-text">进程终结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#删除进程描述符"><span class="nav-number">6.9.1.</span> <span class="nav-text">删除进程描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程造成的进退维谷"><span class="nav-number">6.9.2.</span> <span class="nav-text">孤儿进程造成的进退维谷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程调度"><span class="nav-number">7.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#策略"><span class="nav-number">7.1.</span> <span class="nav-text">策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O消耗型和处理器消耗型的进程"><span class="nav-number">7.1.1.</span> <span class="nav-text">I/O消耗型和处理器消耗型的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程优先级"><span class="nav-number">7.1.2.</span> <span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片"><span class="nav-number">7.1.3.</span> <span class="nav-text">时间片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux调度算法"><span class="nav-number">7.2.</span> <span class="nav-text">Linux调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux调度的实现"><span class="nav-number">7.3.</span> <span class="nav-text">Linux调度的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新创建进程的vruntime是多少？"><span class="nav-number">7.3.1.</span> <span class="nav-text">新创建进程的vruntime是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#休眠进程的vruntime一直保持不变吗？"><span class="nav-number">7.3.2.</span> <span class="nav-text">休眠进程的vruntime一直保持不变吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#休眠进程在唤醒时会立刻抢占CPU吗？"><span class="nav-number">7.3.3.</span> <span class="nav-text">休眠进程在唤醒时会立刻抢占CPU吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程占用的CPU时间片可以无穷小吗？"><span class="nav-number">7.3.4.</span> <span class="nav-text">进程占用的CPU时间片可以无穷小吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信"><span class="nav-number">8.</span> <span class="nav-text">进程间通信</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zpl</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
