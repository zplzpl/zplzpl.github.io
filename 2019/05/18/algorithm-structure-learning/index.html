<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Zpl,Golang,TCP/IP,ElasticSearch,Redis,Mysql,OS,Life">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta name="keywords" content="技术、生活、健身">
<meta property="og:type" content="article">
<meta property="og:title" content="算法与数据结构基础学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/05/18/algorithm-structure-learning/index.html">
<meta property="og:site_name" content="程序员Zpl">
<meta property="og:description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/sort-table.jpg">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/xuanze.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/bubbleSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/insertionSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/shellSort.webp">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/insertionSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/quickSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/quickSort2.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/countingSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/radixSort.gif">
<meta property="og:updated_time" content="2019-05-20T07:45:29.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法与数据结构基础学习笔记">
<meta name="twitter:description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta name="twitter:image" content="http://yoursite.com/uploads/algorithm-structure-learning/sort-table.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">





  <title>算法与数据结构基础学习笔记 | 程序员Zpl</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Zpl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code and gym<br>做最强壮的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法与数据结构基础学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:33:38+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。</p>
<h2 id="重要的问题类型"><a href="#重要的问题类型" class="headerlink" title="重要的问题类型"></a>重要的问题类型</h2><p>计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。<br>最重要的问题类型如下：</p>
<ul>
<li>排序</li>
<li>查找</li>
<li>字符串处理</li>
<li>图问题</li>
<li>组合问题</li>
<li>几何问题</li>
<li>数值问题</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序问题要求我们按照升序重新排列给定列表中的数据项。</p>
<p>我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人的平均成绩来对学生记录进行排序，这段特别选定的信息成为键（key）</p>
<p>计算机科学家通常只关心如何对键进行排序，哪怕表中的元素不是记录，也许仅仅是整数。</p>
<p>到目前为止科学家已经开发出了几十种不同的排序算法。但没有一种算法再任何情况下都是最优的。<br>有些算法比较适合随机排列的输入，而另一些则更适合基本有序的列表。有些算法仅适合排列驻留再快速存储器中的列表。而另一些可以用来对存储再磁盘上的大型文件排序，如此等等。</p>
<p>排序算法有两个特性值得一提：</p>
<ul>
<li>如果一个排序算法保留了等值元素的输入中的相对位置，就可以说它是稳定的。</li>
<li>如果一个算法不需要额外的存储空间（除了个别存储单元以外），我们就说它是在位（in-place）</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找问题就是在给定的集合（或者是多重集，它允许多个元素具有相同的值）中找一个给定的值（我们称之为查找键）。</p>
<p>对于查找来说，也没有一种算法在任何情况下都是最优的。有些算法比其他算法速度快，但需要更多的存储空间。有些算法速度非常快，但仅使用于有序的数组。</p>
<p>和排序算法不同，查找算法没有稳定性问题。但会发生其他问题。查找问题就必须结合另外两种操作一起考虑，在数据集合中添加和删除元素的操作。</p>
<p>在这种情况下必须仔细选择数据结构和算法。以便在各种操作的需求之间达到一个平衡。而且对于高效查找（以及添加和删除）的特大型数据集合来说，如何组织其结构是一个不同寻常的挑战，而这对实际应用具有非常重要的意义。</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串是字符表中的符号所构成序列。我们尤其关心文本串，它是由字母、数字以及特殊符号构成的；位串是由“0”和“1”构成的；</p>
<p>如何在文本查找一个给定的词，这一特殊问题引起了研究人员的特别关注，它们成为字符串匹配问题。类似这种查找的特性，人们发明了好几种算法。</p>
<h2 id="图问题"><a href="#图问题" class="headerlink" title="图问题"></a>图问题</h2><p>TODO</p>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>TODO</p>
<h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p>TODO</p>
<h2 id="数值问题"><a href="#数值问题" class="headerlink" title="数值问题"></a>数值问题</h2><p>TODO</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>数据结构定义：对相关的数据项进行组织的特殊架构。</p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一维数组是n个相同数据类型的元素构成的序列，他们连续存储在计算机的存储器种，我们只要指定数组的下标就能够访问这些元素</p>
<p>无论位于数组的什么为止，都能用相等的常量时间访问数组中的任何元素。这种特性不是链表所具有的。</p>
<p>数组可以实现多种其他的数据结构，比较出名是<strong>字符串</strong>。字符串是来自于字母表的字符序列，并以一个特殊字符来标志字符串的结束。<br>字符串的常见操作不同于其他数组的典型操作。字符串的典型操作包括计算字符串的长度，按照字典序（即字母顺序）确定两个字符串在排序时的顺序。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是0个或多个成为节点的元素构成的序列，每个节点包含两类信息：一类是数据；另一类是一个或者多个成为指针的链接，指向链表中其他元素。</p>
<p>如果指向链表其他元素位null的时候表明节点没有后继元素。</p>
<p>单链表中，除了尾节点，每个节点都包含一个指向下一个元素的指针。</p>
<p>为了访问链表中的某个特定元素，我们从链表的首节点开始，沿指针链向前遍历，直到访问到该特定元素为止。因此和数组不同，访问单链表元素所需要的时间依赖于该元素在的链表中的位置。</p>
<p>优点：</p>
<ul>
<li>链表不需要实现分配任何存储空间</li>
<li>插入和删除的效率也非常高，只要相关的节点重新连接就可以了。</li>
</ul>
<p>为了增加链表灵活性，链表通常从一个称为表头的特殊节点开始，这个节点包含链表的长度，包含一个指向头元素的指针，还有可以包含指向尾元素的指针。</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>这是单向链表的扩展结构，其中除了首尾两个节点，每个节点都同时包含指向前趋的指针和指向后继的指针。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列也是一种列表，只是删除元素在列表的一头进行，这一头成为队头（出队），查入元素在表的另一头进行，这一头成为队尾（入队），因此，队列是按照“先进先出”(First-In-First-Out FIFO)的方式运转。</p>
<p>队列也有许多重要的而英勇，其中包括一些图问题的算法。</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>从一个动态改变的候选集合中选择一个优先级最高的元素。有一种数据结构可以满足，称为优先队列。</p>
<p>优先队列是数据项中的一个集合，这些数据项都来自于一些全序域。对优先队列的主要操作包括查找最大元素、删除最大元素和查入新的元素。</p>
<p>我们可以基于数组或者有序数组来实现优先队列，但这两种都不是最高效率的方案，优先队列有更好的实现方法，我们称之为堆(heap)</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种插入和删除操作都只能在端部进行的列表，这一端称为栈顶。</p>
<p>当我们在栈中添加一个元素或者删除一个元素时，该结构都按照一种“后进先出”（Last-In-First-Out LIFO)的方式运转。</p>
<p>栈的应用很广，对于实现递归算法来说时不可缺少的。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树，更精确地说，自由树就是连通无回路图。无回路但不一定连通的图成为森林。</p>
<p>树的边数总是比它的顶点数少1</p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>树的另外一个非常重要的特性就是：树的任意两个顶点之间总是恰好存在一条从一个顶点到另一个顶点的简单路径。这个性质使得以下做法成为可能：</p>
<p>任选自由树种的一个顶点，将它作为所谓的有根树的根。对有根树的描述中，根通常放在最顶上（树的第0层），邻接根的顶点放在根的下面，再下面是跟根距离两条边的顶点，然后以此类推。</p>
<p>有根树扮演很重要的角色，远比自由树重要，它们常常被简称为“树”。也就是说“树”通常是指有根树。</p>
<h4 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h4><p>有序树是一颗有根树，树中每个顶点的所有子女都是有序的。</p>
<h2 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h2><p>分析算法效率一般框架一般有两种：时间效率和空间效率</p>
<ul>
<li>时间雄安率指出算法的运行速度，空间效率涉及算法需要的额外空间。</li>
<li>算法的时间效率主要用它输入规模的函数来度量。该函数计算算法基本操作的执行次数。基本操作是总云心赶时间中工先最大的操作。通常它是算法的最内层循环中最费时的操作。</li>
<li>大多算法的效率可以分为以下几类：常数、对数、线性、线性对数、平方、立方和指数</li>
</ul>
<p>o(1)常数, o(n)线性, o(logn)对数, o(nlogn)线性对数</p>
<ul>
<li>比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。</li>
<li>再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。</li>
<li>再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</li>
<li>O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。</li>
<li>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961615&amp;idx=1&amp;sn=8711d52aa7bbd77db02eded67f6cc299&amp;chksm=bd2d0cd38a5a85c5e767e3be02fe885d0bcc95a9755d1e9b52971aac31b4fbca24227102a578&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我时间复杂度了 -  58沈剑  架构师之路</a></p>
<h1 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h1><p><img src="/uploads/algorithm-structure-learning/sort-table.jpg" alt></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序开始的时候，我们扫描整个列表，找到它最小元素，然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素中的最小元素，再和第二个元素交换位置，把第二小元素放在它的最终位置上。</p>
<p>一般来说，在对该列表进行第i遍扫描的时候，该算法在最后n-i个元素中寻找最小元素，然后拿它和Ai交换。</p>
<p>优点：</p>
<ul>
<li>不需要额外的存储空间</li>
<li>键的交换次数仅为O(n)，或者更精确点时n-1次。这个特性使得选择排序优于许多其他排序</li>
</ul>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 不稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/xuanze.gif" alt></p>
<h3 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(in); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[min] &gt; in[j] &#123;</span><br><span class="line">				min = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		in[i], in[min] = in[min], in[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它比较表中的相邻元素，如果它们是逆序的话，就交换它们的位置。重复多次以后，最终，最大的元素就“沉到”列表最后一个位置。第二遍操作将第二大的元素沉下去。这样一直做，直到n-1遍以后，该列表就排好序了。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/bubbleSort.gif" alt></p>
<h3 id="Golang实现-1"><a href="#Golang实现-1" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[j] &gt; in[j+<span class="number">1</span>] &#123;</span><br><span class="line">				in[j], in[j+<span class="number">1</span>] = in[j+<span class="number">1</span>], in[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>另外有一种扩展算法，是以发明者希尔命名-SHELL排序。此排序提供了一种更好的算法来对较大的文件进行排序。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-2"><a href="#Golang实现-2" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">		cur := in[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; in[j]; j-- &#123;</span><br><span class="line">			in[j+<span class="number">1</span>] = in[j]</span><br><span class="line">		&#125;</span><br><span class="line">		in[j+<span class="number">1</span>] = cur</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。</p>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/shellSort.webp" alt></p>
<h3 id="Golang实现-3"><a href="#Golang实现-3" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">	gap := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> gap &lt; length/<span class="number">3</span> &#123;  <span class="comment">// &lt;O(n^(3/2))</span></span><br><span class="line">		gap = gap*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; length; i++ &#123;</span><br><span class="line">			temp := arr[i]</span><br><span class="line">			j := i - gap</span><br><span class="line">			<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap &#123;</span><br><span class="line">				arr[j+gap] = arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+gap] = temp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并排序（归并排序）"><a href="#合并排序（归并排序）" class="headerlink" title="合并排序（归并排序）"></a>合并排序（归并排序）</h2><p>合并排序是成功应用分治技术的一个完美例子。对于一个需要排序的数组A[0..n-1]，合并排序把它一分为二：A[0..n/2-1]和A[n/2..n-1]，并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 稳定 |</p>
<p>exmpale:</p>
<p>Input:   {4, 1, 5, 8, 9, 3, 2, 6, 7}<br>Divide: {4, 1, 5, 8}, {9, 3, 2, 6, 7}<br>Divide: {4, 1}, {5, 8}, {9, 3}, {2, 6}, {7}<br>Divide: {4}, {1}, {5}, {8}, {9}, {3}, {2}, {6}, {7}</p>
<p>Merge: {1, 4}, {5, 8}, {3, 9}, {2, 6}, {7}<br>Merge: {1, 4, 5, 8}, {2, 3, 6, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 8, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 7 ,8, 9}</p>
<h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-4"><a href="#Golang实现-4" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(in []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> in</span><br><span class="line">	&#125;</span><br><span class="line">	mid := <span class="built_in">len</span>(in) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> merge(mergeSort(in[:mid]), mergeSort(in[mid:]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">			result[i] = left[<span class="number">0</span>]</span><br><span class="line">			left = left[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result[i] = right[<span class="number">0</span>]</span><br><span class="line">			right = right[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(left); j++ &#123;</span><br><span class="line">		result[i] = left[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(right); j++ &#123;</span><br><span class="line">		result[i] = right[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于分治思想的重要排序算法，不像合并排序是按照元素在数组中的位置对它们进行划分，快速排序按照元素的值对它们进行划分。划分是对给定数组中的元素的重新排列。使得A[s]左边的元素都小于等于A[s]，而所有A[s]右边的元素都大于等于A[s]；</p>
<p>显然，建立一个划分以后，A[s]已经位于它在有序数组中的最终位置，接下来我们可以继续对A[s]前和A[s]后的子数组分别进行排序。</p>
<p>注意它与合并排序不同之处在于：</p>
<ul>
<li>在合并排序算法中，将问题划分成两个子问题是很快的，算法的主要工作在于合并子问题的解；</li>
<li>而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并问题的解了。</li>
</ul>
<p>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p>它的最内层循环效率非常，使得在处理随机排列的数组时，速度要比合并排序快（对于堆排序也是如此。堆排序是另一种效率为nlogn的算法）。</p>
<p>人们对这个基本算法，进行了坚持不懈的改良，研究人员在这一领域的重要成果包括：</p>
<ul>
<li>更好的中轴选择方法：例如随即快速排序，它使用随机的元素作为中轴；三平分划分法，它以数组最左边、最右边和最中间的元素的中位数作为中轴。</li>
<li>当子数组足够小时（对于大多数计算机系统而言，元素数为5-15），改用插入排序方法，或者根本就不再对小数组进行排序，而是在快速排序结束后再使用插入排序的方法对整个近似有序的数组进行排序。</li>
<li>一些划分方法的挨近，例如三路划分，将数组分成三段，每段的元素分别小于、等于、大于中轴元素。</li>
</ul>
<p>根据国际上快速排序的权威塞奇威克的说法，如果同时应用这些改进措施，可以将该算法的运行时间削减20%-30%</p>
<p>但是与其他算法一样，快速排序算法也又缺点，它是不稳定的。同时它还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到O(logn)，但是它还是比堆排序O(1)的空间效率差。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 不稳定 |</p>
<h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/quickSort.gif" alt><br><img src="/uploads/algorithm-structure-learning/quickSort2.gif" alt></p>
<h3 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> _quickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		partition := partition(arr, left, right)</span><br><span class="line">		_quickSort(arr, left, partition<span class="number">-1</span>)</span><br><span class="line">		_quickSort(arr, partition+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	pivot := left</span><br><span class="line">	index := left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := index; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; arr[pivot] &#123;</span><br><span class="line">			arr[i], arr[index] = arr[index], arr[i]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[pivot], arr[index<span class="number">-1</span>] = arr[index<span class="number">-1</span>], arr[pivot]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 堆排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在一个标准的字典中可能会把“堆”定义成元素的无序堆积，但被称为“堆”的数据结构绝对不符合这个定义。我们更应该把它说成是一种灵巧的，部分有序的数据结构，它尤其使用用来实现优先级队列。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请回忆一下，优先队列是元素的一个集合，其中每个元素都包含一个被成为元素优先级的可排序属性。优先队列支持下面的：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 找出一个具有最高优先级的元素（即最大元素）</span></span><br><span class="line"><span class="string">* 删除一个具有最高优先级的元素</span></span><br><span class="line"><span class="string">* 添加一个元素到集合中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主要是由于这些操作的有效实现，使得堆既龄人感兴趣，又非常具有实用价值。在诸如操作系统的作页调度以及通信网络中流量管理等场景中，非常需要采用优先队列。并且优先队列也常常出现在一些重要的算法，例如Prim算法，Dijkstra算法，曼哈夫编码，还有在分支界限中的应用。堆排序是一种在理论上十分重要的排序算法，它的基础也依赖于堆这一数据结构。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span></span><br><span class="line"><span class="string">小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序的时间雄安率和合并排序的时间效率属于同一类，并且不同的是，堆排序是在位的，也就是说，它并不需要任何额外的存储空间。针对随机文件的计时实验指出，堆排序比快速排序运行得慢，但是和合并排序相比还是有竞争力的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">| 时间复杂度 |  O(nlogn) |</span></span><br><span class="line"><span class="string">| 稳定性 | 不稳定 |</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆可以定义为一颗二叉树，树的节点中包含键（每个节点一个键），并且树满足下面两个条件：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 树的形状要求---这个二叉树是基本完备的（或者简称完全二叉树），这意味着，树的每一层都是满的，除了最后一层最右边的元素可能缺位。</span></span><br><span class="line"><span class="string">1. 父母优势要求，又称为堆特性--每个节点的键都要大于或者等于它的子女的键（对于任何叶子我们认为这个条件都是自动满足的）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请注意，在堆中，键值是从上到下排序的。也就是说，在任何从根到某个叶子的路径上，键值的序列是递减的（如果允许相等键的存在，则是非递增的）。然而，键值之间并不存在从左到右的次序。也就是说，在树的同一层的节点之间，不存在任何关系，更一般地说，在同一节点的左右子树之间也没有任何关系。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面列出堆的重要特性，这些特性都是不难证明的：</span></span><br><span class="line"><span class="string">1. 只存在一颗n个节点的完全二叉树，它的高度等于log2n</span></span><br><span class="line"><span class="string">1. 堆的根总是包含了堆的最大元素</span></span><br><span class="line"><span class="string">1. 堆的一个节点以及该节点的子孙也是一个堆</span></span><br><span class="line"><span class="string">1. 可以用数组来实现堆，方法是用从上到下、从左到右的方式来记录堆的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">虽然大多数处理堆的算法来说，把堆想象成二叉树可以容易地理解它们所隐含的思想，但对于实际实现来说，使用数组会简单得多，效率也高得多。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在数组中，对于一个位于父母位置i(1&lt;=i&lt;=n/2)的键来说，它的子女将会在2i和2i+1，相应地，对于位于i(2&lt;=i&lt;=n)的键来说，它的父母将会在i/2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 动画演示</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort2.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort3.gif)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Golang实现</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	heapify(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">		siftDown(arr, <span class="number">0</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (<span class="built_in">len</span>(arr) - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(heap []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; heap[child] &gt; heap[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> heap[root] &gt; heap[child] &#123;</span><br><span class="line">			heap[root], heap[child] = heap[child], heap[root]</span><br><span class="line">			root = child</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>敲重点</p>
<ul>
<li>这是个线性时间复杂度的算法</li>
<li>不是通过比较的方式</li>
<li>必须有明确的范围</li>
<li>数据规模不能太大，因为需要额外开辟数组空间</li>
</ul>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/countingSort.gif" alt></p>
<h3 id="Golang实现-5"><a href="#Golang实现-5" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="keyword">int</span>, maxValue <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bucketLen := maxValue + <span class="number">1</span></span><br><span class="line">	bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, bucketLen)</span><br><span class="line"></span><br><span class="line">	sortedIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		bucket[arr[i]] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketLen; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> bucket[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			arr[sortedIndex] = i</span><br><span class="line">			sortedIndex += <span class="number">1</span></span><br><span class="line">			bucket[i] -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p>
<p>桶排序的基本思想：</p>
<p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p>
<p>桶排序的适用范围是，待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间。</p>
<h3 id="Golang实现-6"><a href="#Golang实现-6" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(array []<span class="keyword">int</span>, bucketSize <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> max, min <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nBuckets := <span class="keyword">int</span>(max-min)/bucketSize + <span class="number">1</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, nBuckets)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nBuckets; i++ &#123;</span><br><span class="line">		buckets[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		idx := <span class="keyword">int</span>(n-min) / bucketSize</span><br><span class="line">		buckets[idx] = <span class="built_in">append</span>(buckets[idx], n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sorted := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bucket) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			insertionSort(bucket)</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, bucket...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p>
<p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p>
<p>基数排序适用于：</p>
<ol>
<li>数据范围较小，建议在小于1000</li>
<li><p>每个数值都要大于等于0</p>
<p>算法描述</p>
</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h3 id="LSD动画演示"><a href="#LSD动画演示" class="headerlink" title="LSD动画演示"></a>LSD动画演示</h3><p><img src="/uploads/algorithm-structure-learning/radixSort.gif" alt></p>
<h3 id="Golang实现-7"><a href="#Golang实现-7" class="headerlink" title="Golang实现"></a>Golang实现</h3><blockquote>
<p>这里bucket扩展为两倍支持负数加入排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[<span class="number">0</span>])))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		v := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[i])))</span><br><span class="line">		<span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxDigit := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> max/<span class="number">10</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">		maxDigit++</span><br><span class="line">		max = max / <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> dev, j := <span class="number">1</span>, <span class="number">0</span>; j &lt; maxDigit; j++ &#123;</span><br><span class="line"></span><br><span class="line">		buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">			idx := (arr[i]/dev)%<span class="number">10</span> + <span class="number">10</span></span><br><span class="line">			buckets[idx] = <span class="built_in">append</span>(buckets[idx], arr[i])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">				arr[pos] = v</span><br><span class="line">				pos++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev = dev * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.bookstack.cn/read/JS-Sorting-Algorithm" target="_blank" rel="noopener">十大经典排序算法</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/10/linux-learning/" rel="next" title="Linux学习笔记">
                <i class="fa fa-chevron-left"></i> Linux学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zpl">
          <p class="site-author-name" itemprop="name">Zpl</p>
           
              <p class="site-description motion-element" itemprop="description">随便记一下，顺便骚一下</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要的问题类型"><span class="nav-number">1.1.</span> <span class="nav-text">重要的问题类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">1.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">1.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串处理"><span class="nav-number">1.4.</span> <span class="nav-text">字符串处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图问题"><span class="nav-number">1.5.</span> <span class="nav-text">图问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合问题"><span class="nav-number">1.6.</span> <span class="nav-text">组合问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几何问题"><span class="nav-number">1.7.</span> <span class="nav-text">几何问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值问题"><span class="nav-number">1.8.</span> <span class="nav-text">数值问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.9.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性数据结构"><span class="nav-number">1.9.1.</span> <span class="nav-text">线性数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#双向链表"><span class="nav-number">1.9.1.2.1.</span> <span class="nav-text">双向链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优先队列"><span class="nav-number">1.9.1.3.1.</span> <span class="nav-text">优先队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">1.9.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有根树"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">有根树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序树"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">有序树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法效率分析基础"><span class="nav-number">1.10.</span> <span class="nav-text">算法效率分析基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序-1"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">2.1.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示"><span class="nav-number">2.1.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现"><span class="nav-number">2.1.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">2.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动画演示"><span class="nav-number">2.4.1.</span> <span class="nav-text">动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并排序（归并排序）"><span class="nav-number">2.5.</span> <span class="nav-text">合并排序（归并排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">2.6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-4"><span class="nav-number">2.6.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-实现"><span class="nav-number">2.6.2.</span> <span class="nav-text">Golang 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-number">2.7.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动画演示-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-5"><span class="nav-number">2.7.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">2.8.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-6"><span class="nav-number">2.8.1.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">2.9.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LSD动画演示"><span class="nav-number">2.9.1.</span> <span class="nav-text">LSD动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-7"><span class="nav-number">2.9.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表-1"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zpl</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
