<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Zpl,Golang,TCP/IP,ElasticSearch,Redis,Mysql,OS,Life">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta name="keywords" content="技术、生活、健身">
<meta property="og:type" content="article">
<meta property="og:title" content="算法与数据结构基础学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/05/18/algorithm-structure-learning/index.html">
<meta property="og:site_name" content="程序员Zpl">
<meta property="og:description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/sort-table.jpg">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/xuanze.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/bubbleSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/insertionSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/shellSort.webp">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/insertionSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/quickSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/quickSort2.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/countingSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/radixSort.gif">
<meta property="og:image" content="http://yoursite.com/uploads/algorithm-structure-learning/bsearcht.png">
<meta property="og:updated_time" content="2019-05-24T14:03:17.345Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法与数据结构基础学习笔记">
<meta name="twitter:description" content="基础知识“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。 重要的问题类型计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。最重要的问题类型如下：  排序 查找 字符串处理 图问题 组合问题 几何问题 数值问题  排序排序问题要求我们按照升序重新排列给定列表中的数据项。 我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人">
<meta name="twitter:image" content="http://yoursite.com/uploads/algorithm-structure-learning/sort-table.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">





  <title>算法与数据结构基础学习笔记 | 程序员Zpl</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Zpl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code and gym<br>做最强壮的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/algorithm-structure-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zpl">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Zpl">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法与数据结构基础学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:33:38+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>“算法”是在有限的时间内，对问题求解的一个清洗的指令序列。算法的每个输入确定了该算法求解问题的一个实例。</p>
<h2 id="重要的问题类型"><a href="#重要的问题类型" class="headerlink" title="重要的问题类型"></a>重要的问题类型</h2><p>计算中能遇到无数问题，只有少数领域的问题引起了研究人员的特殊关注。<br>最重要的问题类型如下：</p>
<ul>
<li>排序</li>
<li>查找</li>
<li>字符串处理</li>
<li>图问题</li>
<li>组合问题</li>
<li>几何问题</li>
<li>数值问题</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序问题要求我们按照升序重新排列给定列表中的数据项。</p>
<p>我们可以按照学生姓名的字母顺序，也可以按照学号或者学生个人的平均成绩来对学生记录进行排序，这段特别选定的信息成为键（key）</p>
<p>计算机科学家通常只关心如何对键进行排序，哪怕表中的元素不是记录，也许仅仅是整数。</p>
<p>到目前为止科学家已经开发出了几十种不同的排序算法。但没有一种算法再任何情况下都是最优的。<br>有些算法比较适合随机排列的输入，而另一些则更适合基本有序的列表。有些算法仅适合排列驻留再快速存储器中的列表。而另一些可以用来对存储再磁盘上的大型文件排序，如此等等。</p>
<p>排序算法有两个特性值得一提：</p>
<ul>
<li>如果一个排序算法保留了等值元素的输入中的相对位置，就可以说它是稳定的。</li>
<li>如果一个算法不需要额外的存储空间（除了个别存储单元以外），我们就说它是在位（in-place）</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找问题就是在给定的集合（或者是多重集，它允许多个元素具有相同的值）中找一个给定的值（我们称之为查找键）。</p>
<p>对于查找来说，也没有一种算法在任何情况下都是最优的。有些算法比其他算法速度快，但需要更多的存储空间。有些算法速度非常快，但仅使用于有序的数组。</p>
<p>和排序算法不同，查找算法没有稳定性问题。但会发生其他问题。查找问题就必须结合另外两种操作一起考虑，在数据集合中添加和删除元素的操作。</p>
<p>在这种情况下必须仔细选择数据结构和算法。以便在各种操作的需求之间达到一个平衡。而且对于高效查找（以及添加和删除）的特大型数据集合来说，如何组织其结构是一个不同寻常的挑战，而这对实际应用具有非常重要的意义。</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串是字符表中的符号所构成序列。我们尤其关心文本串，它是由字母、数字以及特殊符号构成的；位串是由“0”和“1”构成的；</p>
<p>如何在文本查找一个给定的词，这一特殊问题引起了研究人员的特别关注，它们成为字符串匹配问题。类似这种查找的特性，人们发明了好几种算法。</p>
<h2 id="图问题"><a href="#图问题" class="headerlink" title="图问题"></a>图问题</h2><p>TODO</p>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>TODO</p>
<h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p>TODO</p>
<h2 id="数值问题"><a href="#数值问题" class="headerlink" title="数值问题"></a>数值问题</h2><p>TODO</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>数据结构定义：对相关的数据项进行组织的特殊架构。</p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一维数组是n个相同数据类型的元素构成的序列，他们连续存储在计算机的存储器种，我们只要指定数组的下标就能够访问这些元素</p>
<p>无论位于数组的什么为止，都能用相等的常量时间访问数组中的任何元素。这种特性不是链表所具有的。</p>
<p>数组可以实现多种其他的数据结构，比较出名是<strong>字符串</strong>。字符串是来自于字母表的字符序列，并以一个特殊字符来标志字符串的结束。<br>字符串的常见操作不同于其他数组的典型操作。字符串的典型操作包括计算字符串的长度，按照字典序（即字母顺序）确定两个字符串在排序时的顺序。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表是0个或多个成为节点的元素构成的序列，每个节点包含两类信息：一类是数据；另一类是一个或者多个成为指针的链接，指向链表中其他元素。</p>
<p>如果指向链表其他元素位null的时候表明节点没有后继元素。</p>
<p>单链表中，除了尾节点，每个节点都包含一个指向下一个元素的指针。</p>
<p>为了访问链表中的某个特定元素，我们从链表的首节点开始，沿指针链向前遍历，直到访问到该特定元素为止。因此和数组不同，访问单链表元素所需要的时间依赖于该元素在的链表中的位置。</p>
<p>优点：</p>
<ul>
<li>链表不需要实现分配任何存储空间</li>
<li>插入和删除的效率也非常高，只要相关的节点重新连接就可以了。</li>
</ul>
<p>为了增加链表灵活性，链表通常从一个称为表头的特殊节点开始，这个节点包含链表的长度，包含一个指向头元素的指针，还有可以包含指向尾元素的指针。</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>这是单向链表的扩展结构，其中除了首尾两个节点，每个节点都同时包含指向前趋的指针和指向后继的指针。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列也是一种列表，只是删除元素在列表的一头进行，这一头成为队头（出队），查入元素在表的另一头进行，这一头成为队尾（入队），因此，队列是按照“先进先出”(First-In-First-Out FIFO)的方式运转。</p>
<p>队列也有许多重要的而英勇，其中包括一些图问题的算法。</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>从一个动态改变的候选集合中选择一个优先级最高的元素。有一种数据结构可以满足，称为优先队列。</p>
<p>优先队列是数据项中的一个集合，这些数据项都来自于一些全序域。对优先队列的主要操作包括查找最大元素、删除最大元素和查入新的元素。</p>
<p>我们可以基于数组或者有序数组来实现优先队列，但这两种都不是最高效率的方案，优先队列有更好的实现方法，我们称之为堆(heap)</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种插入和删除操作都只能在端部进行的列表，这一端称为栈顶。</p>
<p>当我们在栈中添加一个元素或者删除一个元素时，该结构都按照一种“后进先出”（Last-In-First-Out LIFO)的方式运转。</p>
<p>栈的应用很广，对于实现递归算法来说时不可缺少的。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树，更精确地说，自由树就是连通无回路图。无回路但不一定连通的图成为森林。</p>
<p>树的边数总是比它的顶点数少1</p>
<h4 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h4><p>树的另外一个非常重要的特性就是：树的任意两个顶点之间总是恰好存在一条从一个顶点到另一个顶点的简单路径。这个性质使得以下做法成为可能：</p>
<p>任选自由树种的一个顶点，将它作为所谓的有根树的根。对有根树的描述中，根通常放在最顶上（树的第0层），邻接根的顶点放在根的下面，再下面是跟根距离两条边的顶点，然后以此类推。</p>
<p>有根树扮演很重要的角色，远比自由树重要，它们常常被简称为“树”。也就是说“树”通常是指有根树。</p>
<h4 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h4><p>有序树是一颗有根树，树中每个顶点的所有子女都是有序的。</p>
<h2 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h2><p>分析算法效率一般框架一般有两种：时间效率和空间效率</p>
<ul>
<li>时间雄安率指出算法的运行速度，空间效率涉及算法需要的额外空间。</li>
<li>算法的时间效率主要用它输入规模的函数来度量。该函数计算算法基本操作的执行次数。基本操作是总云心赶时间中工先最大的操作。通常它是算法的最内层循环中最费时的操作。</li>
<li>大多算法的效率可以分为以下几类：常数、对数、线性、线性对数、平方、立方和指数</li>
</ul>
<p>o(1)常数, o(n)线性, o(logn)对数, o(nlogn)线性对数</p>
<ul>
<li>比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。</li>
<li>再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。</li>
<li>再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</li>
<li>O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。</li>
<li>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961615&amp;idx=1&amp;sn=8711d52aa7bbd77db02eded67f6cc299&amp;chksm=bd2d0cd38a5a85c5e767e3be02fe885d0bcc95a9755d1e9b52971aac31b4fbca24227102a578&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我时间复杂度了 -  58沈剑  架构师之路</a></p>
<h1 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h1><p><img src="/uploads/algorithm-structure-learning/sort-table.jpg" alt></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序开始的时候，我们扫描整个列表，找到它最小元素，然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素中的最小元素，再和第二个元素交换位置，把第二小元素放在它的最终位置上。</p>
<p>一般来说，在对该列表进行第i遍扫描的时候，该算法在最后n-i个元素中寻找最小元素，然后拿它和Ai交换。</p>
<p>优点：</p>
<ul>
<li>不需要额外的存储空间</li>
<li>键的交换次数仅为O(n)，或者更精确点时n-1次。这个特性使得选择排序优于许多其他排序</li>
</ul>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 不稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/xuanze.gif" alt></p>
<h3 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(in); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[min] &gt; in[j] &#123;</span><br><span class="line">				min = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		in[i], in[min] = in[min], in[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>它比较表中的相邻元素，如果它们是逆序的话，就交换它们的位置。重复多次以后，最终，最大的元素就“沉到”列表最后一个位置。第二遍操作将第二大的元素沉下去。这样一直做，直到n-1遍以后，该列表就排好序了。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<p>该算法属于蛮力法</p>
<h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/bubbleSort.gif" alt></p>
<h3 id="Golang实现-1"><a href="#Golang实现-1" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(in)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> in[j] &gt; in[j+<span class="number">1</span>] &#123;</span><br><span class="line">				in[j], in[j+<span class="number">1</span>] = in[j+<span class="number">1</span>], in[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>另外有一种扩展算法，是以发明者希尔命名-SHELL排序。此排序提供了一种更好的算法来对较大的文件进行排序。</p>
<p>| 时间复杂度 |  O(n²) |<br>| 稳定性 | 稳定 |</p>
<h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-2"><a href="#Golang实现-2" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(in []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">		cur := in[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; in[j]; j-- &#123;</span><br><span class="line">			in[j+<span class="number">1</span>] = in[j]</span><br><span class="line">		&#125;</span><br><span class="line">		in[j+<span class="number">1</span>] = cur</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。</p>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/shellSort.webp" alt></p>
<h3 id="Golang实现-3"><a href="#Golang实现-3" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">	gap := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> gap &lt; length/<span class="number">3</span> &#123;  <span class="comment">// &lt;O(n^(3/2))</span></span><br><span class="line">		gap = gap*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; length; i++ &#123;</span><br><span class="line">			temp := arr[i]</span><br><span class="line">			j := i - gap</span><br><span class="line">			<span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap &#123;</span><br><span class="line">				arr[j+gap] = arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+gap] = temp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并排序（归并排序）"><a href="#合并排序（归并排序）" class="headerlink" title="合并排序（归并排序）"></a>合并排序（归并排序）</h2><p>合并排序是成功应用分治技术的一个完美例子。对于一个需要排序的数组A[0..n-1]，合并排序把它一分为二：A[0..n/2-1]和A[n/2..n-1]，并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 稳定 |</p>
<p>exmpale:</p>
<p>Input:   {4, 1, 5, 8, 9, 3, 2, 6, 7}<br>Divide: {4, 1, 5, 8}, {9, 3, 2, 6, 7}<br>Divide: {4, 1}, {5, 8}, {9, 3}, {2, 6}, {7}<br>Divide: {4}, {1}, {5}, {8}, {9}, {3}, {2}, {6}, {7}</p>
<p>Merge: {1, 4}, {5, 8}, {3, 9}, {2, 6}, {7}<br>Merge: {1, 4, 5, 8}, {2, 3, 6, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 8, 9}, {7}<br>Merge: {1, 2, 3, 4, 5, 6, 7 ,8, 9}</p>
<h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/insertionSort.gif" alt></p>
<h3 id="Golang实现-4"><a href="#Golang实现-4" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(in []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> in</span><br><span class="line">	&#125;</span><br><span class="line">	mid := <span class="built_in">len</span>(in) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> merge(mergeSort(in[:mid]), mergeSort(in[mid:]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] &#123;</span><br><span class="line">			result[i] = left[<span class="number">0</span>]</span><br><span class="line">			left = left[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result[i] = right[<span class="number">0</span>]</span><br><span class="line">			right = right[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(left); j++ &#123;</span><br><span class="line">		result[i] = left[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(right); j++ &#123;</span><br><span class="line">		result[i] = right[j]</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于分治思想的重要排序算法，不像合并排序是按照元素在数组中的位置对它们进行划分，快速排序按照元素的值对它们进行划分。划分是对给定数组中的元素的重新排列。使得A[s]左边的元素都小于等于A[s]，而所有A[s]右边的元素都大于等于A[s]；</p>
<p>显然，建立一个划分以后，A[s]已经位于它在有序数组中的最终位置，接下来我们可以继续对A[s]前和A[s]后的子数组分别进行排序。</p>
<p>注意它与合并排序不同之处在于：</p>
<ul>
<li>在合并排序算法中，将问题划分成两个子问题是很快的，算法的主要工作在于合并子问题的解；</li>
<li>而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并问题的解了。</li>
</ul>
<p>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p>它的最内层循环效率非常，使得在处理随机排列的数组时，速度要比合并排序快（对于堆排序也是如此。堆排序是另一种效率为nlogn的算法）。</p>
<p>人们对这个基本算法，进行了坚持不懈的改良，研究人员在这一领域的重要成果包括：</p>
<ul>
<li>更好的中轴选择方法：例如随即快速排序，它使用随机的元素作为中轴；三平分划分法，它以数组最左边、最右边和最中间的元素的中位数作为中轴。</li>
<li>当子数组足够小时（对于大多数计算机系统而言，元素数为5-15），改用插入排序方法，或者根本就不再对小数组进行排序，而是在快速排序结束后再使用插入排序的方法对整个近似有序的数组进行排序。</li>
<li>一些划分方法的挨近，例如三路划分，将数组分成三段，每段的元素分别小于、等于、大于中轴元素。</li>
</ul>
<p>根据国际上快速排序的权威塞奇威克的说法，如果同时应用这些改进措施，可以将该算法的运行时间削减20%-30%</p>
<p>但是与其他算法一样，快速排序算法也又缺点，它是不稳定的。同时它还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到O(logn)，但是它还是比堆排序O(1)的空间效率差。</p>
<p>最坏情况下，是整个序列都已经有序且完全倒序 ，<br>此时，快速排序退化为冒泡排序，要比较n*（n-1）/2次才能完成</p>
<p>| 时间复杂度 |  O(nlogn) |<br>| 稳定性 | 不稳定 |</p>
<h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="/uploads/algorithm-structure-learning/quickSort.gif" alt><br><img src="/uploads/algorithm-structure-learning/quickSort2.gif" alt></p>
<h3 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> _quickSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">		partition := partition(arr, left, right)</span><br><span class="line">		_quickSort(arr, left, partition<span class="number">-1</span>)</span><br><span class="line">		_quickSort(arr, partition+<span class="number">1</span>, right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	pivot := left</span><br><span class="line">	index := left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := index; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; arr[pivot] &#123;</span><br><span class="line">			arr[i], arr[index] = arr[index], arr[i]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[pivot], arr[index<span class="number">-1</span>] = arr[index<span class="number">-1</span>], arr[pivot]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 堆排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在一个标准的字典中可能会把“堆”定义成元素的无序堆积，但被称为“堆”的数据结构绝对不符合这个定义。我们更应该把它说成是一种灵巧的，部分有序的数据结构，它尤其使用用来实现优先级队列。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请回忆一下，优先队列是元素的一个集合，其中每个元素都包含一个被成为元素优先级的可排序属性。优先队列支持下面的：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 找出一个具有最高优先级的元素（即最大元素）</span></span><br><span class="line"><span class="string">* 删除一个具有最高优先级的元素</span></span><br><span class="line"><span class="string">* 添加一个元素到集合中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主要是由于这些操作的有效实现，使得堆既龄人感兴趣，又非常具有实用价值。在诸如操作系统的作页调度以及通信网络中流量管理等场景中，非常需要采用优先队列。并且优先队列也常常出现在一些重要的算法，例如Prim算法，Dijkstra算法，曼哈夫编码，还有在分支界限中的应用。堆排序是一种在理论上十分重要的排序算法，它的基础也依赖于堆这一数据结构。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span></span><br><span class="line"><span class="string">小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆排序的时间雄安率和合并排序的时间效率属于同一类，并且不同的是，堆排序是在位的，也就是说，它并不需要任何额外的存储空间。针对随机文件的计时实验指出，堆排序比快速排序运行得慢，但是和合并排序相比还是有竞争力的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">| 时间复杂度 |  O(nlogn) |</span></span><br><span class="line"><span class="string">| 稳定性 | 不稳定 |</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 堆</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">堆可以定义为一颗二叉树，树的节点中包含键（每个节点一个键），并且树满足下面两个条件：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 树的形状要求---这个二叉树是基本完备的（或者简称完全二叉树），这意味着，树的每一层都是满的，除了最后一层最右边的元素可能缺位。</span></span><br><span class="line"><span class="string">1. 父母优势要求，又称为堆特性--每个节点的键都要大于或者等于它的子女的键（对于任何叶子我们认为这个条件都是自动满足的）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请注意，在堆中，键值是从上到下排序的。也就是说，在任何从根到某个叶子的路径上，键值的序列是递减的（如果允许相等键的存在，则是非递增的）。然而，键值之间并不存在从左到右的次序。也就是说，在树的同一层的节点之间，不存在任何关系，更一般地说，在同一节点的左右子树之间也没有任何关系。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面列出堆的重要特性，这些特性都是不难证明的：</span></span><br><span class="line"><span class="string">1. 只存在一颗n个节点的完全二叉树，它的高度等于log2n</span></span><br><span class="line"><span class="string">1. 堆的根总是包含了堆的最大元素</span></span><br><span class="line"><span class="string">1. 堆的一个节点以及该节点的子孙也是一个堆</span></span><br><span class="line"><span class="string">1. 可以用数组来实现堆，方法是用从上到下、从左到右的方式来记录堆的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">虽然大多数处理堆的算法来说，把堆想象成二叉树可以容易地理解它们所隐含的思想，但对于实际实现来说，使用数组会简单得多，效率也高得多。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在数组中，对于一个位于父母位置i(1&lt;=i&lt;=n/2)的键来说，它的子女将会在2i和2i+1，相应地，对于位于i(2&lt;=i&lt;=n)的键来说，它的父母将会在i/2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 动画演示</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort2.gif)</span></span><br><span class="line"><span class="string">![](/uploads/algorithm-structure-learning/heapSort3.gif)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Golang实现</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	heapify(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">		siftDown(arr, <span class="number">0</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (<span class="built_in">len</span>(arr) - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown</span><span class="params">(heap []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := lo</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child &gt;= hi &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; hi &amp;&amp; heap[child] &gt; heap[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> heap[root] &gt; heap[child] &#123;</span><br><span class="line">			heap[root], heap[child] = heap[child], heap[root]</span><br><span class="line">			root = child</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>敲重点</p>
<ul>
<li>这是个线性时间复杂度的算法</li>
<li>不是通过比较的方式</li>
<li>必须有明确的范围</li>
<li>数据规模不能太大，因为需要额外开辟数组空间</li>
</ul>
<p>计数排序的核心是，空间换时间</p>
<p>计数排序，时间复杂度为O(n)；<br>当待排序元素个数很多，但值域范围很窄时，计数排序是很节省空间的；</p>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/uploads/algorithm-structure-learning/countingSort.gif" alt></p>
<h3 id="Golang实现-5"><a href="#Golang实现-5" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(arr []<span class="keyword">int</span>, maxValue <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bucketLen := maxValue + <span class="number">1</span></span><br><span class="line">	bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, bucketLen)</span><br><span class="line"></span><br><span class="line">	sortedIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		bucket[arr[i]] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketLen; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> bucket[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			arr[sortedIndex] = i</span><br><span class="line">			sortedIndex += <span class="number">1</span></span><br><span class="line">			bucket[i] -= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p>
<p>桶排序的基本思想：</p>
<p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p>
<p>桶排序的适用范围是，待排序的元素能够均匀分布在某一个范围[MIN, MAX]之间。</p>
<p>桶排序，是一种复杂度为O(n)的排序<br>桶排序，是一种稳定的排序<br>桶排序，适用于数据均匀分布在一个区间内的场景</p>
<h3 id="Golang实现-6"><a href="#Golang实现-6" class="headerlink" title="Golang实现"></a>Golang实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(array []<span class="keyword">int</span>, bucketSize <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> max, min <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nBuckets := <span class="keyword">int</span>(max-min)/bucketSize + <span class="number">1</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, nBuckets)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nBuckets; i++ &#123;</span><br><span class="line">		buckets[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> array &#123;</span><br><span class="line">		idx := <span class="keyword">int</span>(n-min) / bucketSize</span><br><span class="line">		buckets[idx] = <span class="built_in">append</span>(buckets[idx], n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sorted := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bucket) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			insertionSort(bucket)</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, bucket...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p>
<p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p>
<p>基数排序适用于：</p>
<ol>
<li>数据范围较小，建议在小于1000</li>
<li><p>每个数值都要大于等于0</p>
<p>算法描述</p>
</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<ul>
<li>基的选取，可以先从个位开始，也可以先从十位开始，结果是一样的；</li>
<li>基数排序，是一种稳定的排序；</li>
<li><p>时间复杂度，可以认为是线性的O(n)；</p>
<h3 id="LSD动画演示"><a href="#LSD动画演示" class="headerlink" title="LSD动画演示"></a>LSD动画演示</h3><p><img src="/uploads/algorithm-structure-learning/radixSort.gif" alt></p>
<h3 id="Golang实现-7"><a href="#Golang实现-7" class="headerlink" title="Golang实现"></a>Golang实现</h3><blockquote>
<p>这里bucket扩展为两倍支持负数加入排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[<span class="number">0</span>])))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		v := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(arr[i])))</span><br><span class="line">		<span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxDigit := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> max/<span class="number">10</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">		maxDigit++</span><br><span class="line">		max = max / <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> dev, j := <span class="number">1</span>, <span class="number">0</span>; j &lt; maxDigit; j++ &#123;</span><br><span class="line"></span><br><span class="line">		buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">			idx := (arr[i]/dev)%<span class="number">10</span> + <span class="number">10</span></span><br><span class="line">			buckets[idx] = <span class="built_in">append</span>(buckets[idx], arr[i])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">				arr[pos] = v</span><br><span class="line">				pos++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev = dev * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="常见关于排序的问题"><a href="#常见关于排序的问题" class="headerlink" title="常见关于排序的问题"></a>常见关于排序的问题</h2><h3 id="TOP-K"><a href="#TOP-K" class="headerlink" title="TOP K"></a>TOP K</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961587&amp;idx=1&amp;sn=54bf39db7043cc638315caf70f24d94b&amp;chksm=bd2d0d2f8a5a84395246be4522d10fbfc1f744658047d5fb3fad8e9f3c3d76baab3a2ce84867&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">拜托，面试别再问我TopK了</a></p>
<h4 id="TOP-K-无序"><a href="#TOP-K-无序" class="headerlink" title="TOP K 无序"></a>TOP K 无序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	buildHeap(arr, k)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; arr[<span class="number">0</span>] &#123;</span><br><span class="line">			arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">			siftDown2(arr, <span class="number">0</span>, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := (k - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		siftDown2(arr, i, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftDown2</span><span class="params">(arr []<span class="keyword">int</span>, low, high <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	root := low</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		child := root*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> child &gt;= high &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; high &amp;&amp; arr[child] &gt; arr[child+<span class="number">1</span>] &#123;</span><br><span class="line">			child++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> arr[root] &gt; arr[child] &#123;</span><br><span class="line">			arr[root], arr[child] = arr[child], arr[root]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TOP-K-有序"><a href="#TOP-K-有序" class="headerlink" title="TOP K 有序"></a>TOP K 有序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKbubble</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr)-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>(result, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>-i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h1 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>当你想用二叉树存储大量数据时，只需遵循一条简单的规则：当使用中序遍历时，在每个节点中存储的数据的键将具有递增的顺序。通过遵循这条规则，现在可以把二叉树视作二叉查找树。</p>
<p>二叉搜索树又名有序二叉树，结点元素按固定次序排布，使得我们可以在进行查找等操作时使用二分搜索提高效率。</p>
<p><img src="/uploads/algorithm-structure-learning/bsearcht.png" alt></p>
<p>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</p>
<h2 id="自平衡二叉查找树"><a href="#自平衡二叉查找树" class="headerlink" title="自平衡二叉查找树"></a>自平衡二叉查找树</h2><p>使用二叉查找树我们赢得了查找、插入和删除的时间效率，这些操作都属于O(logn)，但这仅仅在平均情况下成力，在最差情况下，这些操作属于O(n)，因为这种树可能会退化成一种严重不平衡的树，树的高度为n-1。</p>
<p>计算机科学家付出了大量的经历食土寻找一种既能够保留经典二叉查找树的好特性，又能避免它退化到最差情况的数据结构，我们这里所说的好特性主要是指它对于字典操作的对数效率以及它维护了集合元素的顺序。科学家们现在给了两套方案：</p>
<ul>
<li>第一种方法属于实例化简得类型：把一颗不平衡得二叉查找树转变为平衡得形式。因为，我们说这类树是自平衡得。这个思想的特定实现之间的区别在于它们对于平衡的定义是不同的。一颗AVL树要求它的每个节点左右子树的高度差不能超过1。一颗红黑树能够容忍同一节点的一颗子树的高度是另一颗子树的两倍。如果一个节点的插入或者删除产生了一颗违背平衡要求的树，我们就从一系列成为旋转的特定变换种选择一种，重新构造这棵树，使得这颗树满足平衡要求。</li>
<li>第二种方法属于改变表现得类型：它允许一颗查找树的单个节点种不止包含一个元素。这种树的特例是2-3树、2-3-4树以及B树，它们的区别在于查找树的单个节点种能够容纳的元素个数，但它们都达到了很好的平衡。</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>一颗AVL树是一颗二叉查找树，其中每个节点的平衡因子定义为该节点左子树和右子树的高度差，这个平衡因子要么为0，要么为+1或者-1（一颗空树的高度定义为-1。当然，平衡因子也可以定义为左右子树的叶子数的差，而不是高度差）。<br>AVL查找和插入操作的效率都为O(logn)，然后这些令人印象深刻的效率特性是有代价，AVL树的缺点是频繁的旋转、需要维护树的节点的平衡以及总体上的复杂性，尤其是删除操作。这些缺点阻碍了AVL树成为实现字典的标准结构。但同时所蕴含的思想通过旋转来重新平衡一颗二叉树-被证明是富有成效的，也导致人们发现了经典二查找树的其他一些令人感兴趣的变化形式。</p>
<p>最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL</p>
<p>平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。我们可以推出AVL树适合用于插入删除次数比较少，但查找多的情况</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是一种可以包含两种类型节点的树：2节点和3节点。一个2节点值包含一个键K和两个子女（换句话说，一个2节点和一颗经典二叉查找树的节点类型是相同的）。一个3节点包含两个有序的键K1和K2（K1&lt;K2)，并且有3个子女。最左边的子女作为键值小于K1的子树的根，，中间的子女作为键值位于K1和K2之间的子树的根，最右边的子女作为键值大于K2的子树的根。</p>
<p>2-3树的最后一个要求是，树种的所有叶子必须位于同一层，也就是说，一颗2-3树总是高度平衡的：对于每个叶子来说，从树的根到叶子的路径长度都是相同。为了这个特性，我们付出的“代价”是允许查找树的一个节点包含不止一个键。</p>
<p>在2-3树中查找一个给定的键K是非常简单的。我们从根开始，如果根是一个2节点，我们就把它当作一个二叉查找树来操作：如果K等于根的键值，算法停止；如果K小于或者大于根的键值，我们分别在左子树或右子树中继续查找。如果根是一个3节点，在不超过两次比较之后，我们就能知道，是停止查找（K等于根的值），还是应该在根的3颗子树的哪颗中继续查找。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>实现AVL树的一种更容易的方式是：使用被称为红黑树的概念。它利用了两个新概念：</p>
<ol>
<li>在红黑树中，数据只存储在树的叶节点中。也就是说，只有不带子节点的节点才能包含实际的数据。内部节点只用引用。</li>
<li>将每个节点都视作带有红色或黑色。节点的颜色有下面的规则决定：</li>
</ol>
<ul>
<li>所有叶节点都是黑色</li>
<li>在沿着从根出发的任何路径上都不允许出现连续的红色节点</li>
<li><p>树的所有叶节点都必须具有相同的黑色深度，它被定义为叶节点与根之间的黑色节点数量减1</p>
</li>
<li><p>任何一个节点都有颜色，黑色或者红色</p>
</li>
<li>根节点是黑色的</li>
<li>父子节点之间不能出现两个连续的红节点</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等</li>
<li>空节点被认为是黑色的</li>
</ul>
<p>map和set都是用红黑树实现的<br>著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块<br>epoll在内核中的实现，用红黑树管理事件块<br>nginx中，用红黑树管理timer等<br>Java的TreeMap实现</p>
<p>平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><blockquote>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961486&amp;idx=1&amp;sn=b319a87f87797d5d662ab4715666657f&amp;chksm=bd2d0d528a5a84446fb88da7590e6d4e5ad06cfebb5cb57a83cf75056007ba29515c85b9a24c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">数据库索引，到底是什么做的 – 略浅显</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">深入从B树、B+树、B*树谈到R 树</a></li>
</ul>
</blockquote>
<p>B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。</p>
<ul>
<li>不再是二叉搜索，而是m叉搜索；</li>
<li>叶子节点，非叶子节点，都存储数据；</li>
<li>中序遍历，可以获得所有节点；</li>
</ul>
<p>但在此之前，咱们还得简单回顾下一棵m阶的B 树的特性，如下：</p>
<ul>
<li>树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。</li>
<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；</li>
<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<ol>
<li>Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。</li>
<li>Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 </li>
<li>除根结点之外的结点的关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1（叶子结点也必须满足此条关于关键字数的性质，根结点除外）</li>
</ol>
</li>
</ul>
<p>B树为何适合做索引？</p>
<ul>
<li>由于是m分叉的，高度能够大大降低</li>
<li>每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO；</li>
</ul>
<p>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO</p>
<p>我们知道，B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。与本blog之前介绍的红黑树很相似，但在降低磁盘I/0操作方面要更好一些。许多数据库系统都一般使用B树或者B树的各种变形结构，如下文即将要介绍的B+树，B*树来存储信息。 B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p>
<p>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</p>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/m0_37535642/article/details/72356737" target="_blank" rel="noopener">磁盘块是什么？它的大小？</a></li>
<li><a href="http://www.cnblogs.com/valor-xh/p/6669897.html" target="_blank" rel="noopener">电脑中常用的“扇区”、“簇”、“块”、“页”等概念</a></li>
</ul>
</blockquote>
<p>一棵含有N个总关键字数的m阶的B树的最大高度是多少?<br>log_ceil（m/2）(N+1)/2 + 1 </p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树，如上图，仍是m叉搜索树，在B树的基础上，做了一些改进：</p>
<ul>
<li>非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；</li>
<li>叶子之间，增加了链表，获取所有节点，不再需要中序遍历；</li>
</ul>
<p>这些改进让B+树比B树有更优的特性：</p>
<ul>
<li>范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；</li>
<li>叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储</li>
<li>非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引</li>
</ul>
<p>最后，量化说下，为什么m叉的B+树比二叉搜索树的高度大大大大降低？</p>
<p>大概计算一下：</p>
<p>(1)局部性原理，将一个节点的大小设为一页，一页4K，假设一个KEY有8字节，一个节点可以存储500个KEY，即j=500</p>
<p>(2)m叉树，大概m/2&lt;= j &lt;=m，即可以差不多是1000叉树</p>
<p>(3)那么：<br>一层树：1个节点，1<em>500个KEY，大小4K<br>二层树：1000个节点，1000</em>500=50W个KEY，大小1000<em>4K=4M<br>三层树：1000</em>1000个节点，1000<em>1000</em>500=5亿个KEY，大小1000<em>1000</em>4K=4G</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p><a href="https://blog.csdn.net/sunhuaqiang1/article/details/52463257" target="_blank" rel="noopener">Trie树(字典树)</a></p>
<p>Trie并不是平衡树，也不一定非要有序。它主要用于前缀匹配，比如字符串，比如说ip地址，如果字符串长度是固定或者说有限的，那么Trie的深度是可控制的，你可以得到很好的搜索效果，而且插入新数据后不用平衡。不过Trie不像B-tree通用性那么强，你需要针对你自己的实际应用来设计你自己的Trie，比如说你做个字典应用，是用26个字母，还是用unicode来前缀匹配？如果是ip地址搜索，是用二进制来前缀拼配，还是八进制来匹配？</p>
<h1 id="散列法"><a href="#散列法" class="headerlink" title="散列法"></a>散列法</h1><p>散列法的基本思想就是把键分布在一个称为散列表(hash table)的一维数组H[0..m-1]中。我们可以通过对每个键计算某些被称为散列函数(hash function)的与定义函数h的值，来完成这种分布。该函数为每个键指定一个称为散列地址的位于0到m-1之间的整数。</p>
<p>一般来说，散列函数需要满足下列多少有些冲突的要求：</p>
<ul>
<li>散列表的长度相对于键的个数不应过大，但同时也不应过小从而影响算法的时间效率</li>
<li>散列函数需要把键在散列表的单元格中尽可能均匀地分布（因为这个要求，m的值常常被选定为质数。对于大多数应用来说，这个要求还使得散列函数必须考虑键的所有比特位，而不仅仅是其中的某个位）</li>
<li>散列函数必须容易计算</li>
</ul>
<p>显然如果选择的散列表长度m小于键的数量n，会遇到碰撞，这是一种两个（或者更多）键被散列到散列表的同一个单元格的现象。但即使m相对于n足够大，这种碰撞还是会发生的，实际上，在最坏的情况下，所有的键都会散列到散列表同一个单元格中。幸运的是，通过选择适当的散列表长度和散列函数，这种情况很少发生。然后，每一种散列方法都必须要有一种碰撞解决机制。散列有两个主要版本：开散列，也称为分离链；闭散列，也称为开式寻址，在这两个主要版本中，他们的碰撞解决机制是不同的。</p>
<p>在字典的实现中，平衡查找树是散列表的主要竞争对手，因此有必要将两者的主要特征进行比较：</p>
<ul>
<li>渐近时间效率：在使用散列表时，查找、插入、删除操作的效率平均情况下是0(1)，最坏情况（可能性很小）是O(n)。而对于平衡查找树来说，这些操作的时间效率平均和最坏情况都是O(logn)</li>
<li>有序性保留：相对于平衡查找树，散列表并没有假定键是有序的，也通常不保证它们是有序性。这使得散列不太适用于要求按序遍历键值和按范围查询的应用。例如计算位于某个上界和下界之间的键值的个数。</li>
</ul>
<h2 id="开散列（分离链）"><a href="#开散列（分离链）" class="headerlink" title="开散列（分离链）"></a>开散列（分离链）</h2><p>在开散列中，键被存储在附着于散列表单元格上的链表中。每个链表包含着所有散列到该单元格的键。</p>
<p>一般来说，查找的效率取决于链表的长度，而这个长度又取决于字典和散列表的长度以及散列函数的质量。如果该散列函数大致均匀将n个键分布在散列表的m个单元格中，每个链表的长度大约相当于n/m个键。其比率a=n/m被称为散列表的负载因子，它在散列的效率中扮演了一个至关重要的角色。具体来说，假设在成功查找和不成功查找中平均需检查的指针个数分别位S和U，那么它们的值分别应是：</p>
<p>S约等于a+a/2 U=a</p>
<h2 id="闭散列（开式寻址）"><a href="#闭散列（开式寻址）" class="headerlink" title="闭散列（开式寻址）"></a>闭散列（开式寻址）</h2><p>在闭散列中，所有的键都存储在散列表本身中，而没有使用链表（当然，意味着表的长度m至少必须和键的数量n一样大），可以采用不同的策略来解决碰撞，最简单的一种称为线性探查，它检查碰撞发生处后面的单元格。如果该单元格为空，新的键就放置此处；如果下一个单元格被占用了，就检查单元格的直接后继是否可用，以此类推。请注意，如果到达了散列表的尾部，查找就折回表的开始处。也就是说，我们把表作为一个循环数组。</p>
<p>虽然对于这个散列版本来说，查找和插入操作时简单而直接的，但是删除操作则不是这样。一个简单的方法时使用“延迟删除”，也就是说，用一个特殊的符号来标记曾被占用过的位置，以把它们和那些从未被占用过的位置区别开来。</p>
<h1 id="参加面试问题"><a href="#参加面试问题" class="headerlink" title="参加面试问题"></a>参加面试问题</h1><h2 id="两个有序集合合并的方法"><a href="#两个有序集合合并的方法" class="headerlink" title="两个有序集合合并的方法"></a>两个有序集合合并的方法</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959895&amp;idx=1&amp;sn=de25ce2544c088ff9be0b93fd3ea4d15&amp;chksm=bd2d078b8a5a8e9d5ae4339a683d3f980ff2994f3c10c4081c7bab7f0d77f37521de95e974bf&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入浅出搜索架构引擎、方案与细节（上）</a></p>
<h3 id="for-for，土办法，时间复杂度O-nn"><a href="#for-for，土办法，时间复杂度O-nn" class="headerlink" title="for  for，土办法，时间复杂度O(nn)"></a>for <em> for，土办法，时间复杂度O(n</em>n)</h3><p>每个搜索词命中的网页是很多的，O(n*n)的复杂度是明显不能接受的。倒排索引是在创建之初可以进行排序预处理，问题转化成两个有序的list求交集，就方便多了。</p>
<h3 id="有序list求交集，拉链法"><a href="#有序list求交集，拉链法" class="headerlink" title="有序list求交集，拉链法"></a>有序list求交集，拉链法</h3><p>有序集合1{1,3,5,7,8,9}</p>
<p>有序集合2{2,3,4,5,6,7}</p>
<p>两个指针指向首元素，比较元素的大小：</p>
<p>（1）如果相同，放入结果集，随意移动一个指针</p>
<p>（2）否则，移动值较小的一个指针，直到队尾</p>
<p>这种方法的好处是：</p>
<p>（1）集合中的元素最多被比较一次，时间复杂度为O(n)</p>
<p>（2）多个有序集合可以同时进行，这适用于多个分词的item求url_id交集</p>
<p>这个方法就像一条拉链的两边齿轮，一一比对就像拉链，故称为拉链法</p>
<h3 id="分桶并行优化"><a href="#分桶并行优化" class="headerlink" title="分桶并行优化"></a>分桶并行优化</h3><p>数据量大时，url_id分桶水平切分+并行运算是一种常见的优化方法，如果能将list1&lt;url_id&gt;和list2&lt;url_id&gt;分成若干个桶区间，每个区间利用多线程并行求交集，各个线程结果集的并集，作为最终的结果集，能够大大的减少执行时间。</p>
<p>举例：</p>
<p>有序集合1{1,3,5,7,8,9, 10,30,50,70,80,90}</p>
<p>有序集合2{2,3,4,5,6,7, 20,30,40,50,60,70}</p>
<p>求交集，先进行分桶拆分：</p>
<p>桶1的范围为[1, 9]</p>
<p>桶2的范围为[10, 100]</p>
<p>桶3的范围为[101, max_int]</p>
<p>于是：</p>
<p>集合1就拆分成</p>
<p>集合a{1,3,5,7,8,9}</p>
<p>集合b{10,30,50,70,80,90}</p>
<p>集合c{}</p>
<p>集合2就拆分成</p>
<p>集合d{2,3,4,5,6,7}</p>
<p>集合e{20,30,40,50,60,70}</p>
<p>集合e{}</p>
<p>每个桶内的数据量大大降低了，并且每个桶内没有重复元素，可以利用多线程并行计算：</p>
<p>桶1内的集合a和集合d的交集是x{3,5,7}</p>
<p>桶2内的集合b和集合e的交集是y{30, 50, 70}</p>
<p>桶3内的集合c和集合d的交集是z{}</p>
<p>最终，集合1和集合2的交集，是x与y与z的并集，即集合{3,5,7,30,50,70}</p>
<h3 id="bitmap再次优化"><a href="#bitmap再次优化" class="headerlink" title="bitmap再次优化"></a>bitmap再次优化</h3><p>数据进行了水平分桶拆分之后，每个桶内的数据一定处于一个范围之内，如果集合符合这个特点，就可以使用bitmap来表示集合</p>
<p>水平分桶，bitmap优化之后，能极大提高求交集的效率，但时间复杂度仍旧是O(n)</p>
<p>bitmap需要大量连续空间，占用内存较大</p>
<h3 id="跳表skiplist"><a href="#跳表skiplist" class="headerlink" title="跳表skiplist"></a>跳表skiplist</h3><p>有序链表集合求交集，跳表是最常用的数据结构，它可以将有序集合求交集的复杂度由O(n)降至O(log(n))</p>
<p>集合1{1,2,3,4,20,21,22,23,50,60,70}</p>
<p>集合2{50,70}</p>
<p>要求交集，如果用拉链法，会发现1,2,3,4,20,21,22,23都要被无效遍历一次，每个元素都要被比对，时间复杂度为O(n)，能不能每次比对“跳过一些元素”呢？</p>
<p>集合1{1,2,3,4,20,21,22,23,50,60,70}建立跳表时，一级只有{1,20,50}三个元素，二级与普通链表相同</p>
<p>集合2{50,70}由于元素较少，只建立了一级普通链表</p>
<p>如此这般，在实施“拉链”求交集的过程中，set1的指针能够由1跳到20再跳到50，中间能够跳过很多元素，无需进行一一比对，跳表求交集的时间复杂度近似O(log(n))，这是搜索引擎中常见的算法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.bookstack.cn/read/JS-Sorting-Algorithm" target="_blank" rel="noopener">十大经典排序算法</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/10/linux-learning/" rel="next" title="Linux学习笔记">
                <i class="fa fa-chevron-left"></i> Linux学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zpl">
          <p class="site-author-name" itemprop="name">Zpl</p>
           
              <p class="site-description motion-element" itemprop="description">随便记一下，顺便骚一下</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要的问题类型"><span class="nav-number">1.1.</span> <span class="nav-text">重要的问题类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">1.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">1.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串处理"><span class="nav-number">1.4.</span> <span class="nav-text">字符串处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图问题"><span class="nav-number">1.5.</span> <span class="nav-text">图问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合问题"><span class="nav-number">1.6.</span> <span class="nav-text">组合问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几何问题"><span class="nav-number">1.7.</span> <span class="nav-text">几何问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值问题"><span class="nav-number">1.8.</span> <span class="nav-text">数值问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.9.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性数据结构"><span class="nav-number">1.9.1.</span> <span class="nav-text">线性数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#双向链表"><span class="nav-number">1.9.1.2.1.</span> <span class="nav-text">双向链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优先队列"><span class="nav-number">1.9.1.3.1.</span> <span class="nav-text">优先队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">1.9.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有根树"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">有根树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序树"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">有序树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法效率分析基础"><span class="nav-number">1.10.</span> <span class="nav-text">算法效率分析基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序-1"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">2.1.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示"><span class="nav-number">2.1.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现"><span class="nav-number">2.1.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">2.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动画演示"><span class="nav-number">2.4.1.</span> <span class="nav-text">动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并排序（归并排序）"><span class="nav-number">2.5.</span> <span class="nav-text">合并排序（归并排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">2.6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动图演示-4"><span class="nav-number">2.6.1.</span> <span class="nav-text">动图演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang-实现"><span class="nav-number">2.6.2.</span> <span class="nav-text">Golang 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-number">2.7.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动画演示-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-5"><span class="nav-number">2.7.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">2.8.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-6"><span class="nav-number">2.8.1.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">2.9.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LSD动画演示"><span class="nav-number">2.9.1.</span> <span class="nav-text">LSD动画演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Golang实现-7"><span class="nav-number">2.9.2.</span> <span class="nav-text">Golang实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见关于排序的问题"><span class="nav-number">2.10.</span> <span class="nav-text">常见关于排序的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TOP-K"><span class="nav-number">2.10.1.</span> <span class="nav-text">TOP K</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TOP-K-无序"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">TOP K 无序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TOP-K-有序"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">TOP K 有序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表-1"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树-1"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">4.1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉查找树"><span class="nav-number">4.2.</span> <span class="nav-text">二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自平衡二叉查找树"><span class="nav-number">4.3.</span> <span class="nav-text">自平衡二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL树"><span class="nav-number">4.3.1.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">4.3.2.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">4.3.3.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B树"><span class="nav-number">4.3.4.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">4.3.5.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树"><span class="nav-number">4.3.6.</span> <span class="nav-text">Trie树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列法"><span class="nav-number">5.</span> <span class="nav-text">散列法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开散列（分离链）"><span class="nav-number">5.1.</span> <span class="nav-text">开散列（分离链）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭散列（开式寻址）"><span class="nav-number">5.2.</span> <span class="nav-text">闭散列（开式寻址）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参加面试问题"><span class="nav-number">6.</span> <span class="nav-text">参加面试问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#两个有序集合合并的方法"><span class="nav-number">6.1.</span> <span class="nav-text">两个有序集合合并的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for-for，土办法，时间复杂度O-nn"><span class="nav-number">6.1.1.</span> <span class="nav-text">for  for，土办法，时间复杂度O(nn)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序list求交集，拉链法"><span class="nav-number">6.1.2.</span> <span class="nav-text">有序list求交集，拉链法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分桶并行优化"><span class="nav-number">6.1.3.</span> <span class="nav-text">分桶并行优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap再次优化"><span class="nav-number">6.1.4.</span> <span class="nav-text">bitmap再次优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表skiplist"><span class="nav-number">6.1.5.</span> <span class="nav-text">跳表skiplist</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zpl</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
